/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./js/imask.js":
/*!*********************!*\
  !*** ./js/imask.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { "@babel/helpers - typeof"; return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof2(obj); }
(function (global, factory) {
  ( false ? undefined : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function (exports) {
  'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof2(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);
        var desc;
        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            return false;
          }
          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }
        return true;
      };
    }
    return set(target, property, value, receiver);
  }
  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error('failed to set property');
    }
    return value;
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /**
    Provides details of changing model value
    @param {Object} [details]
    @param {string} [details.inserted] - Inserted symbols
    @param {boolean} [details.skip] - Can skip chars
    @param {number} [details.removeCount] - Removed symbols count
    @param {number} [details.tailShift] - Additional offset if any changes occurred before tail
  */
  var ChangeDetails = /*#__PURE__*/function () {
    /** Inserted symbols */

    /** Can skip chars */

    /** Additional offset if any changes occurred before tail */

    /** Raw inserted is used by dynamic mask */
    function ChangeDetails(details) {
      _classCallCheck(this, ChangeDetails);
      Object.assign(this, {
        inserted: '',
        rawInserted: '',
        skip: false,
        tailShift: 0
      }, details);
    }
    /**
      Aggregate changes
      @returns {ChangeDetails} `this`
    */

    _createClass(ChangeDetails, [{
      key: "aggregate",
      value: function aggregate(details) {
        this.rawInserted += details.rawInserted;
        this.skip = this.skip || details.skip;
        this.inserted += details.inserted;
        this.tailShift += details.tailShift;
        return this;
      }
      /** Total offset considering all changes */
    }, {
      key: "offset",
      get: function get() {
        return this.tailShift + this.inserted.length;
      }
    }]);
    return ChangeDetails;
  }();

  /** Checks if value is string */

  function isString(str) {
    return typeof str === 'string' || str instanceof String;
  }
  /**
    Direction
    @prop {string} NONE
    @prop {string} LEFT
    @prop {string} FORCE_LEFT
    @prop {string} RIGHT
    @prop {string} FORCE_RIGHT
  */

  var DIRECTION = {
    NONE: 'NONE',
    LEFT: 'LEFT',
    FORCE_LEFT: 'FORCE_LEFT',
    RIGHT: 'RIGHT',
    FORCE_RIGHT: 'FORCE_RIGHT'
  };
  /** */

  function forceDirection(direction) {
    switch (direction) {
      case DIRECTION.LEFT:
        return DIRECTION.FORCE_LEFT;
      case DIRECTION.RIGHT:
        return DIRECTION.FORCE_RIGHT;
      default:
        return direction;
    }
  }
  /** Escapes regular expression control chars */

  function escapeRegExp(str) {
    return str.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  function normalizePrepare(prep) {
    return Array.isArray(prep) ? prep : [prep, new ChangeDetails()];
  } // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes

  function objectIncludes(b, a) {
    if (a === b) return true;
    var arrA = Array.isArray(a),
      arrB = Array.isArray(b),
      i;
    if (arrA && arrB) {
      if (a.length != b.length) return false;
      for (i = 0; i < a.length; i++) {
        if (!objectIncludes(a[i], b[i])) return false;
      }
      return true;
    }
    if (arrA != arrB) return false;
    if (a && b && _typeof(a) === 'object' && _typeof(b) === 'object') {
      var dateA = a instanceof Date,
        dateB = b instanceof Date;
      if (dateA && dateB) return a.getTime() == b.getTime();
      if (dateA != dateB) return false;
      var regexpA = a instanceof RegExp,
        regexpB = b instanceof RegExp;
      if (regexpA && regexpB) return a.toString() == b.toString();
      if (regexpA != regexpB) return false;
      var keys = Object.keys(a); // if (keys.length !== Object.keys(b).length) return false;

      for (i = 0; i < keys.length; i++) {
        // $FlowFixMe ... ???
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      }
      for (i = 0; i < keys.length; i++) {
        if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;
      }
      return true;
    } else if (a && b && typeof a === 'function' && typeof b === 'function') {
      return a.toString() === b.toString();
    }
    return false;
  }
  /** Selection range */

  /** Provides details of changing input */

  var ActionDetails = /*#__PURE__*/function () {
    /** Current input value */

    /** Current cursor position */

    /** Old input value */

    /** Old selection */
    function ActionDetails(value, cursorPos, oldValue, oldSelection) {
      _classCallCheck(this, ActionDetails);
      this.value = value;
      this.cursorPos = cursorPos;
      this.oldValue = oldValue;
      this.oldSelection = oldSelection; // double check if left part was changed (autofilling, other non-standard input triggers)

      while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {
        --this.oldSelection.start;
      }
    }
    /**
      Start changing position
      @readonly
    */

    _createClass(ActionDetails, [{
      key: "startChangePos",
      get: function get() {
        return Math.min(this.cursorPos, this.oldSelection.start);
      }
      /**
        Inserted symbols count
        @readonly
      */
    }, {
      key: "insertedCount",
      get: function get() {
        return this.cursorPos - this.startChangePos;
      }
      /**
        Inserted symbols
        @readonly
      */
    }, {
      key: "inserted",
      get: function get() {
        return this.value.substr(this.startChangePos, this.insertedCount);
      }
      /**
        Removed symbols count
        @readonly
      */
    }, {
      key: "removedCount",
      get: function get() {
        // Math.max for opposite operation
        return Math.max(this.oldSelection.end - this.startChangePos ||
        // for Delete
        this.oldValue.length - this.value.length, 0);
      }
      /**
        Removed symbols
        @readonly
      */
    }, {
      key: "removed",
      get: function get() {
        return this.oldValue.substr(this.startChangePos, this.removedCount);
      }
      /**
        Unchanged head symbols
        @readonly
      */
    }, {
      key: "head",
      get: function get() {
        return this.value.substring(0, this.startChangePos);
      }
      /**
        Unchanged tail symbols
        @readonly
      */
    }, {
      key: "tail",
      get: function get() {
        return this.value.substring(this.startChangePos + this.insertedCount);
      }
      /**
        Remove direction
        @readonly
      */
    }, {
      key: "removeDirection",
      get: function get() {
        if (!this.removedCount || this.insertedCount) return DIRECTION.NONE; // align right if delete at right

        return (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) &&
        // if not range removed (event with backspace)
        this.oldSelection.end === this.oldSelection.start ? DIRECTION.RIGHT : DIRECTION.LEFT;
      }
    }]);
    return ActionDetails;
  }();

  /** Provides details of continuous extracted tail */
  var ContinuousTailDetails = /*#__PURE__*/function () {
    /** Tail value as string */

    /** Tail start position */

    /** Start position */
    function ContinuousTailDetails() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var stop = arguments.length > 2 ? arguments[2] : undefined;
      _classCallCheck(this, ContinuousTailDetails);
      this.value = value;
      this.from = from;
      this.stop = stop;
    }
    _createClass(ContinuousTailDetails, [{
      key: "toString",
      value: function toString() {
        return this.value;
      }
    }, {
      key: "extend",
      value: function extend(tail) {
        this.value += String(tail);
      }
    }, {
      key: "appendTo",
      value: function appendTo(masked) {
        return masked.append(this.toString(), {
          tail: true
        }).aggregate(masked._appendPlaceholder());
      }
    }, {
      key: "state",
      get: function get() {
        return {
          value: this.value,
          from: this.from,
          stop: this.stop
        };
      },
      set: function set(state) {
        Object.assign(this, state);
      }
    }, {
      key: "unshift",
      value: function unshift(beforePos) {
        if (!this.value.length || beforePos != null && this.from >= beforePos) return '';
        var shiftChar = this.value[0];
        this.value = this.value.slice(1);
        return shiftChar;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (!this.value.length) return '';
        var shiftChar = this.value[this.value.length - 1];
        this.value = this.value.slice(0, -1);
        return shiftChar;
      }
    }]);
    return ContinuousTailDetails;
  }();

  /**
   * Applies mask on element.
   * @constructor
   * @param {HTMLInputElement|HTMLTextAreaElement|MaskElement} el - Element to apply mask
   * @param {Object} opts - Custom mask options
   * @return {InputMask}
   */
  function IMask(el) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // currently available only for input-like elements
    return new IMask.InputMask(el, opts);
  }

  /** Supported mask type */

  /** Provides common masking stuff */
  var Masked = /*#__PURE__*/function () {
    // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773

    /** @type {Mask} */

    /** */
    // $FlowFixMe no ideas

    /** Transforms value before mask processing */

    /** Validates if value is acceptable */

    /** Does additional processing in the end of editing */

    /** Format typed value to string */

    /** Parse strgin to get typed value */

    /** Enable characters overwriting */

    /** */

    /** */
    function Masked(opts) {
      _classCallCheck(this, Masked);
      this._value = '';
      this._update(Object.assign({}, Masked.DEFAULTS, opts));
      this.isInitialized = true;
    }
    /** Sets and applies new options */

    _createClass(Masked, [{
      key: "updateOptions",
      value: function updateOptions(opts) {
        if (!Object.keys(opts).length) return; // $FlowFixMe

        this.withValueRefresh(this._update.bind(this, opts));
      }
      /**
        Sets new options
        @protected
      */
    }, {
      key: "_update",
      value: function _update(opts) {
        Object.assign(this, opts);
      }
      /** Mask state */
    }, {
      key: "state",
      get: function get() {
        return {
          _value: this.value
        };
      },
      set: function set(state) {
        this._value = state._value;
      }
      /** Resets value */
    }, {
      key: "reset",
      value: function reset() {
        this._value = '';
      }
      /** */
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        this.resolve(value);
      }
      /** Resolve new value */
    }, {
      key: "resolve",
      value: function resolve(value) {
        this.reset();
        this.append(value, {
          input: true
        }, '');
        this.doCommit();
        return this.value;
      }
      /** */
    }, {
      key: "unmaskedValue",
      get: function get() {
        return this.value;
      },
      set: function set(value) {
        this.reset();
        this.append(value, {}, '');
        this.doCommit();
      }
      /** */
    }, {
      key: "typedValue",
      get: function get() {
        return this.doParse(this.value);
      },
      set: function set(value) {
        this.value = this.doFormat(value);
      }
      /** Value that includes raw user input */
    }, {
      key: "rawInputValue",
      get: function get() {
        return this.extractInput(0, this.value.length, {
          raw: true
        });
      },
      set: function set(value) {
        this.reset();
        this.append(value, {
          raw: true
        }, '');
        this.doCommit();
      }
      /** */
    }, {
      key: "isComplete",
      get: function get() {
        return true;
      }
      /** */
    }, {
      key: "isFilled",
      get: function get() {
        return this.isComplete;
      }
      /** Finds nearest input position in direction */
    }, {
      key: "nearestInputPos",
      value: function nearestInputPos(cursorPos, direction) {
        return cursorPos;
      }
      /** Extracts value in range considering flags */
    }, {
      key: "extractInput",
      value: function extractInput() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        return this.value.slice(fromPos, toPos);
      }
      /** Extracts tail in range */
    }, {
      key: "extractTail",
      value: function extractTail() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);
      }
      /** Appends tail */
      // $FlowFixMe no ideas
    }, {
      key: "appendTail",
      value: function appendTail(tail) {
        if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
        return tail.appendTo(this);
      }
      /** Appends char */
    }, {
      key: "_appendCharRaw",
      value: function _appendCharRaw(ch) {
        if (!ch) return new ChangeDetails();
        this._value += ch;
        return new ChangeDetails({
          inserted: ch,
          rawInserted: ch
        });
      }
      /** Appends char */
    }, {
      key: "_appendChar",
      value: function _appendChar(ch) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var checkTail = arguments.length > 2 ? arguments[2] : undefined;
        var consistentState = this.state;
        var details;
        var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));
        var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);
        ch = _normalizePrepare2[0];
        details = _normalizePrepare2[1];
        details = details.aggregate(this._appendCharRaw(ch, flags));
        if (details.inserted) {
          var consistentTail;
          var appended = this.doValidate(flags) !== false;
          if (appended && checkTail != null) {
            // validation ok, check tail
            var beforeTailState = this.state;
            if (this.overwrite === true) {
              consistentTail = checkTail.state;
              checkTail.unshift(this.value.length);
            }
            var tailDetails = this.appendTail(checkTail);
            appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift

            if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {
              this.state = beforeTailState;
              consistentTail = checkTail.state;
              checkTail.shift();
              tailDetails = this.appendTail(checkTail);
              appended = tailDetails.rawInserted === checkTail.toString();
            } // if ok, rollback state after tail

            if (appended && tailDetails.inserted) this.state = beforeTailState;
          } // revert all if something went wrong

          if (!appended) {
            details = new ChangeDetails();
            this.state = consistentState;
            if (checkTail && consistentTail) checkTail.state = consistentTail;
          }
        }
        return details;
      }
      /** Appends optional placeholder at end */
    }, {
      key: "_appendPlaceholder",
      value: function _appendPlaceholder() {
        return new ChangeDetails();
      }
      /** Appends optional eager placeholder at end */
    }, {
      key: "_appendEager",
      value: function _appendEager() {
        return new ChangeDetails();
      }
      /** Appends symbols considering flags */
      // $FlowFixMe no ideas
    }, {
      key: "append",
      value: function append(str, flags, tail) {
        if (!isString(str)) throw new Error('value should be string');
        var details = new ChangeDetails();
        var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;
        if (flags !== null && flags !== void 0 && flags.tail) flags._beforeTailState = this.state;
        for (var ci = 0; ci < str.length; ++ci) {
          details.aggregate(this._appendChar(str[ci], flags, checkTail));
        } // append tail but aggregate only tailShift

        if (checkTail != null) {
          details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends
          // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)
          // this._resetBeforeTailState();
        }

        if (this.eager && flags !== null && flags !== void 0 && flags.input && str) {
          details.aggregate(this._appendEager());
        }
        return details;
      }
      /** */
    }, {
      key: "remove",
      value: function remove() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);
        return new ChangeDetails();
      }
      /** Calls function and reapplies current value */
    }, {
      key: "withValueRefresh",
      value: function withValueRefresh(fn) {
        if (this._refreshing || !this.isInitialized) return fn();
        this._refreshing = true;
        var rawInput = this.rawInputValue;
        var value = this.value;
        var ret = fn();
        this.rawInputValue = rawInput; // append lost trailing chars at end

        if (this.value && this.value !== value && value.indexOf(this.value) === 0) {
          this.append(value.slice(this.value.length), {}, '');
        }
        delete this._refreshing;
        return ret;
      }
      /** */
    }, {
      key: "runIsolated",
      value: function runIsolated(fn) {
        if (this._isolated || !this.isInitialized) return fn(this);
        this._isolated = true;
        var state = this.state;
        var ret = fn(this);
        this.state = state;
        delete this._isolated;
        return ret;
      }
      /**
        Prepares string before mask processing
        @protected
      */
    }, {
      key: "doPrepare",
      value: function doPrepare(str) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.prepare ? this.prepare(str, this, flags) : str;
      }
      /**
        Validates if value is acceptable
        @protected
      */
    }, {
      key: "doValidate",
      value: function doValidate(flags) {
        return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));
      }
      /**
        Does additional processing in the end of editing
        @protected
      */
    }, {
      key: "doCommit",
      value: function doCommit() {
        if (this.commit) this.commit(this.value, this);
      }
      /** */
    }, {
      key: "doFormat",
      value: function doFormat(value) {
        return this.format ? this.format(value, this) : value;
      }
      /** */
    }, {
      key: "doParse",
      value: function doParse(str) {
        return this.parse ? this.parse(str, this) : str;
      }
      /** */
    }, {
      key: "splice",
      value: function splice(start, deleteCount, inserted, removeDirection) {
        var flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
          input: true
        };
        var tailPos = start + deleteCount;
        var tail = this.extractTail(tailPos);
        var oldRawValue;
        if (this.eager) {
          removeDirection = forceDirection(removeDirection);
          oldRawValue = this.extractInput(0, tailPos, {
            raw: true
          });
        }
        var startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !this.eager ? DIRECTION.NONE : removeDirection);
        var details = new ChangeDetails({
          tailShift: startChangePos - start // adjust tailShift if start was aligned
        }).aggregate(this.remove(startChangePos));
        if (this.eager && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {
          if (removeDirection === DIRECTION.FORCE_LEFT) {
            var valLength;
            while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {
              details.aggregate(new ChangeDetails({
                tailShift: -1
              })).aggregate(this.remove(valLength - 1));
            }
          } else if (removeDirection === DIRECTION.FORCE_RIGHT) {
            tail.unshift();
          }
        }
        return details.aggregate(this.append(inserted, flags, tail));
      }
    }, {
      key: "maskEquals",
      value: function maskEquals(mask) {
        return this.mask === mask;
      }
    }, {
      key: "typedValueEquals",
      value: function typedValueEquals(value) {
        var tval = this.typedValue;
        return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.doFormat(value) === this.doFormat(this.typedValue);
      }
    }]);
    return Masked;
  }();
  Masked.DEFAULTS = {
    format: function format(v) {
      return v;
    },
    parse: function parse(v) {
      return v;
    }
  };
  Masked.EMPTY_VALUES = [undefined, null, ''];
  IMask.Masked = Masked;

  /** Get Masked class by mask type */

  function maskedClass(mask) {
    if (mask == null) {
      throw new Error('mask property should be defined');
    } // $FlowFixMe

    if (mask instanceof RegExp) return IMask.MaskedRegExp; // $FlowFixMe

    if (isString(mask)) return IMask.MaskedPattern; // $FlowFixMe

    if (mask instanceof Date || mask === Date) return IMask.MaskedDate; // $FlowFixMe

    if (mask instanceof Number || typeof mask === 'number' || mask === Number) return IMask.MaskedNumber; // $FlowFixMe

    if (Array.isArray(mask) || mask === Array) return IMask.MaskedDynamic; // $FlowFixMe

    if (IMask.Masked && mask.prototype instanceof IMask.Masked) return mask; // $FlowFixMe

    if (mask instanceof IMask.Masked) return mask.constructor; // $FlowFixMe

    if (mask instanceof Function) return IMask.MaskedFunction;
    console.warn('Mask not found for mask', mask); // eslint-disable-line no-console
    // $FlowFixMe

    return IMask.Masked;
  }
  /** Creates new {@link Masked} depending on mask type */

  function createMask(opts) {
    // $FlowFixMe
    if (IMask.Masked && opts instanceof IMask.Masked) return opts;
    opts = Object.assign({}, opts);
    var mask = opts.mask; // $FlowFixMe

    if (IMask.Masked && mask instanceof IMask.Masked) return mask;
    var MaskedClass = maskedClass(mask);
    if (!MaskedClass) throw new Error('Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.');
    return new MaskedClass(opts);
  }
  IMask.createMask = createMask;
  var _excluded$4 = ["mask"];
  var DEFAULT_INPUT_DEFINITIONS = {
    '0': /\d/,
    'a': /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // http://stackoverflow.com/a/22075070
    '*': /./
  };
  /** */

  var PatternInputDefinition = /*#__PURE__*/function () {
    /** */

    /** */

    /** */

    /** */

    /** */

    /** */

    /** */
    function PatternInputDefinition(opts) {
      _classCallCheck(this, PatternInputDefinition);
      var mask = opts.mask,
        blockOpts = _objectWithoutProperties(opts, _excluded$4);
      this.masked = createMask({
        mask: mask
      });
      Object.assign(this, blockOpts);
    }
    _createClass(PatternInputDefinition, [{
      key: "reset",
      value: function reset() {
        this.isFilled = false;
        this.masked.reset();
      }
    }, {
      key: "remove",
      value: function remove() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        if (fromPos === 0 && toPos >= 1) {
          this.isFilled = false;
          return this.masked.remove(fromPos, toPos);
        }
        return new ChangeDetails();
      }
    }, {
      key: "value",
      get: function get() {
        return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : '');
      }
    }, {
      key: "unmaskedValue",
      get: function get() {
        return this.masked.unmaskedValue;
      }
    }, {
      key: "isComplete",
      get: function get() {
        return Boolean(this.masked.value) || this.isOptional;
      }
    }, {
      key: "_appendChar",
      value: function _appendChar(ch) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (this.isFilled) return new ChangeDetails();
        var state = this.masked.state; // simulate input

        var details = this.masked._appendChar(ch, flags);
        if (details.inserted && this.doValidate(flags) === false) {
          details.inserted = details.rawInserted = '';
          this.masked.state = state;
        }
        if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {
          details.inserted = this.placeholderChar;
        }
        details.skip = !details.inserted && !this.isOptional;
        this.isFilled = Boolean(details.inserted);
        return details;
      }
    }, {
      key: "append",
      value: function append() {
        var _this$masked;

        // TODO probably should be done via _appendChar
        return (_this$masked = this.masked).append.apply(_this$masked, arguments);
      }
    }, {
      key: "_appendPlaceholder",
      value: function _appendPlaceholder() {
        var details = new ChangeDetails();
        if (this.isFilled || this.isOptional) return details;
        this.isFilled = true;
        details.inserted = this.placeholderChar;
        return details;
      }
    }, {
      key: "_appendEager",
      value: function _appendEager() {
        return new ChangeDetails();
      }
    }, {
      key: "extractTail",
      value: function extractTail() {
        var _this$masked2;
        return (_this$masked2 = this.masked).extractTail.apply(_this$masked2, arguments);
      }
    }, {
      key: "appendTail",
      value: function appendTail() {
        var _this$masked3;
        return (_this$masked3 = this.masked).appendTail.apply(_this$masked3, arguments);
      }
    }, {
      key: "extractInput",
      value: function extractInput() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        var flags = arguments.length > 2 ? arguments[2] : undefined;
        return this.masked.extractInput(fromPos, toPos, flags);
      }
    }, {
      key: "nearestInputPos",
      value: function nearestInputPos(cursorPos) {
        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
        var minPos = 0;
        var maxPos = this.value.length;
        var boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);
        switch (direction) {
          case DIRECTION.LEFT:
          case DIRECTION.FORCE_LEFT:
            return this.isComplete ? boundPos : minPos;
          case DIRECTION.RIGHT:
          case DIRECTION.FORCE_RIGHT:
            return this.isComplete ? boundPos : maxPos;
          case DIRECTION.NONE:
          default:
            return boundPos;
        }
      }
    }, {
      key: "doValidate",
      value: function doValidate() {
        var _this$masked4, _this$parent;
        return (_this$masked4 = this.masked).doValidate.apply(_this$masked4, arguments) && (!this.parent || (_this$parent = this.parent).doValidate.apply(_this$parent, arguments));
      }
    }, {
      key: "doCommit",
      value: function doCommit() {
        this.masked.doCommit();
      }
    }, {
      key: "state",
      get: function get() {
        return {
          masked: this.masked.state,
          isFilled: this.isFilled
        };
      },
      set: function set(state) {
        this.masked.state = state.masked;
        this.isFilled = state.isFilled;
      }
    }]);
    return PatternInputDefinition;
  }();
  var PatternFixedDefinition = /*#__PURE__*/function () {
    /** */

    /** */

    /** */

    /** */

    /** */

    /** */
    function PatternFixedDefinition(opts) {
      _classCallCheck(this, PatternFixedDefinition);
      Object.assign(this, opts);
      this._value = '';
      this.isFixed = true;
    }
    _createClass(PatternFixedDefinition, [{
      key: "value",
      get: function get() {
        return this._value;
      }
    }, {
      key: "unmaskedValue",
      get: function get() {
        return this.isUnmasking ? this.value : '';
      }
    }, {
      key: "reset",
      value: function reset() {
        this._isRawInput = false;
        this._value = '';
      }
    }, {
      key: "remove",
      value: function remove() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;
        this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);
        if (!this._value) this._isRawInput = false;
        return new ChangeDetails();
      }
    }, {
      key: "nearestInputPos",
      value: function nearestInputPos(cursorPos) {
        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
        var minPos = 0;
        var maxPos = this._value.length;
        switch (direction) {
          case DIRECTION.LEFT:
          case DIRECTION.FORCE_LEFT:
            return minPos;
          case DIRECTION.NONE:
          case DIRECTION.RIGHT:
          case DIRECTION.FORCE_RIGHT:
          default:
            return maxPos;
        }
      }
    }, {
      key: "extractInput",
      value: function extractInput() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;
        var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || '';
      }
    }, {
      key: "isComplete",
      get: function get() {
        return true;
      }
    }, {
      key: "isFilled",
      get: function get() {
        return Boolean(this._value);
      }
    }, {
      key: "_appendChar",
      value: function _appendChar(ch) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var details = new ChangeDetails();
        if (this._value) return details;
        var appended = this.char === ch;
        var isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && (!flags.raw || !this.eager) && !flags.tail;
        if (isResolved) details.rawInserted = this.char;
        this._value = details.inserted = this.char;
        this._isRawInput = isResolved && (flags.raw || flags.input);
        return details;
      }
    }, {
      key: "_appendEager",
      value: function _appendEager() {
        return this._appendChar(this.char, {
          tail: true
        });
      }
    }, {
      key: "_appendPlaceholder",
      value: function _appendPlaceholder() {
        var details = new ChangeDetails();
        if (this._value) return details;
        this._value = details.inserted = this.char;
        return details;
      }
    }, {
      key: "extractTail",
      value: function extractTail() {
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        return new ContinuousTailDetails('');
      } // $FlowFixMe no ideas
    }, {
      key: "appendTail",
      value: function appendTail(tail) {
        if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
        return tail.appendTo(this);
      }
    }, {
      key: "append",
      value: function append(str, flags, tail) {
        var details = this._appendChar(str[0], flags);
        if (tail != null) {
          details.tailShift += this.appendTail(tail).tailShift;
        }
        return details;
      }
    }, {
      key: "doCommit",
      value: function doCommit() {}
    }, {
      key: "state",
      get: function get() {
        return {
          _value: this._value,
          _isRawInput: this._isRawInput
        };
      },
      set: function set(state) {
        Object.assign(this, state);
      }
    }]);
    return PatternFixedDefinition;
  }();
  var _excluded$3 = ["chunks"];
  var ChunksTailDetails = /*#__PURE__*/function () {
    /** */
    function ChunksTailDetails() {
      var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      _classCallCheck(this, ChunksTailDetails);
      this.chunks = chunks;
      this.from = from;
    }
    _createClass(ChunksTailDetails, [{
      key: "toString",
      value: function toString() {
        return this.chunks.map(String).join('');
      } // $FlowFixMe no ideas
    }, {
      key: "extend",
      value: function extend(tailChunk) {
        if (!String(tailChunk)) return;
        if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));
        var lastChunk = this.chunks[this.chunks.length - 1];
        var extendLast = lastChunk && (
        // if stops are same or tail has no stop
        lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&
        // if tail chunk goes just after last chunk
        tailChunk.from === lastChunk.from + lastChunk.toString().length;
        if (tailChunk instanceof ContinuousTailDetails) {
          // check the ability to extend previous chunk
          if (extendLast) {
            // extend previous chunk
            lastChunk.extend(tailChunk.toString());
          } else {
            // append new chunk
            this.chunks.push(tailChunk);
          }
        } else if (tailChunk instanceof ChunksTailDetails) {
          if (tailChunk.stop == null) {
            // unwrap floating chunks to parent, keeping `from` pos
            var firstTailChunk;
            while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {
              firstTailChunk = tailChunk.chunks.shift();
              firstTailChunk.from += tailChunk.from;
              this.extend(firstTailChunk);
            }
          } // if tail chunk still has value

          if (tailChunk.toString()) {
            // if chunks contains stops, then popup stop to container
            tailChunk.stop = tailChunk.blockIndex;
            this.chunks.push(tailChunk);
          }
        }
      }
    }, {
      key: "appendTo",
      value: function appendTo(masked) {
        // $FlowFixMe
        if (!(masked instanceof IMask.MaskedPattern)) {
          var tail = new ContinuousTailDetails(this.toString());
          return tail.appendTo(masked);
        }
        var details = new ChangeDetails();
        for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {
          var chunk = this.chunks[ci];
          var lastBlockIter = masked._mapPosToBlock(masked.value.length);
          var stop = chunk.stop;
          var chunkBlock = void 0;
          if (stop != null && (
          // if block not found or stop is behind lastBlock
          !lastBlockIter || lastBlockIter.index <= stop)) {
            if (chunk instanceof ChunksTailDetails ||
            // for continuous block also check if stop is exist
            masked._stops.indexOf(stop) >= 0) {
              details.aggregate(masked._appendPlaceholder(stop));
            }
            chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];
          }
          if (chunkBlock) {
            var tailDetails = chunkBlock.appendTail(chunk);
            tailDetails.skip = false; // always ignore skip, it will be set on last

            details.aggregate(tailDetails);
            masked._value += tailDetails.inserted; // get not inserted chars

            var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);
            if (remainChars) details.aggregate(masked.append(remainChars, {
              tail: true
            }));
          } else {
            details.aggregate(masked.append(chunk.toString(), {
              tail: true
            }));
          }
        }
        return details;
      }
    }, {
      key: "state",
      get: function get() {
        return {
          chunks: this.chunks.map(function (c) {
            return c.state;
          }),
          from: this.from,
          stop: this.stop,
          blockIndex: this.blockIndex
        };
      },
      set: function set(state) {
        var chunks = state.chunks,
          props = _objectWithoutProperties(state, _excluded$3);
        Object.assign(this, props);
        this.chunks = chunks.map(function (cstate) {
          var chunk = "chunks" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above

          chunk.state = cstate;
          return chunk;
        });
      }
    }, {
      key: "unshift",
      value: function unshift(beforePos) {
        if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';
        var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;
        var ci = 0;
        while (ci < this.chunks.length) {
          var chunk = this.chunks[ci];
          var shiftChar = chunk.unshift(chunkShiftPos);
          if (chunk.toString()) {
            // chunk still contains value
            // but not shifted - means no more available chars to shift
            if (!shiftChar) break;
            ++ci;
          } else {
            // clean if chunk has no value
            this.chunks.splice(ci, 1);
          }
          if (shiftChar) return shiftChar;
        }
        return '';
      }
    }, {
      key: "shift",
      value: function shift() {
        if (!this.chunks.length) return '';
        var ci = this.chunks.length - 1;
        while (0 <= ci) {
          var chunk = this.chunks[ci];
          var shiftChar = chunk.shift();
          if (chunk.toString()) {
            // chunk still contains value
            // but not shifted - means no more available chars to shift
            if (!shiftChar) break;
            --ci;
          } else {
            // clean if chunk has no value
            this.chunks.splice(ci, 1);
          }
          if (shiftChar) return shiftChar;
        }
        return '';
      }
    }]);
    return ChunksTailDetails;
  }();
  var PatternCursor = /*#__PURE__*/function () {
    function PatternCursor(masked, pos) {
      _classCallCheck(this, PatternCursor);
      this.masked = masked;
      this._log = [];
      var _ref = masked._mapPosToBlock(pos) || (pos < 0 ?
        // first
        {
          index: 0,
          offset: 0
        } :
        // last
        {
          index: this.masked._blocks.length,
          offset: 0
        }),
        offset = _ref.offset,
        index = _ref.index;
      this.offset = offset;
      this.index = index;
      this.ok = false;
    }
    _createClass(PatternCursor, [{
      key: "block",
      get: function get() {
        return this.masked._blocks[this.index];
      }
    }, {
      key: "pos",
      get: function get() {
        return this.masked._blockStartPos(this.index) + this.offset;
      }
    }, {
      key: "state",
      get: function get() {
        return {
          index: this.index,
          offset: this.offset,
          ok: this.ok
        };
      },
      set: function set(s) {
        Object.assign(this, s);
      }
    }, {
      key: "pushState",
      value: function pushState() {
        this._log.push(this.state);
      }
    }, {
      key: "popState",
      value: function popState() {
        var s = this._log.pop();
        this.state = s;
        return s;
      }
    }, {
      key: "bindBlock",
      value: function bindBlock() {
        if (this.block) return;
        if (this.index < 0) {
          this.index = 0;
          this.offset = 0;
        }
        if (this.index >= this.masked._blocks.length) {
          this.index = this.masked._blocks.length - 1;
          this.offset = this.block.value.length;
        }
      }
    }, {
      key: "_pushLeft",
      value: function _pushLeft(fn) {
        this.pushState();
        for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) === null || _this$block === void 0 ? void 0 : _this$block.value.length) || 0) {
          var _this$block;
          if (fn()) return this.ok = true;
        }
        return this.ok = false;
      }
    }, {
      key: "_pushRight",
      value: function _pushRight(fn) {
        this.pushState();
        for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {
          if (fn()) return this.ok = true;
        }
        return this.ok = false;
      }
    }, {
      key: "pushLeftBeforeFilled",
      value: function pushLeftBeforeFilled() {
        var _this = this;
        return this._pushLeft(function () {
          if (_this.block.isFixed || !_this.block.value) return;
          _this.offset = _this.block.nearestInputPos(_this.offset, DIRECTION.FORCE_LEFT);
          if (_this.offset !== 0) return true;
        });
      }
    }, {
      key: "pushLeftBeforeInput",
      value: function pushLeftBeforeInput() {
        var _this2 = this;

        // cases:
        // filled input: 00|
        // optional empty input: 00[]|
        // nested block: XX<[]>|
        return this._pushLeft(function () {
          if (_this2.block.isFixed) return;
          _this2.offset = _this2.block.nearestInputPos(_this2.offset, DIRECTION.LEFT);
          return true;
        });
      }
    }, {
      key: "pushLeftBeforeRequired",
      value: function pushLeftBeforeRequired() {
        var _this3 = this;
        return this._pushLeft(function () {
          if (_this3.block.isFixed || _this3.block.isOptional && !_this3.block.value) return;
          _this3.offset = _this3.block.nearestInputPos(_this3.offset, DIRECTION.LEFT);
          return true;
        });
      }
    }, {
      key: "pushRightBeforeFilled",
      value: function pushRightBeforeFilled() {
        var _this4 = this;
        return this._pushRight(function () {
          if (_this4.block.isFixed || !_this4.block.value) return;
          _this4.offset = _this4.block.nearestInputPos(_this4.offset, DIRECTION.FORCE_RIGHT);
          if (_this4.offset !== _this4.block.value.length) return true;
        });
      }
    }, {
      key: "pushRightBeforeInput",
      value: function pushRightBeforeInput() {
        var _this5 = this;
        return this._pushRight(function () {
          if (_this5.block.isFixed) return; // const o = this.offset;

          _this5.offset = _this5.block.nearestInputPos(_this5.offset, DIRECTION.NONE); // HACK cases like (STILL DOES NOT WORK FOR NESTED)
          // aa|X
          // aa<X|[]>X_    - this will not work
          // if (o && o === this.offset && this.block instanceof PatternInputDefinition) continue;

          return true;
        });
      }
    }, {
      key: "pushRightBeforeRequired",
      value: function pushRightBeforeRequired() {
        var _this6 = this;
        return this._pushRight(function () {
          if (_this6.block.isFixed || _this6.block.isOptional && !_this6.block.value) return; // TODO check |[*]XX_

          _this6.offset = _this6.block.nearestInputPos(_this6.offset, DIRECTION.NONE);
          return true;
        });
      }
    }]);
    return PatternCursor;
  }();

  /** Masking by RegExp */

  var MaskedRegExp = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedRegExp, _Masked);
    var _super = _createSuper(MaskedRegExp);
    function MaskedRegExp() {
      _classCallCheck(this, MaskedRegExp);
      return _super.apply(this, arguments);
    }
    _createClass(MaskedRegExp, [{
      key: "_update",
      value:
      /**
        @override
        @param {Object} opts
      */
      function _update(opts) {
        if (opts.mask) opts.validate = function (value) {
          return value.search(opts.mask) >= 0;
        };
        _get(_getPrototypeOf(MaskedRegExp.prototype), "_update", this).call(this, opts);
      }
    }]);
    return MaskedRegExp;
  }(Masked);
  IMask.MaskedRegExp = MaskedRegExp;
  var _excluded$2 = ["_blocks"];

  /**
    Pattern mask
    @param {Object} opts
    @param {Object} opts.blocks
    @param {Object} opts.definitions
    @param {string} opts.placeholderChar
    @param {boolean} opts.lazy
  */
  var MaskedPattern = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedPattern, _Masked);
    var _super = _createSuper(MaskedPattern);

    /** */

    /** */

    /** Single char for empty input */

    /** Show placeholder only when needed */
    function MaskedPattern() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, MaskedPattern);

      // TODO type $Shape<MaskedPatternOptions>={} does not work
      opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);
      return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));
    }
    /**
      @override
      @param {Object} opts
    */

    _createClass(MaskedPattern, [{
      key: "_update",
      value: function _update() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        opts.definitions = Object.assign({}, this.definitions, opts.definitions);
        _get(_getPrototypeOf(MaskedPattern.prototype), "_update", this).call(this, opts);
        this._rebuildMask();
      }
      /** */
    }, {
      key: "_rebuildMask",
      value: function _rebuildMask() {
        var _this = this;
        var defs = this.definitions;
        this._blocks = [];
        this._stops = [];
        this._maskedBlocks = {};
        var pattern = this.mask;
        if (!pattern || !defs) return;
        var unmaskingBlock = false;
        var optionalBlock = false;
        for (var i = 0; i < pattern.length; ++i) {
          if (this.blocks) {
            var _ret = function () {
              var p = pattern.slice(i);
              var bNames = Object.keys(_this.blocks).filter(function (bName) {
                return p.indexOf(bName) === 0;
              }); // order by key length

              bNames.sort(function (a, b) {
                return b.length - a.length;
              }); // use block name with max length

              var bName = bNames[0];
              if (bName) {
                // $FlowFixMe no ideas
                var maskedBlock = createMask(Object.assign({
                  parent: _this,
                  lazy: _this.lazy,
                  eager: _this.eager,
                  placeholderChar: _this.placeholderChar,
                  overwrite: _this.overwrite
                }, _this.blocks[bName]));
                if (maskedBlock) {
                  _this._blocks.push(maskedBlock); // store block index

                  if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];
                  _this._maskedBlocks[bName].push(_this._blocks.length - 1);
                }
                i += bName.length - 1;
                return "continue";
              }
            }();
            if (_ret === "continue") continue;
          }
          var char = pattern[i];
          var isInput = (char in defs);
          if (char === MaskedPattern.STOP_CHAR) {
            this._stops.push(this._blocks.length);
            continue;
          }
          if (char === '{' || char === '}') {
            unmaskingBlock = !unmaskingBlock;
            continue;
          }
          if (char === '[' || char === ']') {
            optionalBlock = !optionalBlock;
            continue;
          }
          if (char === MaskedPattern.ESCAPE_CHAR) {
            ++i;
            char = pattern[i];
            if (!char) break;
            isInput = false;
          }
          var def = isInput ? new PatternInputDefinition({
            parent: this,
            lazy: this.lazy,
            eager: this.eager,
            placeholderChar: this.placeholderChar,
            mask: defs[char],
            isOptional: optionalBlock
          }) : new PatternFixedDefinition({
            char: char,
            eager: this.eager,
            isUnmasking: unmaskingBlock
          });
          this._blocks.push(def);
        }
      }
      /**
        @override
      */
    }, {
      key: "state",
      get: function get() {
        return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), "state", this), {
          _blocks: this._blocks.map(function (b) {
            return b.state;
          })
        });
      },
      set: function set(state) {
        var _blocks = state._blocks,
          maskedState = _objectWithoutProperties(state, _excluded$2);
        this._blocks.forEach(function (b, bi) {
          return b.state = _blocks[bi];
        });
        _set(_getPrototypeOf(MaskedPattern.prototype), "state", maskedState, this, true);
      }
      /**
        @override
      */
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(MaskedPattern.prototype), "reset", this).call(this);
        this._blocks.forEach(function (b) {
          return b.reset();
        });
      }
      /**
        @override
      */
    }, {
      key: "isComplete",
      get: function get() {
        return this._blocks.every(function (b) {
          return b.isComplete;
        });
      }
      /**
        @override
      */
    }, {
      key: "isFilled",
      get: function get() {
        return this._blocks.every(function (b) {
          return b.isFilled;
        });
      }
    }, {
      key: "isFixed",
      get: function get() {
        return this._blocks.every(function (b) {
          return b.isFixed;
        });
      }
    }, {
      key: "isOptional",
      get: function get() {
        return this._blocks.every(function (b) {
          return b.isOptional;
        });
      }
      /**
        @override
      */
    }, {
      key: "doCommit",
      value: function doCommit() {
        this._blocks.forEach(function (b) {
          return b.doCommit();
        });
        _get(_getPrototypeOf(MaskedPattern.prototype), "doCommit", this).call(this);
      }
      /**
        @override
      */
    }, {
      key: "unmaskedValue",
      get: function get() {
        return this._blocks.reduce(function (str, b) {
          return str += b.unmaskedValue;
        }, '');
      },
      set: function set(unmaskedValue) {
        _set(_getPrototypeOf(MaskedPattern.prototype), "unmaskedValue", unmaskedValue, this, true);
      }
      /**
        @override
      */
    }, {
      key: "value",
      get: function get() {
        // TODO return _value when not in change?
        return this._blocks.reduce(function (str, b) {
          return str += b.value;
        }, '');
      },
      set: function set(value) {
        _set(_getPrototypeOf(MaskedPattern.prototype), "value", value, this, true);
      }
      /**
        @override
      */
    }, {
      key: "appendTail",
      value: function appendTail(tail) {
        return _get(_getPrototypeOf(MaskedPattern.prototype), "appendTail", this).call(this, tail).aggregate(this._appendPlaceholder());
      }
      /**
        @override
      */
    }, {
      key: "_appendEager",
      value: function _appendEager() {
        var _this$_mapPosToBlock;
        var details = new ChangeDetails();
        var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;
        if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks

        if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;
        for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {
          var d = this._blocks[bi]._appendEager();
          if (!d.inserted) break;
          details.aggregate(d);
        }
        return details;
      }
      /**
        @override
      */
    }, {
      key: "_appendCharRaw",
      value: function _appendCharRaw(ch) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var blockIter = this._mapPosToBlock(this.value.length);
        var details = new ChangeDetails();
        if (!blockIter) return details;
        for (var bi = blockIter.index;; ++bi) {
          var _flags$_beforeTailSta, _flags$_beforeTailSta2;
          var _block = this._blocks[bi];
          if (!_block) break;
          var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {
            _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]
          }));
          var skip = blockDetails.skip;
          details.aggregate(blockDetails);
          if (skip || blockDetails.rawInserted) break; // go next char
        }

        return details;
      }
      /**
        @override
      */
    }, {
      key: "extractTail",
      value: function extractTail() {
        var _this2 = this;
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        var chunkTail = new ChunksTailDetails();
        if (fromPos === toPos) return chunkTail;
        this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {
          var blockChunk = b.extractTail(bFromPos, bToPos);
          blockChunk.stop = _this2._findStopBefore(bi);
          blockChunk.from = _this2._blockStartPos(bi);
          if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;
          chunkTail.extend(blockChunk);
        });
        return chunkTail;
      }
      /**
        @override
      */
    }, {
      key: "extractInput",
      value: function extractInput() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (fromPos === toPos) return '';
        var input = '';
        this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {
          input += b.extractInput(fromPos, toPos, flags);
        });
        return input;
      }
    }, {
      key: "_findStopBefore",
      value: function _findStopBefore(blockIndex) {
        var stopBefore;
        for (var si = 0; si < this._stops.length; ++si) {
          var stop = this._stops[si];
          if (stop <= blockIndex) stopBefore = stop;else break;
        }
        return stopBefore;
      }
      /** Appends placeholder depending on laziness */
    }, {
      key: "_appendPlaceholder",
      value: function _appendPlaceholder(toBlockIndex) {
        var _this3 = this;
        var details = new ChangeDetails();
        if (this.lazy && toBlockIndex == null) return details;
        var startBlockIter = this._mapPosToBlock(this.value.length);
        if (!startBlockIter) return details;
        var startBlockIndex = startBlockIter.index;
        var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;
        this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {
          if (!b.lazy || toBlockIndex != null) {
            // $FlowFixMe `_blocks` may not be present
            var args = b._blocks != null ? [b._blocks.length] : [];
            var bDetails = b._appendPlaceholder.apply(b, args);
            _this3._value += bDetails.inserted;
            details.aggregate(bDetails);
          }
        });
        return details;
      }
      /** Finds block in pos */
    }, {
      key: "_mapPosToBlock",
      value: function _mapPosToBlock(pos) {
        var accVal = '';
        for (var bi = 0; bi < this._blocks.length; ++bi) {
          var _block2 = this._blocks[bi];
          var blockStartPos = accVal.length;
          accVal += _block2.value;
          if (pos <= accVal.length) {
            return {
              index: bi,
              offset: pos - blockStartPos
            };
          }
        }
      }
      /** */
    }, {
      key: "_blockStartPos",
      value: function _blockStartPos(blockIndex) {
        return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {
          return pos += b.value.length;
        }, 0);
      }
      /** */
    }, {
      key: "_forEachBlocksInRange",
      value: function _forEachBlocksInRange(fromPos) {
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        var fn = arguments.length > 2 ? arguments[2] : undefined;
        var fromBlockIter = this._mapPosToBlock(fromPos);
        if (fromBlockIter) {
          var toBlockIter = this._mapPosToBlock(toPos); // process first block

          var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;
          var fromBlockStartPos = fromBlockIter.offset;
          var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;
          fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);
          if (toBlockIter && !isSameBlock) {
            // process intermediate blocks
            for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {
              fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);
            } // process last block

            fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);
          }
        }
      }
      /**
        @override
      */
    }, {
      key: "remove",
      value: function remove() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), "remove", this).call(this, fromPos, toPos);
        this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {
          removeDetails.aggregate(b.remove(bFromPos, bToPos));
        });
        return removeDetails;
      }
      /**
        @override
      */
    }, {
      key: "nearestInputPos",
      value: function nearestInputPos(cursorPos) {
        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
        if (!this._blocks.length) return 0;
        var cursor = new PatternCursor(this, cursorPos);
        if (direction === DIRECTION.NONE) {
          // -------------------------------------------------
          // NONE should only go out from fixed to the right!
          // -------------------------------------------------
          if (cursor.pushRightBeforeInput()) return cursor.pos;
          cursor.popState();
          if (cursor.pushLeftBeforeInput()) return cursor.pos;
          return this.value.length;
        } // FORCE is only about a|* otherwise is 0

        if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {
          // try to break fast when *|a
          if (direction === DIRECTION.LEFT) {
            cursor.pushRightBeforeFilled();
            if (cursor.ok && cursor.pos === cursorPos) return cursorPos;
            cursor.popState();
          } // forward flow

          cursor.pushLeftBeforeInput();
          cursor.pushLeftBeforeRequired();
          cursor.pushLeftBeforeFilled(); // backward flow

          if (direction === DIRECTION.LEFT) {
            cursor.pushRightBeforeInput();
            cursor.pushRightBeforeRequired();
            if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;
            cursor.popState();
            if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;
            cursor.popState();
          }
          if (cursor.ok) return cursor.pos;
          if (direction === DIRECTION.FORCE_LEFT) return 0;
          cursor.popState();
          if (cursor.ok) return cursor.pos;
          cursor.popState();
          if (cursor.ok) return cursor.pos; // cursor.popState();
          // if (
          //   cursor.pushRightBeforeInput() &&
          //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position
          //   (!this.lazy || this.extractInput())
          // ) return cursor.pos;

          return 0;
        }
        if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {
          // forward flow
          cursor.pushRightBeforeInput();
          cursor.pushRightBeforeRequired();
          if (cursor.pushRightBeforeFilled()) return cursor.pos;
          if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow

          cursor.popState();
          if (cursor.ok) return cursor.pos;
          cursor.popState();
          if (cursor.ok) return cursor.pos;
          return this.nearestInputPos(cursorPos, DIRECTION.LEFT);
        }
        return cursorPos;
      }
      /** Get block by name */
    }, {
      key: "maskedBlock",
      value: function maskedBlock(name) {
        return this.maskedBlocks(name)[0];
      }
      /** Get all blocks by name */
    }, {
      key: "maskedBlocks",
      value: function maskedBlocks(name) {
        var _this4 = this;
        var indices = this._maskedBlocks[name];
        if (!indices) return [];
        return indices.map(function (gi) {
          return _this4._blocks[gi];
        });
      }
    }]);
    return MaskedPattern;
  }(Masked);
  MaskedPattern.DEFAULTS = {
    lazy: true,
    placeholderChar: '_'
  };
  MaskedPattern.STOP_CHAR = '`';
  MaskedPattern.ESCAPE_CHAR = '\\';
  MaskedPattern.InputDefinition = PatternInputDefinition;
  MaskedPattern.FixedDefinition = PatternFixedDefinition;
  IMask.MaskedPattern = MaskedPattern;

  /** Pattern which accepts ranges */

  var MaskedRange = /*#__PURE__*/function (_MaskedPattern) {
    _inherits(MaskedRange, _MaskedPattern);
    var _super = _createSuper(MaskedRange);
    function MaskedRange() {
      _classCallCheck(this, MaskedRange);
      return _super.apply(this, arguments);
    }
    _createClass(MaskedRange, [{
      key: "_matchFrom",
      get:
      /**
        Optionally sets max length of pattern.
        Used when pattern length is longer then `to` param length. Pads zeros at start in this case.
      */

      /** Min bound */

      /** Max bound */

      /** */
      function get() {
        return this.maxLength - String(this.from).length;
      }
      /**
        @override
      */
    }, {
      key: "_update",
      value: function _update(opts) {
        // TODO type
        opts = Object.assign({
          to: this.to || 0,
          from: this.from || 0,
          maxLength: this.maxLength || 0
        }, opts);
        var maxLength = String(opts.to).length;
        if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);
        opts.maxLength = maxLength;
        var fromStr = String(opts.from).padStart(maxLength, '0');
        var toStr = String(opts.to).padStart(maxLength, '0');
        var sameCharsCount = 0;
        while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) {
          ++sameCharsCount;
        }
        opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\0') + '0'.repeat(maxLength - sameCharsCount);
        _get(_getPrototypeOf(MaskedRange.prototype), "_update", this).call(this, opts);
      }
      /**
        @override
      */
    }, {
      key: "isComplete",
      get: function get() {
        return _get(_getPrototypeOf(MaskedRange.prototype), "isComplete", this) && Boolean(this.value);
      }
    }, {
      key: "boundaries",
      value: function boundaries(str) {
        var minstr = '';
        var maxstr = '';
        var _ref = str.match(/^(\D*)(\d*)(\D*)/) || [],
          _ref2 = _slicedToArray(_ref, 3),
          placeholder = _ref2[1],
          num = _ref2[2];
        if (num) {
          minstr = '0'.repeat(placeholder.length) + num;
          maxstr = '9'.repeat(placeholder.length) + num;
        }
        minstr = minstr.padEnd(this.maxLength, '0');
        maxstr = maxstr.padEnd(this.maxLength, '9');
        return [minstr, maxstr];
      } // TODO str is a single char everytime

      /**
        @override
      */
    }, {
      key: "doPrepare",
      value: function doPrepare(ch) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var details;
        var _normalizePrepare = normalizePrepare(_get(_getPrototypeOf(MaskedRange.prototype), "doPrepare", this).call(this, ch.replace(/\D/g, ''), flags));
        var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);
        ch = _normalizePrepare2[0];
        details = _normalizePrepare2[1];
        if (!this.autofix || !ch) return ch;
        var fromStr = String(this.from).padStart(this.maxLength, '0');
        var toStr = String(this.to).padStart(this.maxLength, '0');
        var nextVal = this.value + ch;
        if (nextVal.length > this.maxLength) return '';
        var _this$boundaries = this.boundaries(nextVal),
          _this$boundaries2 = _slicedToArray(_this$boundaries, 2),
          minstr = _this$boundaries2[0],
          maxstr = _this$boundaries2[1];
        if (Number(maxstr) < this.from) return fromStr[nextVal.length - 1];
        if (Number(minstr) > this.to) {
          if (this.autofix === 'pad' && nextVal.length < this.maxLength) {
            return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];
          }
          return toStr[nextVal.length - 1];
        }
        return ch;
      }
      /**
        @override
      */
    }, {
      key: "doValidate",
      value: function doValidate() {
        var _get2;
        var str = this.value;
        var firstNonZero = str.search(/[^0]/);
        if (firstNonZero === -1 && str.length <= this._matchFrom) return true;
        var _this$boundaries3 = this.boundaries(str),
          _this$boundaries4 = _slicedToArray(_this$boundaries3, 2),
          minstr = _this$boundaries4[0],
          maxstr = _this$boundaries4[1];
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.from <= Number(maxstr) && Number(minstr) <= this.to && (_get2 = _get(_getPrototypeOf(MaskedRange.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
      }
    }]);
    return MaskedRange;
  }(MaskedPattern);
  IMask.MaskedRange = MaskedRange;

  /** Date mask */

  var MaskedDate = /*#__PURE__*/function (_MaskedPattern) {
    _inherits(MaskedDate, _MaskedPattern);
    var _super = _createSuper(MaskedDate);

    /** Pattern mask for date according to {@link MaskedDate#format} */

    /** Start date */

    /** End date */

    /** */

    /**
      @param {Object} opts
    */
    function MaskedDate(opts) {
      _classCallCheck(this, MaskedDate);
      return _super.call(this, Object.assign({}, MaskedDate.DEFAULTS, opts));
    }
    /**
      @override
    */

    _createClass(MaskedDate, [{
      key: "_update",
      value: function _update(opts) {
        if (opts.mask === Date) delete opts.mask;
        if (opts.pattern) opts.mask = opts.pattern;
        var blocks = opts.blocks;
        opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block

        if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();
        if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();
        if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {
          opts.blocks.m.from = opts.min.getMonth() + 1;
          opts.blocks.m.to = opts.max.getMonth() + 1;
          if (opts.blocks.m.from === opts.blocks.m.to) {
            opts.blocks.d.from = opts.min.getDate();
            opts.blocks.d.to = opts.max.getDate();
          }
        }
        Object.assign(opts.blocks, this.blocks, blocks); // add autofix

        Object.keys(opts.blocks).forEach(function (bk) {
          var b = opts.blocks[bk];
          if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;
        });
        _get(_getPrototypeOf(MaskedDate.prototype), "_update", this).call(this, opts);
      }
      /**
        @override
      */
    }, {
      key: "doValidate",
      value: function doValidate() {
        var _get2;
        var date = this.date;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_get2 = _get(_getPrototypeOf(MaskedDate.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));
      }
      /** Checks if date is exists */
    }, {
      key: "isDateExist",
      value: function isDateExist(str) {
        return this.format(this.parse(str, this), this).indexOf(str) >= 0;
      }
      /** Parsed Date */
    }, {
      key: "date",
      get: function get() {
        return this.typedValue;
      },
      set: function set(date) {
        this.typedValue = date;
      }
      /**
        @override
      */
    }, {
      key: "typedValue",
      get: function get() {
        return this.isComplete ? _get(_getPrototypeOf(MaskedDate.prototype), "typedValue", this) : null;
      },
      set: function set(value) {
        _set(_getPrototypeOf(MaskedDate.prototype), "typedValue", value, this, true);
      }
      /**
        @override
      */
    }, {
      key: "maskEquals",
      value: function maskEquals(mask) {
        return mask === Date || _get(_getPrototypeOf(MaskedDate.prototype), "maskEquals", this).call(this, mask);
      }
    }]);
    return MaskedDate;
  }(MaskedPattern);
  MaskedDate.DEFAULTS = {
    pattern: 'd{.}`m{.}`Y',
    format: function format(date) {
      if (!date) return '';
      var day = String(date.getDate()).padStart(2, '0');
      var month = String(date.getMonth() + 1).padStart(2, '0');
      var year = date.getFullYear();
      return [day, month, year].join('.');
    },
    parse: function parse(str) {
      var _str$split = str.split('.'),
        _str$split2 = _slicedToArray(_str$split, 3),
        day = _str$split2[0],
        month = _str$split2[1],
        year = _str$split2[2];
      return new Date(year, month - 1, day);
    }
  };
  MaskedDate.GET_DEFAULT_BLOCKS = function () {
    return {
      d: {
        mask: MaskedRange,
        from: 1,
        to: 31,
        maxLength: 2
      },
      m: {
        mask: MaskedRange,
        from: 1,
        to: 12,
        maxLength: 2
      },
      Y: {
        mask: MaskedRange,
        from: 1900,
        to: 9999
      }
    };
  };
  IMask.MaskedDate = MaskedDate;

  /**
    Generic element API to use with mask
    @interface
  */
  var MaskElement = /*#__PURE__*/function () {
    function MaskElement() {
      _classCallCheck(this, MaskElement);
    }
    _createClass(MaskElement, [{
      key: "selectionStart",
      get: /** */

      /** */

      /** */

      /** Safely returns selection start */
      function get() {
        var start;
        try {
          start = this._unsafeSelectionStart;
        } catch (e) {}
        return start != null ? start : this.value.length;
      }
      /** Safely returns selection end */
    }, {
      key: "selectionEnd",
      get: function get() {
        var end;
        try {
          end = this._unsafeSelectionEnd;
        } catch (e) {}
        return end != null ? end : this.value.length;
      }
      /** Safely sets element selection */
    }, {
      key: "select",
      value: function select(start, end) {
        if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;
        try {
          this._unsafeSelect(start, end);
        } catch (e) {}
      }
      /** Should be overriden in subclasses */
    }, {
      key: "_unsafeSelect",
      value: function _unsafeSelect(start, end) {}
      /** Should be overriden in subclasses */
    }, {
      key: "isActive",
      get: function get() {
        return false;
      }
      /** Should be overriden in subclasses */
    }, {
      key: "bindEvents",
      value: function bindEvents(handlers) {}
      /** Should be overriden in subclasses */
    }, {
      key: "unbindEvents",
      value: function unbindEvents() {}
    }]);
    return MaskElement;
  }();
  IMask.MaskElement = MaskElement;

  /** Bridge between HTMLElement and {@link Masked} */

  var HTMLMaskElement = /*#__PURE__*/function (_MaskElement) {
    _inherits(HTMLMaskElement, _MaskElement);
    var _super = _createSuper(HTMLMaskElement);

    /** Mapping between HTMLElement events and mask internal events */

    /** HTMLElement to use mask on */

    /**
      @param {HTMLInputElement|HTMLTextAreaElement} input
    */
    function HTMLMaskElement(input) {
      var _this;
      _classCallCheck(this, HTMLMaskElement);
      _this = _super.call(this);
      _this.input = input;
      _this._handlers = {};
      return _this;
    }
    /** */
    // $FlowFixMe https://github.com/facebook/flow/issues/2839

    _createClass(HTMLMaskElement, [{
      key: "rootElement",
      get: function get() {
        var _this$input$getRootNo, _this$input$getRootNo2, _this$input;
        return (_this$input$getRootNo = (_this$input$getRootNo2 = (_this$input = this.input).getRootNode) === null || _this$input$getRootNo2 === void 0 ? void 0 : _this$input$getRootNo2.call(_this$input)) !== null && _this$input$getRootNo !== void 0 ? _this$input$getRootNo : document;
      }
      /**
        Is element in focus
        @readonly
      */
    }, {
      key: "isActive",
      get: function get() {
        //$FlowFixMe
        return this.input === this.rootElement.activeElement;
      }
      /**
        Returns HTMLElement selection start
        @override
      */
    }, {
      key: "_unsafeSelectionStart",
      get: function get() {
        return this.input.selectionStart;
      }
      /**
        Returns HTMLElement selection end
        @override
      */
    }, {
      key: "_unsafeSelectionEnd",
      get: function get() {
        return this.input.selectionEnd;
      }
      /**
        Sets HTMLElement selection
        @override
      */
    }, {
      key: "_unsafeSelect",
      value: function _unsafeSelect(start, end) {
        this.input.setSelectionRange(start, end);
      }
      /**
        HTMLElement value
        @override
      */
    }, {
      key: "value",
      get: function get() {
        return this.input.value;
      },
      set: function set(value) {
        this.input.value = value;
      }
      /**
        Binds HTMLElement events to mask internal events
        @override
      */
    }, {
      key: "bindEvents",
      value: function bindEvents(handlers) {
        var _this2 = this;
        Object.keys(handlers).forEach(function (event) {
          return _this2._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event]);
        });
      }
      /**
        Unbinds HTMLElement events to mask internal events
        @override
      */
    }, {
      key: "unbindEvents",
      value: function unbindEvents() {
        var _this3 = this;
        Object.keys(this._handlers).forEach(function (event) {
          return _this3._toggleEventHandler(event);
        });
      }
      /** */
    }, {
      key: "_toggleEventHandler",
      value: function _toggleEventHandler(event, handler) {
        if (this._handlers[event]) {
          this.input.removeEventListener(event, this._handlers[event]);
          delete this._handlers[event];
        }
        if (handler) {
          this.input.addEventListener(event, handler);
          this._handlers[event] = handler;
        }
      }
    }]);
    return HTMLMaskElement;
  }(MaskElement);
  HTMLMaskElement.EVENTS_MAP = {
    selectionChange: 'keydown',
    input: 'input',
    drop: 'drop',
    click: 'click',
    focus: 'focus',
    commit: 'blur'
  };
  IMask.HTMLMaskElement = HTMLMaskElement;
  var HTMLContenteditableMaskElement = /*#__PURE__*/function (_HTMLMaskElement) {
    _inherits(HTMLContenteditableMaskElement, _HTMLMaskElement);
    var _super = _createSuper(HTMLContenteditableMaskElement);
    function HTMLContenteditableMaskElement() {
      _classCallCheck(this, HTMLContenteditableMaskElement);
      return _super.apply(this, arguments);
    }
    _createClass(HTMLContenteditableMaskElement, [{
      key: "_unsafeSelectionStart",
      get:
      /**
        Returns HTMLElement selection start
        @override
      */
      function get() {
        var root = this.rootElement;
        var selection = root.getSelection && root.getSelection();
        var anchorOffset = selection && selection.anchorOffset;
        var focusOffset = selection && selection.focusOffset;
        if (focusOffset == null || anchorOffset == null || anchorOffset < focusOffset) {
          return anchorOffset;
        }
        return focusOffset;
      }
      /**
        Returns HTMLElement selection end
        @override
      */
    }, {
      key: "_unsafeSelectionEnd",
      get: function get() {
        var root = this.rootElement;
        var selection = root.getSelection && root.getSelection();
        var anchorOffset = selection && selection.anchorOffset;
        var focusOffset = selection && selection.focusOffset;
        if (focusOffset == null || anchorOffset == null || anchorOffset > focusOffset) {
          return anchorOffset;
        }
        return focusOffset;
      }
      /**
        Sets HTMLElement selection
        @override
      */
    }, {
      key: "_unsafeSelect",
      value: function _unsafeSelect(start, end) {
        if (!this.rootElement.createRange) return;
        var range = this.rootElement.createRange();
        range.setStart(this.input.firstChild || this.input, start);
        range.setEnd(this.input.lastChild || this.input, end);
        var root = this.rootElement;
        var selection = root.getSelection && root.getSelection();
        if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
      /**
        HTMLElement value
        @override
      */
    }, {
      key: "value",
      get: function get() {
        // $FlowFixMe
        return this.input.textContent;
      },
      set: function set(value) {
        this.input.textContent = value;
      }
    }]);
    return HTMLContenteditableMaskElement;
  }(HTMLMaskElement);
  IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;
  var _excluded$1 = ["mask"];
  /** Listens to element events and controls changes between element and {@link Masked} */

  var InputMask = /*#__PURE__*/function () {
    /**
      View element
      @readonly
    */

    /**
      Internal {@link Masked} model
      @readonly
    */

    /**
      @param {MaskElement|HTMLInputElement|HTMLTextAreaElement} el
      @param {Object} opts
    */
    function InputMask(el, opts) {
      _classCallCheck(this, InputMask);
      this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA' ? new HTMLContenteditableMaskElement(el) : new HTMLMaskElement(el);
      this.masked = createMask(opts);
      this._listeners = {};
      this._value = '';
      this._unmaskedValue = '';
      this._saveSelection = this._saveSelection.bind(this);
      this._onInput = this._onInput.bind(this);
      this._onChange = this._onChange.bind(this);
      this._onDrop = this._onDrop.bind(this);
      this._onFocus = this._onFocus.bind(this);
      this._onClick = this._onClick.bind(this);
      this.alignCursor = this.alignCursor.bind(this);
      this.alignCursorFriendly = this.alignCursorFriendly.bind(this);
      this._bindEvents(); // refresh

      this.updateValue();
      this._onChange();
    }
    /** Read or update mask */

    _createClass(InputMask, [{
      key: "mask",
      get: function get() {
        return this.masked.mask;
      },
      set: function set(mask) {
        if (this.maskEquals(mask)) return; // $FlowFixMe No ideas ... after update

        if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {
          this.masked.updateOptions({
            mask: mask
          });
          return;
        }
        var masked = createMask({
          mask: mask
        });
        masked.unmaskedValue = this.masked.unmaskedValue;
        this.masked = masked;
      }
      /** Raw value */
    }, {
      key: "maskEquals",
      value: function maskEquals(mask) {
        var _this$masked;
        return mask == null || ((_this$masked = this.masked) === null || _this$masked === void 0 ? void 0 : _this$masked.maskEquals(mask));
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(str) {
        if (this.value === str) return;
        this.masked.value = str;
        this.updateControl();
        this.alignCursor();
      }
      /** Unmasked value */
    }, {
      key: "unmaskedValue",
      get: function get() {
        return this._unmaskedValue;
      },
      set: function set(str) {
        if (this.unmaskedValue === str) return;
        this.masked.unmaskedValue = str;
        this.updateControl();
        this.alignCursor();
      }
      /** Typed unmasked value */
    }, {
      key: "typedValue",
      get: function get() {
        return this.masked.typedValue;
      },
      set: function set(val) {
        if (this.masked.typedValueEquals(val)) return;
        this.masked.typedValue = val;
        this.updateControl();
        this.alignCursor();
      }
      /**
        Starts listening to element events
        @protected
      */
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this.el.bindEvents({
          selectionChange: this._saveSelection,
          input: this._onInput,
          drop: this._onDrop,
          click: this._onClick,
          focus: this._onFocus,
          commit: this._onChange
        });
      }
      /**
        Stops listening to element events
        @protected
       */
    }, {
      key: "_unbindEvents",
      value: function _unbindEvents() {
        if (this.el) this.el.unbindEvents();
      }
      /**
        Fires custom event
        @protected
       */
    }, {
      key: "_fireEvent",
      value: function _fireEvent(ev) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var listeners = this._listeners[ev];
        if (!listeners) return;
        listeners.forEach(function (l) {
          return l.apply(void 0, args);
        });
      }
      /**
        Current selection start
        @readonly
      */
    }, {
      key: "selectionStart",
      get: function get() {
        return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
      }
      /** Current cursor position */
    }, {
      key: "cursorPos",
      get: function get() {
        return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
      },
      set: function set(pos) {
        if (!this.el || !this.el.isActive) return;
        this.el.select(pos, pos);
        this._saveSelection();
      }
      /**
        Stores current selection
        @protected
      */
    }, {
      key: "_saveSelection",
      value: function /* ev */
      _saveSelection() {
        if (this.value !== this.el.value) {
          console.warn('Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.'); // eslint-disable-line no-console
        }

        this._selection = {
          start: this.selectionStart,
          end: this.cursorPos
        };
      }
      /** Syncronizes model value from view */
    }, {
      key: "updateValue",
      value: function updateValue() {
        this.masked.value = this.el.value;
        this._value = this.masked.value;
      }
      /** Syncronizes view from model value, fires change events */
    }, {
      key: "updateControl",
      value: function updateControl() {
        var newUnmaskedValue = this.masked.unmaskedValue;
        var newValue = this.masked.value;
        var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;
        this._unmaskedValue = newUnmaskedValue;
        this._value = newValue;
        if (this.el.value !== newValue) this.el.value = newValue;
        if (isChanged) this._fireChangeEvents();
      }
      /** Updates options with deep equal check, recreates @{link Masked} model if mask type changes */
    }, {
      key: "updateOptions",
      value: function updateOptions(opts) {
        var mask = opts.mask,
          restOpts = _objectWithoutProperties(opts, _excluded$1);
        var updateMask = !this.maskEquals(mask);
        var updateOpts = !objectIncludes(this.masked, restOpts);
        if (updateMask) this.mask = mask;
        if (updateOpts) this.masked.updateOptions(restOpts);
        if (updateMask || updateOpts) this.updateControl();
      }
      /** Updates cursor */
    }, {
      key: "updateCursor",
      value: function updateCursor(cursorPos) {
        if (cursorPos == null) return;
        this.cursorPos = cursorPos; // also queue change cursor for mobile browsers

        this._delayUpdateCursor(cursorPos);
      }
      /**
        Delays cursor update to support mobile browsers
        @private
      */
    }, {
      key: "_delayUpdateCursor",
      value: function _delayUpdateCursor(cursorPos) {
        var _this = this;
        this._abortUpdateCursor();
        this._changingCursorPos = cursorPos;
        this._cursorChanging = setTimeout(function () {
          if (!_this.el) return; // if was destroyed

          _this.cursorPos = _this._changingCursorPos;
          _this._abortUpdateCursor();
        }, 10);
      }
      /**
        Fires custom events
        @protected
      */
    }, {
      key: "_fireChangeEvents",
      value: function _fireChangeEvents() {
        this._fireEvent('accept', this._inputEvent);
        if (this.masked.isComplete) this._fireEvent('complete', this._inputEvent);
      }
      /**
        Aborts delayed cursor update
        @private
      */
    }, {
      key: "_abortUpdateCursor",
      value: function _abortUpdateCursor() {
        if (this._cursorChanging) {
          clearTimeout(this._cursorChanging);
          delete this._cursorChanging;
        }
      }
      /** Aligns cursor to nearest available position */
    }, {
      key: "alignCursor",
      value: function alignCursor() {
        this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT));
      }
      /** Aligns cursor only if selection is empty */
    }, {
      key: "alignCursorFriendly",
      value: function alignCursorFriendly() {
        if (this.selectionStart !== this.cursorPos) return; // skip if range is selected

        this.alignCursor();
      }
      /** Adds listener on custom event */
    }, {
      key: "on",
      value: function on(ev, handler) {
        if (!this._listeners[ev]) this._listeners[ev] = [];
        this._listeners[ev].push(handler);
        return this;
      }
      /** Removes custom event listener */
    }, {
      key: "off",
      value: function off(ev, handler) {
        if (!this._listeners[ev]) return this;
        if (!handler) {
          delete this._listeners[ev];
          return this;
        }
        var hIndex = this._listeners[ev].indexOf(handler);
        if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);
        return this;
      }
      /** Handles view input event */
    }, {
      key: "_onInput",
      value: function _onInput(e) {
        this._inputEvent = e;
        this._abortUpdateCursor(); // fix strange IE behavior

        if (!this._selection) return this.updateValue();
        var details = new ActionDetails(
        // new state
        this.el.value, this.cursorPos,
        // old state
        this.value, this._selection);
        var oldRawValue = this.masked.rawInputValue;
        var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection, {
          input: true,
          raw: true
        }).offset; // force align in remove direction only if no input chars were removed
        // otherwise we still need to align with NONE (to get out from fixed symbols for instance)

        var removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;
        var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);
        if (removeDirection !== DIRECTION.NONE) cursorPos = this.masked.nearestInputPos(cursorPos, DIRECTION.NONE);
        this.updateControl();
        this.updateCursor(cursorPos);
        delete this._inputEvent;
      }
      /** Handles view change event and commits model value */
    }, {
      key: "_onChange",
      value: function _onChange() {
        if (this.value !== this.el.value) {
          this.updateValue();
        }
        this.masked.doCommit();
        this.updateControl();
        this._saveSelection();
      }
      /** Handles view drop event, prevents by default */
    }, {
      key: "_onDrop",
      value: function _onDrop(ev) {
        ev.preventDefault();
        ev.stopPropagation();
      }
      /** Restore last selection on focus */
    }, {
      key: "_onFocus",
      value: function _onFocus(ev) {
        this.alignCursorFriendly();
      }
      /** Restore last selection on focus */
    }, {
      key: "_onClick",
      value: function _onClick(ev) {
        this.alignCursorFriendly();
      }
      /** Unbind view events and removes element reference */
    }, {
      key: "destroy",
      value: function destroy() {
        this._unbindEvents(); // $FlowFixMe why not do so?

        this._listeners.length = 0; // $FlowFixMe

        delete this.el;
      }
    }]);
    return InputMask;
  }();
  IMask.InputMask = InputMask;

  /** Pattern which validates enum values */

  var MaskedEnum = /*#__PURE__*/function (_MaskedPattern) {
    _inherits(MaskedEnum, _MaskedPattern);
    var _super = _createSuper(MaskedEnum);
    function MaskedEnum() {
      _classCallCheck(this, MaskedEnum);
      return _super.apply(this, arguments);
    }
    _createClass(MaskedEnum, [{
      key: "_update",
      value:
      /**
        @override
        @param {Object} opts
      */
      function _update(opts) {
        // TODO type
        if (opts.enum) opts.mask = '*'.repeat(opts.enum[0].length);
        _get(_getPrototypeOf(MaskedEnum.prototype), "_update", this).call(this, opts);
      }
      /**
        @override
      */
    }, {
      key: "doValidate",
      value: function doValidate() {
        var _this = this,
          _get2;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.enum.some(function (e) {
          return e.indexOf(_this.unmaskedValue) >= 0;
        }) && (_get2 = _get(_getPrototypeOf(MaskedEnum.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
      }
    }]);
    return MaskedEnum;
  }(MaskedPattern);
  IMask.MaskedEnum = MaskedEnum;

  /**
    Number mask
    @param {Object} opts
    @param {string} opts.radix - Single char
    @param {string} opts.thousandsSeparator - Single char
    @param {Array<string>} opts.mapToRadix - Array of single chars
    @param {number} opts.min
    @param {number} opts.max
    @param {number} opts.scale - Digits after point
    @param {boolean} opts.signed - Allow negative
    @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing
    @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing
  */
  var MaskedNumber = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedNumber, _Masked);
    var _super = _createSuper(MaskedNumber);

    /** Single char */

    /** Single char */

    /** Array of single chars */

    /** */

    /** */

    /** Digits after point */

    /** */

    /** Flag to remove leading and trailing zeros in the end of editing */

    /** Flag to pad trailing zeros after point in the end of editing */
    function MaskedNumber(opts) {
      _classCallCheck(this, MaskedNumber);
      return _super.call(this, Object.assign({}, MaskedNumber.DEFAULTS, opts));
    }
    /**
      @override
    */

    _createClass(MaskedNumber, [{
      key: "_update",
      value: function _update(opts) {
        _get(_getPrototypeOf(MaskedNumber.prototype), "_update", this).call(this, opts);
        this._updateRegExps();
      }
      /** */
    }, {
      key: "_updateRegExps",
      value: function _updateRegExps() {
        // use different regexp to process user input (more strict, input suffix) and tail shifting
        var start = '^' + (this.allowNegative ? '[+|\\-]?' : '');
        var midInput = '(0|([1-9]+\\d*))?';
        var mid = '\\d*';
        var end = (this.scale ? '(' + escapeRegExp(this.radix) + '\\d{0,' + this.scale + '})?' : '') + '$';
        this._numberRegExpInput = new RegExp(start + midInput + end);
        this._numberRegExp = new RegExp(start + mid + end);
        this._mapToRadixRegExp = new RegExp('[' + this.mapToRadix.map(escapeRegExp).join('') + ']', 'g');
        this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');
      }
      /** */
    }, {
      key: "_removeThousandsSeparators",
      value: function _removeThousandsSeparators(value) {
        return value.replace(this._thousandsSeparatorRegExp, '');
      }
      /** */
    }, {
      key: "_insertThousandsSeparators",
      value: function _insertThousandsSeparators(value) {
        // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript
        var parts = value.split(this.radix);
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
        return parts.join(this.radix);
      }
      /**
        @override
      */
    }, {
      key: "doPrepare",
      value: function doPrepare(ch) {
        var _get2;
        ch = ch.replace(this._mapToRadixRegExp, this.radix);
        var noSepCh = this._removeThousandsSeparators(ch);
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var _normalizePrepare = normalizePrepare((_get2 = _get(_getPrototypeOf(MaskedNumber.prototype), "doPrepare", this)).call.apply(_get2, [this, noSepCh].concat(args))),
          _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2),
          prepCh = _normalizePrepare2[0],
          details = _normalizePrepare2[1];
        if (ch && !noSepCh) details.skip = true;
        return [prepCh, details];
      }
      /** */
    }, {
      key: "_separatorsCount",
      value: function _separatorsCount(to) {
        var extendOnSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var count = 0;
        for (var pos = 0; pos < to; ++pos) {
          if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {
            ++count;
            if (extendOnSeparators) to += this.thousandsSeparator.length;
          }
        }
        return count;
      }
      /** */
    }, {
      key: "_separatorsCountFromSlice",
      value: function _separatorsCountFromSlice() {
        var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._value;
        return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);
      }
      /**
        @override
      */
    }, {
      key: "extractInput",
      value: function extractInput() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        var flags = arguments.length > 2 ? arguments[2] : undefined;
        var _this$_adjustRangeWit = this._adjustRangeWithSeparators(fromPos, toPos);
        var _this$_adjustRangeWit2 = _slicedToArray(_this$_adjustRangeWit, 2);
        fromPos = _this$_adjustRangeWit2[0];
        toPos = _this$_adjustRangeWit2[1];
        return this._removeThousandsSeparators(_get(_getPrototypeOf(MaskedNumber.prototype), "extractInput", this).call(this, fromPos, toPos, flags));
      }
      /**
        @override
      */
    }, {
      key: "_appendCharRaw",
      value: function _appendCharRaw(ch) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!this.thousandsSeparator) return _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);
        var prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
        var prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);
        this._value = this._removeThousandsSeparators(this.value);
        var appendDetails = _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);
        this._value = this._insertThousandsSeparators(this._value);
        var beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
        var beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);
        appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;
        appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;
        return appendDetails;
      }
      /** */
    }, {
      key: "_findSeparatorAround",
      value: function _findSeparatorAround(pos) {
        if (this.thousandsSeparator) {
          var searchFrom = pos - this.thousandsSeparator.length + 1;
          var separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);
          if (separatorPos <= pos) return separatorPos;
        }
        return -1;
      }
    }, {
      key: "_adjustRangeWithSeparators",
      value: function _adjustRangeWithSeparators(from, to) {
        var separatorAroundFromPos = this._findSeparatorAround(from);
        if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;
        var separatorAroundToPos = this._findSeparatorAround(to);
        if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;
        return [from, to];
      }
      /**
        @override
      */
    }, {
      key: "remove",
      value: function remove() {
        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
        var _this$_adjustRangeWit3 = this._adjustRangeWithSeparators(fromPos, toPos);
        var _this$_adjustRangeWit4 = _slicedToArray(_this$_adjustRangeWit3, 2);
        fromPos = _this$_adjustRangeWit4[0];
        toPos = _this$_adjustRangeWit4[1];
        var valueBeforePos = this.value.slice(0, fromPos);
        var valueAfterPos = this.value.slice(toPos);
        var prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);
        this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));
        var beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);
        return new ChangeDetails({
          tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length
        });
      }
      /**
        @override
      */
    }, {
      key: "nearestInputPos",
      value: function nearestInputPos(cursorPos, direction) {
        if (!this.thousandsSeparator) return cursorPos;
        switch (direction) {
          case DIRECTION.NONE:
          case DIRECTION.LEFT:
          case DIRECTION.FORCE_LEFT:
            {
              var separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);
              if (separatorAtLeftPos >= 0) {
                var separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;
                if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {
                  return separatorAtLeftPos;
                }
              }
              break;
            }
          case DIRECTION.RIGHT:
          case DIRECTION.FORCE_RIGHT:
            {
              var separatorAtRightPos = this._findSeparatorAround(cursorPos);
              if (separatorAtRightPos >= 0) {
                return separatorAtRightPos + this.thousandsSeparator.length;
              }
            }
        }
        return cursorPos;
      }
      /**
        @override
      */
    }, {
      key: "doValidate",
      value: function doValidate(flags) {
        var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp; // validate as string

        var valid = regexp.test(this._removeThousandsSeparators(this.value));
        if (valid) {
          // validate as number
          var number = this.number;
          valid = valid && !isNaN(number) && (
          // check min bound for negative values
          this.min == null || this.min >= 0 || this.min <= this.number) && (
          // check max bound for positive values
          this.max == null || this.max <= 0 || this.number <= this.max);
        }
        return valid && _get(_getPrototypeOf(MaskedNumber.prototype), "doValidate", this).call(this, flags);
      }
      /**
        @override
      */
    }, {
      key: "doCommit",
      value: function doCommit() {
        if (this.value) {
          var number = this.number;
          var validnum = number; // check bounds

          if (this.min != null) validnum = Math.max(validnum, this.min);
          if (this.max != null) validnum = Math.min(validnum, this.max);
          if (validnum !== number) this.unmaskedValue = String(validnum);
          var formatted = this.value;
          if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);
          if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);
          this._value = formatted;
        }
        _get(_getPrototypeOf(MaskedNumber.prototype), "doCommit", this).call(this);
      }
      /** */
    }, {
      key: "_normalizeZeros",
      value: function _normalizeZeros(value) {
        var parts = this._removeThousandsSeparators(value).split(this.radix); // remove leading zeros

        parts[0] = parts[0].replace(/^(\D*)(0*)(\d*)/, function (match, sign, zeros, num) {
          return sign + num;
        }); // add leading zero

        if (value.length && !/\d$/.test(parts[0])) parts[0] = parts[0] + '0';
        if (parts.length > 1) {
          parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros

          if (!parts[1].length) parts.length = 1; // remove fractional
        }

        return this._insertThousandsSeparators(parts.join(this.radix));
      }
      /** */
    }, {
      key: "_padFractionalZeros",
      value: function _padFractionalZeros(value) {
        if (!value) return value;
        var parts = value.split(this.radix);
        if (parts.length < 2) parts.push('');
        parts[1] = parts[1].padEnd(this.scale, '0');
        return parts.join(this.radix);
      }
      /**
        @override
      */
    }, {
      key: "unmaskedValue",
      get: function get() {
        return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, '.');
      },
      set: function set(unmaskedValue) {
        _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", unmaskedValue.replace('.', this.radix), this, true);
      }
      /**
        @override
      */
    }, {
      key: "typedValue",
      get: function get() {
        return Number(this.unmaskedValue);
      },
      set: function set(n) {
        _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", String(n), this, true);
      }
      /** Parsed Number */
    }, {
      key: "number",
      get: function get() {
        return this.typedValue;
      },
      set: function set(number) {
        this.typedValue = number;
      }
      /**
        Is negative allowed
        @readonly
      */
    }, {
      key: "allowNegative",
      get: function get() {
        return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;
      }
      /**
        @override
      */
    }, {
      key: "typedValueEquals",
      value: function typedValueEquals(value) {
        // handle  0 -> '' case (typed = 0 even if value = '')
        // for details see https://github.com/uNmAnNeR/imaskjs/issues/134
        return (_get(_getPrototypeOf(MaskedNumber.prototype), "typedValueEquals", this).call(this, value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');
      }
    }]);
    return MaskedNumber;
  }(Masked);
  MaskedNumber.DEFAULTS = {
    radix: ',',
    thousandsSeparator: '',
    mapToRadix: ['.'],
    scale: 2,
    signed: false,
    normalizeZeros: true,
    padFractionalZeros: false
  };
  MaskedNumber.EMPTY_VALUES = [].concat(_toConsumableArray(Masked.EMPTY_VALUES), [0]);
  IMask.MaskedNumber = MaskedNumber;

  /** Masking by custom Function */

  var MaskedFunction = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedFunction, _Masked);
    var _super = _createSuper(MaskedFunction);
    function MaskedFunction() {
      _classCallCheck(this, MaskedFunction);
      return _super.apply(this, arguments);
    }
    _createClass(MaskedFunction, [{
      key: "_update",
      value:
      /**
        @override
        @param {Object} opts
      */
      function _update(opts) {
        if (opts.mask) opts.validate = opts.mask;
        _get(_getPrototypeOf(MaskedFunction.prototype), "_update", this).call(this, opts);
      }
    }]);
    return MaskedFunction;
  }(Masked);
  IMask.MaskedFunction = MaskedFunction;
  var _excluded = ["compiledMasks", "currentMaskRef", "currentMask"];

  /** Dynamic mask for choosing apropriate mask in run-time */
  var MaskedDynamic = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedDynamic, _Masked);
    var _super = _createSuper(MaskedDynamic);

    /** Currently chosen mask */

    /** Compliled {@link Masked} options */

    /** Chooses {@link Masked} depending on input value */

    /**
      @param {Object} opts
    */
    function MaskedDynamic(opts) {
      var _this;
      _classCallCheck(this, MaskedDynamic);
      _this = _super.call(this, Object.assign({}, MaskedDynamic.DEFAULTS, opts));
      _this.currentMask = null;
      return _this;
    }
    /**
      @override
    */

    _createClass(MaskedDynamic, [{
      key: "_update",
      value: function _update(opts) {
        _get(_getPrototypeOf(MaskedDynamic.prototype), "_update", this).call(this, opts);
        if ('mask' in opts) {
          // mask could be totally dynamic with only `dispatch` option
          this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {
            return createMask(m);
          }) : [];
        }
      }
      /**
        @override
      */
    }, {
      key: "_appendCharRaw",
      value: function _appendCharRaw(ch) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var details = this._applyDispatch(ch, flags);
        if (this.currentMask) {
          details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));
        }
        return details;
      }
    }, {
      key: "_applyDispatch",
      value: function _applyDispatch() {
        var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;
        var inputValue = this.rawInputValue;
        var insertValue = flags.tail && flags._beforeTailState != null ?
        // $FlowFixMe - tired to fight with type system
        flags._beforeTailState._rawInputValue : inputValue;
        var tailValue = inputValue.slice(insertValue.length);
        var prevMask = this.currentMask;
        var details = new ChangeDetails();
        var prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state; // clone flags to prevent overwriting `_beforeTailState`

        this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch

        if (this.currentMask) {
          if (this.currentMask !== prevMask) {
            // if mask changed reapply input
            this.currentMask.reset();
            if (insertValue) {
              // $FlowFixMe - it's ok, we don't change current mask above
              var d = this.currentMask.append(insertValue, {
                raw: true
              });
              details.tailShift = d.inserted.length - prevValueBeforeTail.length;
            }
            if (tailValue) {
              // $FlowFixMe - it's ok, we don't change current mask above
              details.tailShift += this.currentMask.append(tailValue, {
                raw: true,
                tail: true
              }).tailShift;
            }
          } else {
            // Dispatch can do something bad with state, so
            // restore prev mask state
            this.currentMask.state = prevMaskState;
          }
        }
        return details;
      }
    }, {
      key: "_appendPlaceholder",
      value: function _appendPlaceholder() {
        var details = this._applyDispatch.apply(this, arguments);
        if (this.currentMask) {
          details.aggregate(this.currentMask._appendPlaceholder());
        }
        return details;
      }
      /**
       @override
      */
    }, {
      key: "_appendEager",
      value: function _appendEager() {
        var details = this._applyDispatch.apply(this, arguments);
        if (this.currentMask) {
          details.aggregate(this.currentMask._appendEager());
        }
        return details;
      }
    }, {
      key: "currentMaskFlags",
      value: function currentMaskFlags(flags) {
        var _flags$_beforeTailSta, _flags$_beforeTailSta2;
        return Object.assign({}, flags, {
          _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState
        });
      }
      /**
        @override
      */
    }, {
      key: "doDispatch",
      value: function doDispatch(appended) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.dispatch(appended, this, flags);
      }
      /**
        @override
      */
    }, {
      key: "doValidate",
      value: function doValidate(flags) {
        return _get(_getPrototypeOf(MaskedDynamic.prototype), "doValidate", this).call(this, flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));
      }
      /**
        @override
      */
    }, {
      key: "doPrepare",
      value: function doPrepare(str) {
        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _normalizePrepare = normalizePrepare(_get(_getPrototypeOf(MaskedDynamic.prototype), "doPrepare", this).call(this, str, flags)),
          _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2),
          s = _normalizePrepare2[0],
          details = _normalizePrepare2[1];
        if (this.currentMask) {
          var currentDetails;
          var _normalizePrepare3 = normalizePrepare(_get(_getPrototypeOf(MaskedDynamic.prototype), "doPrepare", this).call(this, s, this.currentMaskFlags(flags)));
          var _normalizePrepare4 = _slicedToArray(_normalizePrepare3, 2);
          s = _normalizePrepare4[0];
          currentDetails = _normalizePrepare4[1];
          details = details.aggregate(currentDetails);
        }
        return [s, details];
      }
      /**
        @override
      */
    }, {
      key: "reset",
      value: function reset() {
        var _this$currentMask;
        (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();
        this.compiledMasks.forEach(function (m) {
          return m.reset();
        });
      }
      /**
        @override
      */
    }, {
      key: "value",
      get: function get() {
        return this.currentMask ? this.currentMask.value : '';
      },
      set: function set(value) {
        _set(_getPrototypeOf(MaskedDynamic.prototype), "value", value, this, true);
      }
      /**
        @override
      */
    }, {
      key: "unmaskedValue",
      get: function get() {
        return this.currentMask ? this.currentMask.unmaskedValue : '';
      },
      set: function set(unmaskedValue) {
        _set(_getPrototypeOf(MaskedDynamic.prototype), "unmaskedValue", unmaskedValue, this, true);
      }
      /**
        @override
      */
    }, {
      key: "typedValue",
      get: function get() {
        return this.currentMask ? this.currentMask.typedValue : '';
      } // probably typedValue should not be used with dynamic
      ,

      set: function set(value) {
        var unmaskedValue = String(value); // double check it

        if (this.currentMask) {
          this.currentMask.typedValue = value;
          unmaskedValue = this.currentMask.unmaskedValue;
        }
        this.unmaskedValue = unmaskedValue;
      }
      /**
        @override
      */
    }, {
      key: "isComplete",
      get: function get() {
        var _this$currentMask2;
        return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);
      }
      /**
        @override
      */
    }, {
      key: "isFilled",
      get: function get() {
        var _this$currentMask3;
        return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);
      }
      /**
        @override
      */
    }, {
      key: "remove",
      value: function remove() {
        var details = new ChangeDetails();
        if (this.currentMask) {
          var _this$currentMask4;
          details.aggregate((_this$currentMask4 = this.currentMask).remove.apply(_this$currentMask4, arguments)) // update with dispatch
          .aggregate(this._applyDispatch());
        }
        return details;
      }
      /**
        @override
      */
    }, {
      key: "state",
      get: function get() {
        var _this$currentMask5;
        return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic.prototype), "state", this), {
          _rawInputValue: this.rawInputValue,
          compiledMasks: this.compiledMasks.map(function (m) {
            return m.state;
          }),
          currentMaskRef: this.currentMask,
          currentMask: (_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.state
        });
      },
      set: function set(state) {
        var compiledMasks = state.compiledMasks,
          currentMaskRef = state.currentMaskRef,
          currentMask = state.currentMask,
          maskedState = _objectWithoutProperties(state, _excluded);
        this.compiledMasks.forEach(function (m, mi) {
          return m.state = compiledMasks[mi];
        });
        if (currentMaskRef != null) {
          this.currentMask = currentMaskRef;
          this.currentMask.state = currentMask;
        }
        _set(_getPrototypeOf(MaskedDynamic.prototype), "state", maskedState, this, true);
      }
      /**
        @override
      */
    }, {
      key: "extractInput",
      value: function extractInput() {
        var _this$currentMask6;
        return this.currentMask ? (_this$currentMask6 = this.currentMask).extractInput.apply(_this$currentMask6, arguments) : '';
      }
      /**
        @override
      */
    }, {
      key: "extractTail",
      value: function extractTail() {
        var _this$currentMask7, _get2;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.currentMask ? (_this$currentMask7 = this.currentMask).extractTail.apply(_this$currentMask7, args) : (_get2 = _get(_getPrototypeOf(MaskedDynamic.prototype), "extractTail", this)).call.apply(_get2, [this].concat(args));
      }
      /**
        @override
      */
    }, {
      key: "doCommit",
      value: function doCommit() {
        if (this.currentMask) this.currentMask.doCommit();
        _get(_getPrototypeOf(MaskedDynamic.prototype), "doCommit", this).call(this);
      }
      /**
        @override
      */
    }, {
      key: "nearestInputPos",
      value: function nearestInputPos() {
        var _this$currentMask8, _get3;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this.currentMask ? (_this$currentMask8 = this.currentMask).nearestInputPos.apply(_this$currentMask8, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic.prototype), "nearestInputPos", this)).call.apply(_get3, [this].concat(args));
      }
    }, {
      key: "overwrite",
      get: function get() {
        return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic.prototype), "overwrite", this);
      },
      set: function set(overwrite) {
        console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
      }
    }, {
      key: "eager",
      get: function get() {
        return this.currentMask ? this.currentMask.eager : _get(_getPrototypeOf(MaskedDynamic.prototype), "eager", this);
      },
      set: function set(eager) {
        console.warn('"eager" option is not available in dynamic mask, use this option in siblings');
      }
      /**
        @override
      */
    }, {
      key: "maskEquals",
      value: function maskEquals(mask) {
        return Array.isArray(mask) && this.compiledMasks.every(function (m, mi) {
          var _mask$mi;
          return m.maskEquals((_mask$mi = mask[mi]) === null || _mask$mi === void 0 ? void 0 : _mask$mi.mask);
        });
      }
      /**
        @override
      */
    }, {
      key: "typedValueEquals",
      value: function typedValueEquals(value) {
        var _this$currentMask9;
        return Boolean((_this$currentMask9 = this.currentMask) === null || _this$currentMask9 === void 0 ? void 0 : _this$currentMask9.typedValueEquals(value));
      }
    }]);
    return MaskedDynamic;
  }(Masked);
  MaskedDynamic.DEFAULTS = {
    dispatch: function dispatch(appended, masked, flags) {
      if (!masked.compiledMasks.length) return;
      var inputValue = masked.rawInputValue; // simulate input

      var inputs = masked.compiledMasks.map(function (m, index) {
        m.reset();
        m.append(inputValue, {
          raw: true
        });
        m.append(appended, masked.currentMaskFlags(flags));
        var weight = m.rawInputValue.length;
        return {
          weight: weight,
          index: index
        };
      }); // pop masks with longer values first

      inputs.sort(function (i1, i2) {
        return i2.weight - i1.weight;
      });
      return masked.compiledMasks[inputs[0].index];
    }
  };
  IMask.MaskedDynamic = MaskedDynamic;

  /** Mask pipe source and destination types */

  var PIPE_TYPE = {
    MASKED: 'value',
    UNMASKED: 'unmaskedValue',
    TYPED: 'typedValue'
  };
  /** Creates new pipe function depending on mask type, source and destination options */

  function createPipe(mask) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIPE_TYPE.MASKED;
    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PIPE_TYPE.MASKED;
    var masked = createMask(mask);
    return function (value) {
      return masked.runIsolated(function (m) {
        m[from] = value;
        return m[to];
      });
    };
  }
  /** Pipes value through mask depending on mask type, source and destination options */

  function pipe(value) {
    for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      pipeArgs[_key - 1] = arguments[_key];
    }
    return createPipe.apply(void 0, pipeArgs)(value);
  }
  IMask.PIPE_TYPE = PIPE_TYPE;
  IMask.createPipe = createPipe;
  IMask.pipe = pipe;
  try {
    globalThis.IMask = IMask;
  } catch (e) {}
  exports.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;
  exports.HTMLMaskElement = HTMLMaskElement;
  exports.InputMask = InputMask;
  exports.MaskElement = MaskElement;
  exports.Masked = Masked;
  exports.MaskedDate = MaskedDate;
  exports.MaskedDynamic = MaskedDynamic;
  exports.MaskedEnum = MaskedEnum;
  exports.MaskedFunction = MaskedFunction;
  exports.MaskedNumber = MaskedNumber;
  exports.MaskedPattern = MaskedPattern;
  exports.MaskedRange = MaskedRange;
  exports.MaskedRegExp = MaskedRegExp;
  exports.PIPE_TYPE = PIPE_TYPE;
  exports.createMask = createMask;
  exports.createPipe = createPipe;
  exports["default"] = IMask;
  exports.pipe = pipe;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./js/inputmask.js":
/*!*************************!*\
  !*** ./js/inputmask.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/*!
 * dist/inputmask
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2021 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.7
 */
!function (e, t) {
  if ("object" == ( false ? undefined : _typeof(exports)) && "object" == ( false ? undefined : _typeof(module))) module.exports = t();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else { var a, i; }
}(self, function () {
  return function () {
    "use strict";

    var e = {
        8741: function _(e, t) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = void 0;
          var i = !("undefined" == typeof window || !window.document || !window.document.createElement);
          t.default = i;
        },
        3976: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = void 0;
          var a,
            n = (a = i(5581)) && a.__esModule ? a : {
              default: a
            };
          var r = {
            _maxTestPos: 500,
            placeholder: "_",
            optionalmarker: ["[", "]"],
            quantifiermarker: ["{", "}"],
            groupmarker: ["(", ")"],
            alternatormarker: "|",
            escapeChar: "\\",
            mask: null,
            regex: null,
            oncomplete: function oncomplete() {},
            onincomplete: function onincomplete() {},
            oncleared: function oncleared() {},
            repeat: 0,
            greedy: !1,
            autoUnmask: !1,
            removeMaskOnSubmit: !1,
            clearMaskOnLostFocus: !0,
            insertMode: !0,
            insertModeVisual: !0,
            clearIncomplete: !1,
            alias: null,
            onKeyDown: function onKeyDown() {},
            onBeforeMask: null,
            onBeforePaste: function onBeforePaste(e, t) {
              return "function" == typeof t.onBeforeMask ? t.onBeforeMask.call(this, e, t) : e;
            },
            onBeforeWrite: null,
            onUnMask: null,
            showMaskOnFocus: !0,
            showMaskOnHover: !0,
            onKeyValidation: function onKeyValidation() {},
            skipOptionalPartCharacter: " ",
            numericInput: !1,
            rightAlign: !1,
            undoOnEscape: !0,
            radixPoint: "",
            _radixDance: !1,
            groupSeparator: "",
            keepStatic: null,
            positionCaretOnTab: !0,
            tabThrough: !1,
            supportsInputType: ["text", "tel", "url", "password", "search"],
            ignorables: [n.default.BACKSPACE, n.default.TAB, n.default["PAUSE/BREAK"], n.default.ESCAPE, n.default.PAGE_UP, n.default.PAGE_DOWN, n.default.END, n.default.HOME, n.default.LEFT, n.default.UP, n.default.RIGHT, n.default.DOWN, n.default.INSERT, n.default.DELETE, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
            isComplete: null,
            preValidation: null,
            postValidation: null,
            staticDefinitionSymbol: void 0,
            jitMasking: !1,
            nullable: !0,
            inputEventOnly: !1,
            noValuePatching: !1,
            positionCaretOnClick: "lvp",
            casing: null,
            inputmode: "text",
            importDataAttributes: !0,
            shiftPositions: !0,
            usePrototypeDefinitions: !0,
            validationEventTimeOut: 3e3,
            substitutes: {}
          };
          t.default = r;
        },
        7392: function _(e, t) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = void 0;
          t.default = {
            9: {
              validator: "[0-9\uFF10-\uFF19]",
              definitionSymbol: "*"
            },
            a: {
              validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
              definitionSymbol: "*"
            },
            "*": {
              validator: "[0-9\uFF10-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]"
            }
          };
        },
        253: function _(e, t) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = function (e, t, i) {
            if (void 0 === i) return e.__data ? e.__data[t] : null;
            e.__data = e.__data || {}, e.__data[t] = i;
          };
        },
        3776: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.Event = void 0, t.off = function (e, t) {
            var i, a;
            function n(e, t, n) {
              if (e in i == !0) if (a.removeEventListener ? a.removeEventListener(e, n, !1) : a.detachEvent && a.detachEvent("on" + e, n), "global" === t) for (var r in i[e]) {
                i[e][r].splice(i[e][r].indexOf(n), 1);
              } else i[e][t].splice(i[e][t].indexOf(n), 1);
            }
            function r(e, a) {
              var n,
                r,
                o = [];
              if (e.length > 0) {
                if (void 0 === t) for (n = 0, r = i[e][a].length; n < r; n++) {
                  o.push({
                    ev: e,
                    namespace: a && a.length > 0 ? a : "global",
                    handler: i[e][a][n]
                  });
                } else o.push({
                  ev: e,
                  namespace: a && a.length > 0 ? a : "global",
                  handler: t
                });
              } else if (a.length > 0) for (var l in i) {
                for (var s in i[l]) {
                  if (s === a) if (void 0 === t) for (n = 0, r = i[l][s].length; n < r; n++) {
                    o.push({
                      ev: l,
                      namespace: s,
                      handler: i[l][s][n]
                    });
                  } else o.push({
                    ev: l,
                    namespace: s,
                    handler: t
                  });
                }
              }
              return o;
            }
            if (u(this[0]) && e) {
              i = this[0].eventRegistry, a = this[0];
              for (var o = e.split(" "), l = 0; l < o.length; l++) {
                for (var s = o[l].split("."), c = r(s[0], s[1]), f = 0, d = c.length; f < d; f++) {
                  n(c[f].ev, c[f].namespace, c[f].handler);
                }
              }
            }
            return this;
          }, t.on = function (e, t) {
            function i(e, i) {
              n.addEventListener ? n.addEventListener(e, t, !1) : n.attachEvent && n.attachEvent("on" + e, t), a[e] = a[e] || {}, a[e][i] = a[e][i] || [], a[e][i].push(t);
            }
            if (u(this[0])) for (var a = this[0].eventRegistry, n = this[0], r = e.split(" "), o = 0; o < r.length; o++) {
              var l = r[o].split("."),
                s = l[0],
                c = l[1] || "global";
              i(s, c);
            }
            return this;
          }, t.trigger = function (e) {
            if (u(this[0])) for (var t = this[0].eventRegistry, i = this[0], a = "string" == typeof e ? e.split(" ") : [e.type], r = 0; r < a.length; r++) {
              var l = a[r].split("."),
                s = l[0],
                c = l[1] || "global";
              if (void 0 !== document && "global" === c) {
                var f,
                  d,
                  p = {
                    bubbles: !0,
                    cancelable: !0,
                    detail: arguments[1]
                  };
                if (document.createEvent) {
                  try {
                    if ("input" === s) p.inputType = "insertText", f = new InputEvent(s, p);else f = new CustomEvent(s, p);
                  } catch (e) {
                    (f = document.createEvent("CustomEvent")).initCustomEvent(s, p.bubbles, p.cancelable, p.detail);
                  }
                  e.type && (0, n.default)(f, e), i.dispatchEvent(f);
                } else (f = document.createEventObject()).eventType = s, f.detail = arguments[1], e.type && (0, n.default)(f, e), i.fireEvent("on" + f.eventType, f);
              } else if (void 0 !== t[s]) if (arguments[0] = arguments[0].type ? arguments[0] : o.default.Event(arguments[0]), arguments[0].detail = arguments.slice(1), "global" === c) for (var h in t[s]) {
                for (d = 0; d < t[s][h].length; d++) {
                  t[s][h][d].apply(i, arguments);
                }
              } else for (d = 0; d < t[s][c].length; d++) {
                t[s][c][d].apply(i, arguments);
              }
            }
            return this;
          };
          var a,
            n = s(i(600)),
            r = s(i(9380)),
            o = s(i(4963)),
            l = s(i(8741));
          function s(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          function u(e) {
            return e instanceof Element;
          }
          t.Event = a, "function" == typeof r.default.CustomEvent ? t.Event = a = r.default.CustomEvent : l.default && (t.Event = a = function a(e, t) {
            t = t || {
              bubbles: !1,
              cancelable: !1,
              detail: void 0
            };
            var i = document.createEvent("CustomEvent");
            return i.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), i;
          }, a.prototype = r.default.Event.prototype);
        },
        600: function _(e, t) {
          function i(e) {
            return i = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
              return _typeof(e);
            } : function (e) {
              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
            }, i(e);
          }
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = function e() {
            var t,
              a,
              n,
              r,
              o,
              l,
              s = arguments[0] || {},
              u = 1,
              c = arguments.length,
              f = !1;
            "boolean" == typeof s && (f = s, s = arguments[u] || {}, u++);
            "object" !== i(s) && "function" != typeof s && (s = {});
            for (; u < c; u++) {
              if (null != (t = arguments[u])) for (a in t) {
                n = s[a], r = t[a], s !== r && (f && r && ("[object Object]" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = !1, l = n && Array.isArray(n) ? n : []) : l = n && "[object Object]" === Object.prototype.toString.call(n) ? n : {}, s[a] = e(f, l, r)) : void 0 !== r && (s[a] = r));
              }
            }
            return s;
          };
        },
        4963: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = void 0;
          var a = l(i(600)),
            n = l(i(9380)),
            r = l(i(253)),
            o = i(3776);
          function l(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          var s = n.default.document;
          function u(e) {
            return e instanceof u ? e : this instanceof u ? void (null != e && e !== n.default && (this[0] = e.nodeName ? e : void 0 !== e[0] && e[0].nodeName ? e[0] : s.querySelector(e), void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new u(e);
          }
          u.prototype = {
            on: o.on,
            off: o.off,
            trigger: o.trigger
          }, u.extend = a.default, u.data = r.default, u.Event = o.Event;
          var c = u;
          t.default = c;
        },
        9845: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.ua = t.mobile = t.iphone = t.iemobile = t.ie = void 0;
          var a,
            n = (a = i(9380)) && a.__esModule ? a : {
              default: a
            };
          var r = n.default.navigator && n.default.navigator.userAgent || "",
            o = r.indexOf("MSIE ") > 0 || r.indexOf("Trident/") > 0,
            l = ("ontouchstart" in n.default),
            s = /iemobile/i.test(r),
            u = /iphone/i.test(r) && !s;
          t.iphone = u, t.iemobile = s, t.mobile = l, t.ie = o, t.ua = r;
        },
        7184: function _(e, t) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = function (e) {
            return e.replace(i, "\\$1");
          };
          var i = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim");
        },
        6030: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.EventHandlers = void 0;
          var a,
            n = i(8711),
            r = (a = i(5581)) && a.__esModule ? a : {
              default: a
            },
            o = i(9845),
            l = i(7215),
            s = i(7760),
            u = i(4713);
          function c(e, t) {
            var i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (!i) {
              if (Array.isArray(e) || (i = function (e, t) {
                if (!e) return;
                if ("string" == typeof e) return f(e, t);
                var i = Object.prototype.toString.call(e).slice(8, -1);
                "Object" === i && e.constructor && (i = e.constructor.name);
                if ("Map" === i || "Set" === i) return Array.from(e);
                if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return f(e, t);
              }(e)) || t && e && "number" == typeof e.length) {
                i && (e = i);
                var a = 0,
                  n = function n() {};
                return {
                  s: n,
                  n: function n() {
                    return a >= e.length ? {
                      done: !0
                    } : {
                      done: !1,
                      value: e[a++]
                    };
                  },
                  e: function e(_e) {
                    throw _e;
                  },
                  f: n
                };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var r,
              o = !0,
              l = !1;
            return {
              s: function s() {
                i = i.call(e);
              },
              n: function n() {
                var e = i.next();
                return o = e.done, e;
              },
              e: function e(_e2) {
                l = !0, r = _e2;
              },
              f: function f() {
                try {
                  o || null == i.return || i.return();
                } finally {
                  if (l) throw r;
                }
              }
            };
          }
          function f(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var i = 0, a = new Array(t); i < t; i++) {
              a[i] = e[i];
            }
            return a;
          }
          var d = {
            keydownEvent: function keydownEvent(e) {
              var t = this.inputmask,
                i = t.opts,
                a = t.dependencyLib,
                c = t.maskset,
                f = this,
                d = a(f),
                p = e.keyCode,
                h = n.caret.call(t, f),
                v = i.onKeyDown.call(this, e, n.getBuffer.call(t), h, i);
              if (void 0 !== v) return v;
              if (p === r.default.BACKSPACE || p === r.default.DELETE || o.iphone && p === r.default.BACKSPACE_SAFARI || e.ctrlKey && p === r.default.X && !("oncut" in f)) e.preventDefault(), l.handleRemove.call(t, f, p, h), (0, s.writeBuffer)(f, n.getBuffer.call(t, !0), c.p, e, f.inputmask._valueGet() !== n.getBuffer.call(t).join(""));else if (p === r.default.END || p === r.default.PAGE_DOWN) {
                e.preventDefault();
                var m = n.seekNext.call(t, n.getLastValidPosition.call(t));
                n.caret.call(t, f, e.shiftKey ? h.begin : m, m, !0);
              } else p === r.default.HOME && !e.shiftKey || p === r.default.PAGE_UP ? (e.preventDefault(), n.caret.call(t, f, 0, e.shiftKey ? h.begin : 0, !0)) : i.undoOnEscape && p === r.default.ESCAPE && !0 !== e.altKey ? ((0, s.checkVal)(f, !0, !1, t.undoValue.split("")), d.trigger("click")) : p !== r.default.INSERT || e.shiftKey || e.ctrlKey || void 0 !== t.userOptions.insertMode ? !0 === i.tabThrough && p === r.default.TAB ? !0 === e.shiftKey ? (h.end = n.seekPrevious.call(t, h.end, !0), !0 === u.getTest.call(t, h.end - 1).match.static && h.end--, h.begin = n.seekPrevious.call(t, h.end, !0), h.begin >= 0 && h.end > 0 && (e.preventDefault(), n.caret.call(t, f, h.begin, h.end))) : (h.begin = n.seekNext.call(t, h.begin, !0), h.end = n.seekNext.call(t, h.begin, !0), h.end < c.maskLength && h.end--, h.begin <= c.maskLength && (e.preventDefault(), n.caret.call(t, f, h.begin, h.end))) : e.shiftKey || i.insertModeVisual && !1 === i.insertMode && (p === r.default.RIGHT ? setTimeout(function () {
                var e = n.caret.call(t, f);
                n.caret.call(t, f, e.begin);
              }, 0) : p === r.default.LEFT && setTimeout(function () {
                var e = n.translatePosition.call(t, f.inputmask.caretPos.begin);
                n.translatePosition.call(t, f.inputmask.caretPos.end);
                t.isRTL ? n.caret.call(t, f, e + (e === c.maskLength ? 0 : 1)) : n.caret.call(t, f, e - (0 === e ? 0 : 1));
              }, 0)) : l.isSelection.call(t, h) ? i.insertMode = !i.insertMode : (i.insertMode = !i.insertMode, n.caret.call(t, f, h.begin, h.begin));
              t.ignorable = i.ignorables.includes(p);
            },
            keypressEvent: function keypressEvent(e, t, i, a, o) {
              var u = this.inputmask || this,
                c = u.opts,
                f = u.dependencyLib,
                d = u.maskset,
                p = u.el,
                h = f(p),
                v = e.keyCode;
              if (!(!0 === t || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || u.ignorable)) return v === r.default.ENTER && u.undoValue !== u._valueGet(!0) && (u.undoValue = u._valueGet(!0), setTimeout(function () {
                h.trigger("change");
              }, 0)), u.skipInputEvent = !0, !0;
              if (v) {
                44 !== v && 46 !== v || 3 !== e.location || "" === c.radixPoint || (v = c.radixPoint.charCodeAt(0));
                var m,
                  g = t ? {
                    begin: o,
                    end: o
                  } : n.caret.call(u, p),
                  k = String.fromCharCode(v);
                k = c.substitutes[k] || k, d.writeOutBuffer = !0;
                var y = l.isValid.call(u, g, k, a, void 0, void 0, void 0, t);
                if (!1 !== y && (n.resetMaskSet.call(u, !0), m = void 0 !== y.caret ? y.caret : n.seekNext.call(u, y.pos.begin ? y.pos.begin : y.pos), d.p = m), m = c.numericInput && void 0 === y.caret ? n.seekPrevious.call(u, m) : m, !1 !== i && (setTimeout(function () {
                  c.onKeyValidation.call(p, v, y);
                }, 0), d.writeOutBuffer && !1 !== y)) {
                  var b = n.getBuffer.call(u);
                  (0, s.writeBuffer)(p, b, m, e, !0 !== t);
                }
                if (e.preventDefault(), t) return !1 !== y && (y.forwardPosition = m), y;
              }
            },
            keyupEvent: function keyupEvent(e) {
              var t = this.inputmask;
              !t.isComposing || e.keyCode !== r.default.KEY_229 && e.keyCode !== r.default.ENTER || t.$el.trigger("input");
            },
            pasteEvent: function pasteEvent(e) {
              var t,
                i = this.inputmask,
                a = i.opts,
                r = i._valueGet(!0),
                o = n.caret.call(i, this);
              i.isRTL && (t = o.end, o.end = n.translatePosition.call(i, o.begin), o.begin = n.translatePosition.call(i, t));
              var l = r.substr(0, o.begin),
                u = r.substr(o.end, r.length);
              if (l == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(0, o.begin).join("") && (l = ""), u == (i.isRTL ? n.getBufferTemplate.call(i).slice().reverse() : n.getBufferTemplate.call(i)).slice(o.end).join("") && (u = ""), window.clipboardData && window.clipboardData.getData) r = l + window.clipboardData.getData("Text") + u;else {
                if (!e.clipboardData || !e.clipboardData.getData) return !0;
                r = l + e.clipboardData.getData("text/plain") + u;
              }
              var f = r;
              if (i.isRTL) {
                f = f.split("");
                var d,
                  p = c(n.getBufferTemplate.call(i));
                try {
                  for (p.s(); !(d = p.n()).done;) {
                    var h = d.value;
                    f[0] === h && f.shift();
                  }
                } catch (e) {
                  p.e(e);
                } finally {
                  p.f();
                }
                f = f.join("");
              }
              if ("function" == typeof a.onBeforePaste) {
                if (!1 === (f = a.onBeforePaste.call(i, f, a))) return !1;
                f || (f = r);
              }
              (0, s.checkVal)(this, !0, !1, f.toString().split(""), e), e.preventDefault();
            },
            inputFallBackEvent: function inputFallBackEvent(e) {
              var t = this.inputmask,
                i = t.opts,
                a = t.dependencyLib;
              var l = this,
                c = l.inputmask._valueGet(!0),
                f = (t.isRTL ? n.getBuffer.call(t).slice().reverse() : n.getBuffer.call(t)).join(""),
                p = n.caret.call(t, l, void 0, void 0, !0);
              if (f !== c) {
                c = function (e, i, a) {
                  if (o.iemobile) {
                    var r = i.replace(n.getBuffer.call(t).join(""), "");
                    if (1 === r.length) {
                      var l = i.split("");
                      l.splice(a.begin, 0, r), i = l.join("");
                    }
                  }
                  return i;
                }(0, c, p);
                var h = function (e, a, r) {
                  for (var o, l, s, c = e.substr(0, r.begin).split(""), f = e.substr(r.begin).split(""), d = a.substr(0, r.begin).split(""), p = a.substr(r.begin).split(""), h = c.length >= d.length ? c.length : d.length, v = f.length >= p.length ? f.length : p.length, m = "", g = [], k = "~"; c.length < h;) {
                    c.push(k);
                  }
                  for (; d.length < h;) {
                    d.push(k);
                  }
                  for (; f.length < v;) {
                    f.unshift(k);
                  }
                  for (; p.length < v;) {
                    p.unshift(k);
                  }
                  var y = c.concat(f),
                    b = d.concat(p);
                  for (l = 0, o = y.length; l < o; l++) {
                    switch (s = u.getPlaceholder.call(t, n.translatePosition.call(t, l)), m) {
                      case "insertText":
                        b[l - 1] === y[l] && r.begin == y.length - 1 && g.push(y[l]), l = o;
                        break;
                      case "insertReplacementText":
                      case "deleteContentBackward":
                        y[l] === k ? r.end++ : l = o;
                        break;
                      default:
                        y[l] !== b[l] && (y[l + 1] !== k && y[l + 1] !== s && void 0 !== y[l + 1] || (b[l] !== s || b[l + 1] !== k) && b[l] !== k ? b[l + 1] === k && b[l] === y[l + 1] ? (m = "insertText", g.push(y[l]), r.begin--, r.end--) : y[l] !== s && y[l] !== k && (y[l + 1] === k || b[l] !== y[l] && b[l + 1] === y[l + 1]) ? (m = "insertReplacementText", g.push(y[l]), r.begin--) : y[l] === k ? (m = "deleteContentBackward", (n.isMask.call(t, n.translatePosition.call(t, l), !0) || b[l] === i.radixPoint) && r.end++) : l = o : (m = "insertText", g.push(y[l]), r.begin--, r.end--));
                    }
                  }
                  return {
                    action: m,
                    data: g,
                    caret: r
                  };
                }(c, f, p);
                switch ((l.inputmask.shadowRoot || l.ownerDocument).activeElement !== l && l.focus(), (0, s.writeBuffer)(l, n.getBuffer.call(t)), n.caret.call(t, l, p.begin, p.end, !0), h.action) {
                  case "insertText":
                  case "insertReplacementText":
                    h.data.forEach(function (e, i) {
                      var n = new a.Event("keypress");
                      n.keyCode = e.charCodeAt(0), t.ignorable = !1, d.keypressEvent.call(l, n);
                    }), setTimeout(function () {
                      t.$el.trigger("keyup");
                    }, 0);
                    break;
                  case "deleteContentBackward":
                    var v = new a.Event("keydown");
                    v.keyCode = r.default.BACKSPACE, d.keydownEvent.call(l, v);
                    break;
                  default:
                    (0, s.applyInputValue)(l, c);
                }
                e.preventDefault();
              }
            },
            compositionendEvent: function compositionendEvent(e) {
              var t = this.inputmask;
              t.isComposing = !1, t.$el.trigger("input");
            },
            setValueEvent: function setValueEvent(e) {
              var t = this.inputmask,
                i = this,
                a = e && e.detail ? e.detail[0] : arguments[1];
              void 0 === a && (a = i.inputmask._valueGet(!0)), (0, s.applyInputValue)(i, a), (e.detail && void 0 !== e.detail[1] || void 0 !== arguments[2]) && n.caret.call(t, i, e.detail ? e.detail[1] : arguments[2]);
            },
            focusEvent: function focusEvent(e) {
              var t = this.inputmask,
                i = t.opts,
                a = this,
                r = a.inputmask._valueGet();
              i.showMaskOnFocus && r !== n.getBuffer.call(t).join("") && (0, s.writeBuffer)(a, n.getBuffer.call(t), n.seekNext.call(t, n.getLastValidPosition.call(t))), !0 !== i.positionCaretOnTab || !1 !== t.mouseEnter || l.isComplete.call(t, n.getBuffer.call(t)) && -1 !== n.getLastValidPosition.call(t) || d.clickEvent.apply(a, [e, !0]), t.undoValue = t._valueGet(!0);
            },
            invalidEvent: function invalidEvent(e) {
              this.inputmask.validationEvent = !0;
            },
            mouseleaveEvent: function mouseleaveEvent() {
              var e = this.inputmask,
                t = e.opts,
                i = this;
              e.mouseEnter = !1, t.clearMaskOnLostFocus && (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i && (0, s.HandleNativePlaceholder)(i, e.originalPlaceholder);
            },
            clickEvent: function clickEvent(e, t) {
              var i = this.inputmask,
                a = this;
              if ((a.inputmask.shadowRoot || a.ownerDocument).activeElement === a) {
                var r = n.determineNewCaretPosition.call(i, n.caret.call(i, a), t);
                void 0 !== r && n.caret.call(i, a, r);
              }
            },
            cutEvent: function cutEvent(e) {
              var t = this.inputmask,
                i = t.maskset,
                a = this,
                o = n.caret.call(t, a),
                u = t.isRTL ? n.getBuffer.call(t).slice(o.end, o.begin) : n.getBuffer.call(t).slice(o.begin, o.end),
                c = t.isRTL ? u.reverse().join("") : u.join("");
              window.navigator.clipboard ? window.navigator.clipboard.writeText(c) : window.clipboardData && window.clipboardData.getData && window.clipboardData.setData("Text", c), l.handleRemove.call(t, a, r.default.DELETE, o), (0, s.writeBuffer)(a, n.getBuffer.call(t), i.p, e, t.undoValue !== t._valueGet(!0));
            },
            blurEvent: function blurEvent(e) {
              var t = this.inputmask,
                i = t.opts,
                a = (0, t.dependencyLib)(this),
                r = this;
              if (r.inputmask) {
                (0, s.HandleNativePlaceholder)(r, t.originalPlaceholder);
                var o = r.inputmask._valueGet(),
                  u = n.getBuffer.call(t).slice();
                "" !== o && (i.clearMaskOnLostFocus && (-1 === n.getLastValidPosition.call(t) && o === n.getBufferTemplate.call(t).join("") ? u = [] : s.clearOptionalTail.call(t, u)), !1 === l.isComplete.call(t, u) && (setTimeout(function () {
                  a.trigger("incomplete");
                }, 0), i.clearIncomplete && (n.resetMaskSet.call(t), u = i.clearMaskOnLostFocus ? [] : n.getBufferTemplate.call(t).slice())), (0, s.writeBuffer)(r, u, void 0, e)), t.undoValue !== t._valueGet(!0) && (t.undoValue = t._valueGet(!0), a.trigger("change"));
              }
            },
            mouseenterEvent: function mouseenterEvent() {
              var e = this.inputmask,
                t = e.opts,
                i = this;
              if (e.mouseEnter = !0, (i.inputmask.shadowRoot || i.ownerDocument).activeElement !== i) {
                var a = (e.isRTL ? n.getBufferTemplate.call(e).slice().reverse() : n.getBufferTemplate.call(e)).join("");
                e.placeholder !== a && i.placeholder !== e.originalPlaceholder && (e.originalPlaceholder = i.placeholder), t.showMaskOnHover && (0, s.HandleNativePlaceholder)(i, a);
              }
            },
            submitEvent: function submitEvent() {
              var e = this.inputmask,
                t = e.opts;
              e.undoValue !== e._valueGet(!0) && e.$el.trigger("change"), -1 === n.getLastValidPosition.call(e) && e._valueGet && e._valueGet() === n.getBufferTemplate.call(e).join("") && e._valueSet(""), t.clearIncomplete && !1 === l.isComplete.call(e, n.getBuffer.call(e)) && e._valueSet(""), t.removeMaskOnSubmit && (e._valueSet(e.unmaskedvalue(), !0), setTimeout(function () {
                (0, s.writeBuffer)(e.el, n.getBuffer.call(e));
              }, 0));
            },
            resetEvent: function resetEvent() {
              var e = this.inputmask;
              e.refreshValue = !0, setTimeout(function () {
                (0, s.applyInputValue)(e.el, e._valueGet(!0));
              }, 0);
            }
          };
          t.EventHandlers = d;
        },
        9716: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.EventRuler = void 0;
          var a = l(i(2394)),
            n = l(i(5581)),
            r = i(8711),
            o = i(7760);
          function l(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          var s = {
            on: function on(e, t, i) {
              var l = e.inputmask.dependencyLib,
                s = function s(t) {
                  t.originalEvent && (t = t.originalEvent || t, arguments[0] = t);
                  var s,
                    u = this,
                    c = u.inputmask,
                    f = c ? c.opts : void 0;
                  if (void 0 === c && "FORM" !== this.nodeName) {
                    var d = l.data(u, "_inputmask_opts");
                    l(u).off(), d && new a.default(d).mask(u);
                  } else {
                    if (["submit", "reset", "setvalue"].includes(t.type) || "FORM" === this.nodeName || !(u.disabled || u.readOnly && !("keydown" === t.type && t.ctrlKey && 67 === t.keyCode || !1 === f.tabThrough && t.keyCode === n.default.TAB))) {
                      switch (t.type) {
                        case "input":
                          if (!0 === c.skipInputEvent || t.inputType && "insertCompositionText" === t.inputType) return c.skipInputEvent = !1, t.preventDefault();
                          break;
                        case "keydown":
                          c.skipKeyPressEvent = !1, c.skipInputEvent = c.isComposing = t.keyCode === n.default.KEY_229;
                          break;
                        case "keyup":
                        case "compositionend":
                          c.isComposing && (c.skipInputEvent = !1);
                          break;
                        case "keypress":
                          if (!0 === c.skipKeyPressEvent) return t.preventDefault();
                          c.skipKeyPressEvent = !0;
                          break;
                        case "click":
                        case "focus":
                          return c.validationEvent ? (c.validationEvent = !1, e.blur(), (0, o.HandleNativePlaceholder)(e, (c.isRTL ? r.getBufferTemplate.call(c).slice().reverse() : r.getBufferTemplate.call(c)).join("")), setTimeout(function () {
                            e.focus();
                          }, f.validationEventTimeOut), !1) : (s = arguments, setTimeout(function () {
                            e.inputmask && i.apply(u, s);
                          }, 0), !1);
                      }
                      var p = i.apply(u, arguments);
                      return !1 === p && (t.preventDefault(), t.stopPropagation()), p;
                    }
                    t.preventDefault();
                  }
                };
              ["submit", "reset"].includes(t) ? (s = s.bind(e), null !== e.form && l(e.form).on(t, s)) : l(e).on(t, s), e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(s);
            },
            off: function off(e, t) {
              if (e.inputmask && e.inputmask.events) {
                var i = e.inputmask.dependencyLib,
                  a = e.inputmask.events;
                for (var n in t && ((a = [])[t] = e.inputmask.events[t]), a) {
                  for (var r = a[n]; r.length > 0;) {
                    var o = r.pop();
                    ["submit", "reset"].includes(n) ? null !== e.form && i(e.form).off(n, o) : i(e).off(n, o);
                  }
                  delete e.inputmask.events[n];
                }
              }
            }
          };
          t.EventRuler = s;
        },
        219: function _(e, t, i) {
          var a = d(i(2394)),
            n = d(i(5581)),
            r = d(i(7184)),
            o = i(8711),
            l = i(4713);
          function s(e) {
            return s = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
              return _typeof(e);
            } : function (e) {
              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
            }, s(e);
          }
          function u(e, t) {
            return function (e) {
              if (Array.isArray(e)) return e;
            }(e) || function (e, t) {
              var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
              if (null == i) return;
              var a,
                n,
                r = [],
                o = !0,
                l = !1;
              try {
                for (i = i.call(e); !(o = (a = i.next()).done) && (r.push(a.value), !t || r.length !== t); o = !0) {
                  ;
                }
              } catch (e) {
                l = !0, n = e;
              } finally {
                try {
                  o || null == i.return || i.return();
                } finally {
                  if (l) throw n;
                }
              }
              return r;
            }(e, t) || function (e, t) {
              if (!e) return;
              if ("string" == typeof e) return c(e, t);
              var i = Object.prototype.toString.call(e).slice(8, -1);
              "Object" === i && e.constructor && (i = e.constructor.name);
              if ("Map" === i || "Set" === i) return Array.from(e);
              if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return c(e, t);
            }(e, t) || function () {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function c(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var i = 0, a = new Array(t); i < t; i++) {
              a[i] = e[i];
            }
            return a;
          }
          function f(e, t) {
            for (var i = 0; i < t.length; i++) {
              var a = t[i];
              a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);
            }
          }
          function d(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          var p = a.default.dependencyLib,
            h = function () {
              function e(t, i, a) {
                !function (e, t) {
                  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                }(this, e), this.mask = t, this.format = i, this.opts = a, this._date = new Date(1, 0, 1), this.initDateObject(t, this.opts);
              }
              var t, i, a;
              return t = e, (i = [{
                key: "date",
                get: function get() {
                  return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts)), this._date;
                }
              }, {
                key: "initDateObject",
                value: function value(e, t) {
                  var i;
                  for (P(t).lastIndex = 0; i = P(t).exec(this.format);) {
                    var a = new RegExp("\\d+$").exec(i[0]),
                      n = a ? i[0][0] + "x" : i[0],
                      r = void 0;
                    if (void 0 !== e) {
                      if (a) {
                        var o = P(t).lastIndex,
                          l = O(i.index, t);
                        P(t).lastIndex = o, r = e.slice(0, e.indexOf(l.nextMatch[0]));
                      } else r = e.slice(0, n.length);
                      e = e.slice(r.length);
                    }
                    Object.prototype.hasOwnProperty.call(g, n) && this.setValue(this, r, n, g[n][2], g[n][1]);
                  }
                }
              }, {
                key: "setValue",
                value: function value(e, t, i, a, n) {
                  if (void 0 !== t && (e[a] = "ampm" === a ? t : t.replace(/[^0-9]/g, "0"), e["raw" + a] = t.replace(/\s/g, "_")), void 0 !== n) {
                    var r = e[a];
                    ("day" === a && 29 === parseInt(r) || "month" === a && 2 === parseInt(r)) && (29 !== parseInt(e.day) || 2 !== parseInt(e.month) || "" !== e.year && void 0 !== e.year || e._date.setFullYear(2012, 1, 29)), "day" === a && (m = !0, 0 === parseInt(r) && (r = 1)), "month" === a && (m = !0), "year" === a && (m = !0, r.length < 4 && (r = _(r, 4, !0))), "" === r || isNaN(r) || n.call(e._date, r), "ampm" === a && n.call(e._date, r);
                  }
                }
              }, {
                key: "reset",
                value: function value() {
                  this._date = new Date(1, 0, 1);
                }
              }, {
                key: "reInit",
                value: function value() {
                  this._date = void 0, this.date;
                }
              }]) && f(t.prototype, i), a && f(t, a), Object.defineProperty(t, "prototype", {
                writable: !1
              }), e;
            }(),
            v = new Date().getFullYear(),
            m = !1,
            g = {
              d: ["[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate],
              dd: ["0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function () {
                return _(Date.prototype.getDate.call(this), 2);
              }],
              ddd: [""],
              dddd: [""],
              m: ["[1-9]|1[012]", function (e) {
                var t = e ? parseInt(e) : 0;
                return t > 0 && t--, Date.prototype.setMonth.call(this, t);
              }, "month", function () {
                return Date.prototype.getMonth.call(this) + 1;
              }],
              mm: ["0[1-9]|1[012]", function (e) {
                var t = e ? parseInt(e) : 0;
                return t > 0 && t--, Date.prototype.setMonth.call(this, t);
              }, "month", function () {
                return _(Date.prototype.getMonth.call(this) + 1, 2);
              }],
              mmm: [""],
              mmmm: [""],
              yy: ["[0-9]{2}", Date.prototype.setFullYear, "year", function () {
                return _(Date.prototype.getFullYear.call(this), 2);
              }],
              yyyy: ["[0-9]{4}", Date.prototype.setFullYear, "year", function () {
                return _(Date.prototype.getFullYear.call(this), 4);
              }],
              h: ["[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours],
              hh: ["0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function () {
                return _(Date.prototype.getHours.call(this), 2);
              }],
              hx: [function (e) {
                return "[0-9]{".concat(e, "}");
              }, Date.prototype.setHours, "hours", function (e) {
                return Date.prototype.getHours;
              }],
              H: ["1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours],
              HH: ["0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function () {
                return _(Date.prototype.getHours.call(this), 2);
              }],
              Hx: [function (e) {
                return "[0-9]{".concat(e, "}");
              }, Date.prototype.setHours, "hours", function (e) {
                return function () {
                  return _(Date.prototype.getHours.call(this), e);
                };
              }],
              M: ["[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes],
              MM: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function () {
                return _(Date.prototype.getMinutes.call(this), 2);
              }],
              s: ["[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds],
              ss: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function () {
                return _(Date.prototype.getSeconds.call(this), 2);
              }],
              l: ["[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function () {
                return _(Date.prototype.getMilliseconds.call(this), 3);
              }],
              L: ["[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function () {
                return _(Date.prototype.getMilliseconds.call(this), 2);
              }],
              t: ["[ap]", y, "ampm", b, 1],
              tt: ["[ap]m", y, "ampm", b, 2],
              T: ["[AP]", y, "ampm", b, 1],
              TT: ["[AP]M", y, "ampm", b, 2],
              Z: [".*", void 0, "Z", function () {
                var e = this.toString().match(/\((.+)\)/)[1];
                e.includes(" ") && (e = (e = e.replace("-", " ").toUpperCase()).split(" ").map(function (e) {
                  return u(e, 1)[0];
                }).join(""));
                return e;
              }],
              o: [""],
              S: [""]
            },
            k = {
              isoDate: "yyyy-mm-dd",
              isoTime: "HH:MM:ss",
              isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
              isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
            };
          function y(e) {
            var t = this.getHours();
            e.toLowerCase().includes("p") ? this.setHours(t + 12) : e.toLowerCase().includes("a") && t >= 12 && this.setHours(t - 12);
          }
          function b() {
            var e = this.getHours();
            return (e = e || 12) >= 12 ? "PM" : "AM";
          }
          function x(e) {
            var t = new RegExp("\\d+$").exec(e[0]);
            if (t && void 0 !== t[0]) {
              var i = g[e[0][0] + "x"].slice("");
              return i[0] = i[0](t[0]), i[3] = i[3](t[0]), i;
            }
            if (g[e[0]]) return g[e[0]];
          }
          function P(e) {
            if (!e.tokenizer) {
              var t = [],
                i = [];
              for (var a in g) {
                if (/\.*x$/.test(a)) {
                  var n = a[0] + "\\d+";
                  -1 === i.indexOf(n) && i.push(n);
                } else -1 === t.indexOf(a[0]) && t.push(a[0]);
              }
              e.tokenizer = "(" + (i.length > 0 ? i.join("|") + "|" : "") + t.join("+|") + ")+?|.", e.tokenizer = new RegExp(e.tokenizer, "g");
            }
            return e.tokenizer;
          }
          function E(e, t, i) {
            if (!m) return !0;
            if (void 0 === e.rawday || !isFinite(e.rawday) && new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day || "29" == e.day && (!isFinite(e.rawyear) || void 0 === e.rawyear || "" === e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) return t;
            if ("29" == e.day) {
              var a = O(t.pos, i);
              if ("yyyy" === a.targetMatch[0] && t.pos - a.targetMatchIndex == 2) return t.remove = t.pos + 1, t;
            } else if ("02" == e.month && "30" == e.day && void 0 !== t.c) return e.day = "03", e.date.setDate(3), e.date.setMonth(1), t.insert = [{
              pos: t.pos,
              c: "0"
            }, {
              pos: t.pos + 1,
              c: t.c
            }], t.caret = o.seekNext.call(this, t.pos + 1), t;
            return !1;
          }
          function S(e, t, i, a) {
            var n,
              o,
              l = "";
            for (P(i).lastIndex = 0; n = P(i).exec(e);) {
              if (void 0 === t) {
                if (o = x(n)) l += "(" + o[0] + ")";else switch (n[0]) {
                  case "[":
                    l += "(";
                    break;
                  case "]":
                    l += ")?";
                    break;
                  default:
                    l += (0, r.default)(n[0]);
                }
              } else if (o = x(n)) {
                if (!0 !== a && o[3]) l += o[3].call(t.date);else o[2] ? l += t["raw" + o[2]] : l += n[0];
              } else l += n[0];
            }
            return l;
          }
          function _(e, t, i) {
            for (e = String(e), t = t || 2; e.length < t;) {
              e = i ? e + "0" : "0" + e;
            }
            return e;
          }
          function w(e, t, i) {
            return "string" == typeof e ? new h(e, t, i) : e && "object" === s(e) && Object.prototype.hasOwnProperty.call(e, "date") ? e : void 0;
          }
          function M(e, t) {
            return S(t.inputFormat, {
              date: e
            }, t);
          }
          function O(e, t) {
            var i,
              a,
              n = 0,
              r = 0;
            for (P(t).lastIndex = 0; a = P(t).exec(t.inputFormat);) {
              var o = new RegExp("\\d+$").exec(a[0]);
              if ((n += r = o ? parseInt(o[0]) : a[0].length) >= e + 1) {
                i = a, a = P(t).exec(t.inputFormat);
                break;
              }
            }
            return {
              targetMatchIndex: n - r,
              nextMatch: a,
              targetMatch: i
            };
          }
          a.default.extendAliases({
            datetime: {
              mask: function mask(e) {
                return e.numericInput = !1, g.S = e.i18n.ordinalSuffix.join("|"), e.inputFormat = k[e.inputFormat] || e.inputFormat, e.displayFormat = k[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = k[e.outputFormat] || e.outputFormat || e.inputFormat, e.placeholder = "" !== e.placeholder ? e.placeholder : e.inputFormat.replace(/[[\]]/, ""), e.regex = S(e.inputFormat, void 0, e), e.min = w(e.min, e.inputFormat, e), e.max = w(e.max, e.inputFormat, e), null;
              },
              placeholder: "",
              inputFormat: "isoDateTime",
              displayFormat: null,
              outputFormat: null,
              min: null,
              max: null,
              skipOptionalPartCharacter: "",
              i18n: {
                dayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
                monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                ordinalSuffix: ["st", "nd", "rd", "th"]
              },
              preValidation: function preValidation(e, t, i, a, n, r, o, l) {
                if (l) return !0;
                if (isNaN(i) && e[t] !== i) {
                  var s = O(t, n);
                  if (s.nextMatch && s.nextMatch[0] === i && s.targetMatch[0].length > 1) {
                    var u = g[s.targetMatch[0]][0];
                    if (new RegExp(u).test("0" + e[t - 1])) return e[t] = e[t - 1], e[t - 1] = "0", {
                      fuzzy: !0,
                      buffer: e,
                      refreshFromBuffer: {
                        start: t - 1,
                        end: t + 1
                      },
                      pos: t + 1
                    };
                  }
                }
                return !0;
              },
              postValidation: function postValidation(e, t, i, a, n, r, o, s) {
                var u, c;
                if (o) return !0;
                if (!1 === a && (((u = O(t + 1, n)).targetMatch && u.targetMatchIndex === t && u.targetMatch[0].length > 1 && void 0 !== g[u.targetMatch[0]] || (u = O(t + 2, n)).targetMatch && u.targetMatchIndex === t + 1 && u.targetMatch[0].length > 1 && void 0 !== g[u.targetMatch[0]]) && (c = g[u.targetMatch[0]][0]), void 0 !== c && (void 0 !== r.validPositions[t + 1] && new RegExp(c).test(i + "0") ? (e[t] = i, e[t + 1] = "0", a = {
                  pos: t + 2,
                  caret: t
                }) : new RegExp(c).test("0" + i) && (e[t] = "0", e[t + 1] = i, a = {
                  pos: t + 2
                })), !1 === a)) return a;
                if (a.fuzzy && (e = a.buffer, t = a.pos), (u = O(t, n)).targetMatch && u.targetMatch[0] && void 0 !== g[u.targetMatch[0]]) {
                  var f = g[u.targetMatch[0]];
                  c = f[0];
                  var d = e.slice(u.targetMatchIndex, u.targetMatchIndex + u.targetMatch[0].length);
                  if (!1 === new RegExp(c).test(d.join("")) && 2 === u.targetMatch[0].length && r.validPositions[u.targetMatchIndex] && r.validPositions[u.targetMatchIndex + 1] && (r.validPositions[u.targetMatchIndex + 1].input = "0"), "year" == f[2]) for (var p = l.getMaskTemplate.call(this, !1, 1, void 0, !0), h = t + 1; h < e.length; h++) {
                    e[h] = p[h], delete r.validPositions[h];
                  }
                }
                var m = a,
                  k = w(e.join(""), n.inputFormat, n);
                return m && k.date.getTime() == k.date.getTime() && (n.prefillYear && (m = function (e, t, i) {
                  if (e.year !== e.rawyear) {
                    var a = v.toString(),
                      n = e.rawyear.replace(/[^0-9]/g, ""),
                      r = a.slice(0, n.length),
                      o = a.slice(n.length);
                    if (2 === n.length && n === r) {
                      var l = new Date(v, e.month - 1, e.day);
                      e.day == l.getDate() && (!i.max || i.max.date.getTime() >= l.getTime()) && (e.date.setFullYear(v), e.year = a, t.insert = [{
                        pos: t.pos + 1,
                        c: o[0]
                      }, {
                        pos: t.pos + 2,
                        c: o[1]
                      }]);
                    }
                  }
                  return t;
                }(k, m, n)), m = function (e, t, i, a, n) {
                  if (!t) return t;
                  if (t && i.min && i.min.date.getTime() == i.min.date.getTime()) {
                    var r;
                    for (e.reset(), P(i).lastIndex = 0; r = P(i).exec(i.inputFormat);) {
                      var o;
                      if ((o = x(r)) && o[3]) {
                        for (var l = o[1], s = e[o[2]], u = i.min[o[2]], c = i.max ? i.max[o[2]] : u, f = [], d = !1, p = 0; p < u.length; p++) {
                          void 0 !== a.validPositions[p + r.index] || d ? (f[p] = s[p], d = d || s[p] > u[p]) : (f[p] = u[p], "year" === o[2] && s.length - 1 == p && u != c && (f = (parseInt(f.join("")) + 1).toString().split("")), "ampm" === o[2] && u != c && i.min.date.getTime() > e.date.getTime() && (f[p] = c[p]));
                        }
                        l.call(e._date, f.join(""));
                      }
                    }
                    t = i.min.date.getTime() <= e.date.getTime(), e.reInit();
                  }
                  return t && i.max && i.max.date.getTime() == i.max.date.getTime() && (t = i.max.date.getTime() >= e.date.getTime()), t;
                }(k, m = E.call(this, k, m, n), n, r)), void 0 !== t && m && a.pos !== t ? {
                  buffer: S(n.inputFormat, k, n).split(""),
                  refreshFromBuffer: {
                    start: t,
                    end: a.pos
                  },
                  pos: a.caret || a.pos
                } : m;
              },
              onKeyDown: function onKeyDown(e, t, i, a) {
                e.ctrlKey && e.keyCode === n.default.RIGHT && (this.inputmask._valueSet(M(new Date(), a)), p(this).trigger("setvalue"));
              },
              onUnMask: function onUnMask(e, t, i) {
                return t ? S(i.outputFormat, w(e, i.inputFormat, i), i, !0) : t;
              },
              casing: function casing(e, t, i, a) {
                return 0 == t.nativeDef.indexOf("[ap]") ? e.toLowerCase() : 0 == t.nativeDef.indexOf("[AP]") ? e.toUpperCase() : e;
              },
              onBeforeMask: function onBeforeMask(e, t) {
                return "[object Date]" === Object.prototype.toString.call(e) && (e = M(e, t)), e;
              },
              insertMode: !1,
              shiftPositions: !1,
              keepStatic: !1,
              inputmode: "numeric",
              prefillYear: !0
            }
          });
        },
        3851: function _(e, t, i) {
          var a,
            n = (a = i(2394)) && a.__esModule ? a : {
              default: a
            },
            r = i(8711),
            o = i(4713);
          n.default.extendDefinitions({
            A: {
              validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
              casing: "upper"
            },
            "&": {
              validator: "[0-9A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
              casing: "upper"
            },
            "#": {
              validator: "[0-9A-Fa-f]",
              casing: "upper"
            }
          });
          var l = new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]");
          function s(e, t, i, a, n) {
            return i - 1 > -1 && "." !== t.buffer[i - 1] ? (e = t.buffer[i - 1] + e, e = i - 2 > -1 && "." !== t.buffer[i - 2] ? t.buffer[i - 2] + e : "0" + e) : e = "00" + e, l.test(e);
          }
          n.default.extendAliases({
            cssunit: {
              regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
            },
            url: {
              regex: "(https?|ftp)://.*",
              autoUnmask: !1,
              keepStatic: !1,
              tabThrough: !0
            },
            ip: {
              mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
              definitions: {
                i: {
                  validator: s
                },
                j: {
                  validator: s
                },
                k: {
                  validator: s
                },
                l: {
                  validator: s
                }
              },
              onUnMask: function onUnMask(e, t, i) {
                return e;
              },
              inputmode: "decimal",
              substitutes: {
                ",": "."
              }
            },
            email: {
              mask: function mask(e) {
                var t = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
                  i = t;
                if (e.separator) for (var a = 0; a < e.quantifier; a++) {
                  i += "[".concat(e.separator).concat(t, "]");
                }
                return i;
              },
              greedy: !1,
              casing: "lower",
              separator: null,
              quantifier: 5,
              skipOptionalPartCharacter: "",
              onBeforePaste: function onBeforePaste(e, t) {
                return (e = e.toLowerCase()).replace("mailto:", "");
              },
              definitions: {
                "*": {
                  validator: "[0-9\uFF11-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5!#$%&'*+/=?^_`{|}~-]"
                },
                "-": {
                  validator: "[0-9A-Za-z-]"
                }
              },
              onUnMask: function onUnMask(e, t, i) {
                return e;
              },
              inputmode: "email"
            },
            mac: {
              mask: "##:##:##:##:##:##"
            },
            vin: {
              mask: "V{13}9{4}",
              definitions: {
                V: {
                  validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                  casing: "upper"
                }
              },
              clearIncomplete: !0,
              autoUnmask: !0
            },
            ssn: {
              mask: "999-99-9999",
              postValidation: function postValidation(e, t, i, a, n, l, s) {
                var u = o.getMaskTemplate.call(this, !0, r.getLastValidPosition.call(this), !0, !0);
                return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(u.join(""));
              }
            }
          });
        },
        207: function _(e, t, i) {
          var a = l(i(2394)),
            n = l(i(5581)),
            r = l(i(7184)),
            o = i(8711);
          function l(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          var s = a.default.dependencyLib;
          function u(e, t) {
            for (var i = "", n = 0; n < e.length; n++) {
              a.default.prototype.definitions[e.charAt(n)] || t.definitions[e.charAt(n)] || t.optionalmarker[0] === e.charAt(n) || t.optionalmarker[1] === e.charAt(n) || t.quantifiermarker[0] === e.charAt(n) || t.quantifiermarker[1] === e.charAt(n) || t.groupmarker[0] === e.charAt(n) || t.groupmarker[1] === e.charAt(n) || t.alternatormarker === e.charAt(n) ? i += "\\" + e.charAt(n) : i += e.charAt(n);
            }
            return i;
          }
          function c(e, t, i, a) {
            if (e.length > 0 && t > 0 && (!i.digitsOptional || a)) {
              var n = e.indexOf(i.radixPoint),
                r = !1;
              i.negationSymbol.back === e[e.length - 1] && (r = !0, e.length--), -1 === n && (e.push(i.radixPoint), n = e.length - 1);
              for (var o = 1; o <= t; o++) {
                isFinite(e[n + o]) || (e[n + o] = "0");
              }
            }
            return r && e.push(i.negationSymbol.back), e;
          }
          function f(e, t) {
            var i = 0;
            if ("+" === e) {
              for (i in t.validPositions) {
                ;
              }
              i = o.seekNext.call(this, parseInt(i));
            }
            for (var a in t.tests) {
              if ((a = parseInt(a)) >= i) for (var n = 0, r = t.tests[a].length; n < r; n++) {
                if ((void 0 === t.validPositions[a] || "-" === e) && t.tests[a][n].match.def === e) return a + (void 0 !== t.validPositions[a] && "-" !== e ? 1 : 0);
              }
            }
            return i;
          }
          function d(e, t) {
            var i = -1;
            for (var a in t.validPositions) {
              var n = t.validPositions[a];
              if (n && n.match.def === e) {
                i = parseInt(a);
                break;
              }
            }
            return i;
          }
          function p(e, t, i, a, n) {
            var r = t.buffer ? t.buffer.indexOf(n.radixPoint) : -1,
              o = (-1 !== r || a && n.jitMasking) && new RegExp(n.definitions[9].validator).test(e);
            return n._radixDance && -1 !== r && o && null == t.validPositions[r] ? {
              insert: {
                pos: r === i ? r + 1 : r,
                c: n.radixPoint
              },
              pos: i
            } : o;
          }
          a.default.extendAliases({
            numeric: {
              mask: function mask(e) {
                e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && "0" !== e.digits && ("." === e.radixPoint ? e.groupSeparator = "," : "," === e.radixPoint ? e.groupSeparator = "." : e.groupSeparator = ""), " " === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.placeholder.length > 1 && (e.placeholder = e.placeholder.charAt(0)), "radixFocus" === e.positionCaretOnClick && "" === e.placeholder && (e.positionCaretOnClick = "lvp");
                var t = "0",
                  i = e.radixPoint;
                !0 === e.numericInput && void 0 === e.__financeInput ? (t = "1", e.positionCaretOnClick = "radixFocus" === e.positionCaretOnClick ? "lvp" : e.positionCaretOnClick, e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e._radixDance = !1, i = "," === e.radixPoint ? "?" : "!", "" !== e.radixPoint && void 0 === e.definitions[i] && (e.definitions[i] = {}, e.definitions[i].validator = "[" + e.radixPoint + "]", e.definitions[i].placeholder = e.radixPoint, e.definitions[i].static = !0, e.definitions[i].generated = !0)) : (e.__financeInput = !1, e.numericInput = !0);
                var a,
                  n = "[+]";
                if (n += u(e.prefix, e), "" !== e.groupSeparator ? (void 0 === e.definitions[e.groupSeparator] && (e.definitions[e.groupSeparator] = {}, e.definitions[e.groupSeparator].validator = "[" + e.groupSeparator + "]", e.definitions[e.groupSeparator].placeholder = e.groupSeparator, e.definitions[e.groupSeparator].static = !0, e.definitions[e.groupSeparator].generated = !0), n += e._mask(e)) : n += "9{+}", void 0 !== e.digits && 0 !== e.digits) {
                  var o = e.digits.toString().split(",");
                  isFinite(o[0]) && o[1] && isFinite(o[1]) ? n += i + t + "{" + e.digits + "}" : (isNaN(e.digits) || parseInt(e.digits) > 0) && (e.digitsOptional || e.jitMasking ? (a = n + i + t + "{0," + e.digits + "}", e.keepStatic = !0) : n += i + t + "{" + e.digits + "}");
                } else e.inputmode = "numeric";
                return n += u(e.suffix, e), n += "[-]", a && (n = [a + u(e.suffix, e) + "[-]", n]), e.greedy = !1, function (e) {
                  void 0 === e.parseMinMaxOptions && (null !== e.min && (e.min = e.min.toString().replace(new RegExp((0, r.default)(e.groupSeparator), "g"), ""), "," === e.radixPoint && (e.min = e.min.replace(e.radixPoint, ".")), e.min = isFinite(e.min) ? parseFloat(e.min) : NaN, isNaN(e.min) && (e.min = Number.MIN_VALUE)), null !== e.max && (e.max = e.max.toString().replace(new RegExp((0, r.default)(e.groupSeparator), "g"), ""), "," === e.radixPoint && (e.max = e.max.replace(e.radixPoint, ".")), e.max = isFinite(e.max) ? parseFloat(e.max) : NaN, isNaN(e.max) && (e.max = Number.MAX_VALUE)), e.parseMinMaxOptions = "done");
                }(e), "" !== e.radixPoint && (e.substitutes["." == e.radixPoint ? "," : "."] = e.radixPoint), n;
              },
              _mask: function _mask(e) {
                return "(" + e.groupSeparator + "999){+|1}";
              },
              digits: "*",
              digitsOptional: !0,
              enforceDigitsOnBlur: !1,
              radixPoint: ".",
              positionCaretOnClick: "radixFocus",
              _radixDance: !0,
              groupSeparator: "",
              allowMinus: !0,
              negationSymbol: {
                front: "-",
                back: ""
              },
              prefix: "",
              suffix: "",
              min: null,
              max: null,
              SetMaxOnOverflow: !1,
              step: 1,
              inputType: "text",
              unmaskAsNumber: !1,
              roundingFN: Math.round,
              inputmode: "decimal",
              shortcuts: {
                k: "1000",
                m: "1000000"
              },
              placeholder: "0",
              greedy: !1,
              rightAlign: !0,
              insertMode: !0,
              autoUnmask: !1,
              skipOptionalPartCharacter: "",
              usePrototypeDefinitions: !1,
              stripLeadingZeroes: !0,
              definitions: {
                0: {
                  validator: p
                },
                1: {
                  validator: p,
                  definitionSymbol: "9"
                },
                9: {
                  validator: "[0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]",
                  definitionSymbol: "*"
                },
                "+": {
                  validator: function validator(e, t, i, a, n) {
                    return n.allowMinus && ("-" === e || e === n.negationSymbol.front);
                  }
                },
                "-": {
                  validator: function validator(e, t, i, a, n) {
                    return n.allowMinus && e === n.negationSymbol.back;
                  }
                }
              },
              preValidation: function preValidation(e, t, i, a, n, r, o, l) {
                if (!1 !== n.__financeInput && i === n.radixPoint) return !1;
                var s = e.indexOf(n.radixPoint),
                  u = t;
                if (t = function (e, t, i, a, n) {
                  return n._radixDance && n.numericInput && t !== n.negationSymbol.back && e <= i && (i > 0 || t == n.radixPoint) && (void 0 === a.validPositions[e - 1] || a.validPositions[e - 1].input !== n.negationSymbol.back) && (e -= 1), e;
                }(t, i, s, r, n), "-" === i || i === n.negationSymbol.front) {
                  if (!0 !== n.allowMinus) return !1;
                  var c = !1,
                    p = d("+", r),
                    h = d("-", r);
                  return -1 !== p && (c = [p, h]), !1 !== c ? {
                    remove: c,
                    caret: u - n.negationSymbol.back.length
                  } : {
                    insert: [{
                      pos: f.call(this, "+", r),
                      c: n.negationSymbol.front,
                      fromIsValid: !0
                    }, {
                      pos: f.call(this, "-", r),
                      c: n.negationSymbol.back,
                      fromIsValid: void 0
                    }],
                    caret: u + n.negationSymbol.back.length
                  };
                }
                if (i === n.groupSeparator) return {
                  caret: u
                };
                if (l) return !0;
                if (-1 !== s && !0 === n._radixDance && !1 === a && i === n.radixPoint && void 0 !== n.digits && (isNaN(n.digits) || parseInt(n.digits) > 0) && s !== t) return {
                  caret: n._radixDance && t === s - 1 ? s + 1 : s
                };
                if (!1 === n.__financeInput) if (a) {
                  if (n.digitsOptional) return {
                    rewritePosition: o.end
                  };
                  if (!n.digitsOptional) {
                    if (o.begin > s && o.end <= s) return i === n.radixPoint ? {
                      insert: {
                        pos: s + 1,
                        c: "0",
                        fromIsValid: !0
                      },
                      rewritePosition: s
                    } : {
                      rewritePosition: s + 1
                    };
                    if (o.begin < s) return {
                      rewritePosition: o.begin - 1
                    };
                  }
                } else if (!n.showMaskOnHover && !n.showMaskOnFocus && !n.digitsOptional && n.digits > 0 && "" === this.__valueGet.call(this.el)) return {
                  rewritePosition: s
                };
                return {
                  rewritePosition: t
                };
              },
              postValidation: function postValidation(e, t, i, a, n, r, o) {
                if (!1 === a) return a;
                if (o) return !0;
                if (null !== n.min || null !== n.max) {
                  var l = n.onUnMask(e.slice().reverse().join(""), void 0, s.extend({}, n, {
                    unmaskAsNumber: !0
                  }));
                  if (null !== n.min && l < n.min && (l.toString().length > n.min.toString().length || l < 0)) return !1;
                  if (null !== n.max && l > n.max) return !!n.SetMaxOnOverflow && {
                    refreshFromBuffer: !0,
                    buffer: c(n.max.toString().replace(".", n.radixPoint).split(""), n.digits, n).reverse()
                  };
                }
                return a;
              },
              onUnMask: function onUnMask(e, t, i) {
                if ("" === t && !0 === i.nullable) return t;
                var a = e.replace(i.prefix, "");
                return a = (a = a.replace(i.suffix, "")).replace(new RegExp((0, r.default)(i.groupSeparator), "g"), ""), "" !== i.placeholder.charAt(0) && (a = a.replace(new RegExp(i.placeholder.charAt(0), "g"), "0")), i.unmaskAsNumber ? ("" !== i.radixPoint && -1 !== a.indexOf(i.radixPoint) && (a = a.replace(r.default.call(this, i.radixPoint), ".")), a = (a = a.replace(new RegExp("^" + (0, r.default)(i.negationSymbol.front)), "-")).replace(new RegExp((0, r.default)(i.negationSymbol.back) + "$"), ""), Number(a)) : a;
              },
              isComplete: function isComplete(e, t) {
                var i = (t.numericInput ? e.slice().reverse() : e).join("");
                return i = (i = (i = (i = (i = i.replace(new RegExp("^" + (0, r.default)(t.negationSymbol.front)), "-")).replace(new RegExp((0, r.default)(t.negationSymbol.back) + "$"), "")).replace(t.prefix, "")).replace(t.suffix, "")).replace(new RegExp((0, r.default)(t.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t.radixPoint && (i = i.replace((0, r.default)(t.radixPoint), ".")), isFinite(i);
              },
              onBeforeMask: function onBeforeMask(e, t) {
                var i = t.radixPoint || ",";
                isFinite(t.digits) && (t.digits = parseInt(t.digits)), "number" != typeof e && "number" !== t.inputType || "" === i || (e = e.toString().replace(".", i));
                var a = "-" === e.charAt(0) || e.charAt(0) === t.negationSymbol.front,
                  n = e.split(i),
                  o = n[0].replace(/[^\-0-9]/g, ""),
                  l = n.length > 1 ? n[1].replace(/[^0-9]/g, "") : "",
                  s = n.length > 1;
                e = o + ("" !== l ? i + l : l);
                var u = 0;
                if ("" !== i && (u = t.digitsOptional ? t.digits < l.length ? t.digits : l.length : t.digits, "" !== l || !t.digitsOptional)) {
                  var f = Math.pow(10, u || 1);
                  e = e.replace((0, r.default)(i), "."), isNaN(parseFloat(e)) || (e = (t.roundingFN(parseFloat(e) * f) / f).toFixed(u)), e = e.toString().replace(".", i);
                }
                if (0 === t.digits && -1 !== e.indexOf(i) && (e = e.substring(0, e.indexOf(i))), null !== t.min || null !== t.max) {
                  var d = e.toString().replace(i, ".");
                  null !== t.min && d < t.min ? e = t.min.toString().replace(".", i) : null !== t.max && d > t.max && (e = t.max.toString().replace(".", i));
                }
                return a && "-" !== e.charAt(0) && (e = "-" + e), c(e.toString().split(""), u, t, s).join("");
              },
              onBeforeWrite: function onBeforeWrite(e, t, i, a) {
                function n(e, t) {
                  if (!1 !== a.__financeInput || t) {
                    var i = e.indexOf(a.radixPoint);
                    -1 !== i && e.splice(i, 1);
                  }
                  if ("" !== a.groupSeparator) for (; -1 !== (i = e.indexOf(a.groupSeparator));) {
                    e.splice(i, 1);
                  }
                  return e;
                }
                var o, l;
                if (a.stripLeadingZeroes && (l = function (e, t) {
                  var i = new RegExp("(^" + ("" !== t.negationSymbol.front ? (0, r.default)(t.negationSymbol.front) + "?" : "") + (0, r.default)(t.prefix) + ")(.*)(" + (0, r.default)(t.suffix) + ("" != t.negationSymbol.back ? (0, r.default)(t.negationSymbol.back) + "?" : "") + "$)").exec(e.slice().reverse().join("")),
                    a = i ? i[2] : "",
                    n = !1;
                  return a && (a = a.split(t.radixPoint.charAt(0))[0], n = new RegExp("^[0" + t.groupSeparator + "]*").exec(a)), !(!n || !(n[0].length > 1 || n[0].length > 0 && n[0].length < a.length)) && n;
                }(t, a))) for (var u = t.join("").lastIndexOf(l[0].split("").reverse().join("")) - (l[0] == l.input ? 0 : 1), f = l[0] == l.input ? 1 : 0, d = l[0].length - f; d > 0; d--) {
                  delete this.maskset.validPositions[u + d], delete t[u + d];
                }
                if (e) switch (e.type) {
                  case "blur":
                  case "checkval":
                    if (null !== a.min) {
                      var p = a.onUnMask(t.slice().reverse().join(""), void 0, s.extend({}, a, {
                        unmaskAsNumber: !0
                      }));
                      if (null !== a.min && p < a.min) return {
                        refreshFromBuffer: !0,
                        buffer: c(a.min.toString().replace(".", a.radixPoint).split(""), a.digits, a).reverse()
                      };
                    }
                    if (t[t.length - 1] === a.negationSymbol.front) {
                      var h = new RegExp("(^" + ("" != a.negationSymbol.front ? (0, r.default)(a.negationSymbol.front) + "?" : "") + (0, r.default)(a.prefix) + ")(.*)(" + (0, r.default)(a.suffix) + ("" != a.negationSymbol.back ? (0, r.default)(a.negationSymbol.back) + "?" : "") + "$)").exec(n(t.slice(), !0).reverse().join(""));
                      0 == (h ? h[2] : "") && (o = {
                        refreshFromBuffer: !0,
                        buffer: [0]
                      });
                    } else if ("" !== a.radixPoint) {
                      t.indexOf(a.radixPoint) === a.suffix.length && (o && o.buffer ? o.buffer.splice(0, 1 + a.suffix.length) : (t.splice(0, 1 + a.suffix.length), o = {
                        refreshFromBuffer: !0,
                        buffer: n(t)
                      }));
                    }
                    if (a.enforceDigitsOnBlur) {
                      var v = (o = o || {}) && o.buffer || t.slice().reverse();
                      o.refreshFromBuffer = !0, o.buffer = c(v, a.digits, a, !0).reverse();
                    }
                }
                return o;
              },
              onKeyDown: function onKeyDown(e, t, i, a) {
                var r,
                  o,
                  l = s(this),
                  u = String.fromCharCode(e.keyCode).toLowerCase();
                if ((o = a.shortcuts && a.shortcuts[u]) && o.length > 1) return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(o)), l.trigger("setvalue"), !1;
                if (e.ctrlKey) switch (e.keyCode) {
                  case n.default.UP:
                    return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(a.step)), l.trigger("setvalue"), !1;
                  case n.default.DOWN:
                    return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(a.step)), l.trigger("setvalue"), !1;
                }
                if (!e.shiftKey && (e.keyCode === n.default.DELETE || e.keyCode === n.default.BACKSPACE || e.keyCode === n.default.BACKSPACE_SAFARI) && i.begin !== t.length) {
                  if (t[e.keyCode === n.default.DELETE ? i.begin - 1 : i.end] === a.negationSymbol.front) return r = t.slice().reverse(), "" !== a.negationSymbol.front && r.shift(), "" !== a.negationSymbol.back && r.pop(), l.trigger("setvalue", [r.join(""), i.begin]), !1;
                  if (!0 === a._radixDance) {
                    var f = t.indexOf(a.radixPoint);
                    if (a.digitsOptional) {
                      if (0 === f) return (r = t.slice().reverse()).pop(), l.trigger("setvalue", [r.join(""), i.begin >= r.length ? r.length : i.begin]), !1;
                    } else if (-1 !== f && (i.begin < f || i.end < f || e.keyCode === n.default.DELETE && i.begin === f)) return i.begin !== i.end || e.keyCode !== n.default.BACKSPACE && e.keyCode !== n.default.BACKSPACE_SAFARI || i.begin++, (r = t.slice().reverse()).splice(r.length - i.begin, i.begin - i.end + 1), r = c(r, a.digits, a).join(""), l.trigger("setvalue", [r, i.begin >= r.length ? f + 1 : i.begin]), !1;
                  }
                }
              }
            },
            currency: {
              prefix: "",
              groupSeparator: ",",
              alias: "numeric",
              digits: 2,
              digitsOptional: !1
            },
            decimal: {
              alias: "numeric"
            },
            integer: {
              alias: "numeric",
              inputmode: "numeric",
              digits: 0
            },
            percentage: {
              alias: "numeric",
              min: 0,
              max: 100,
              suffix: " %",
              digits: 0,
              allowMinus: !1
            },
            indianns: {
              alias: "numeric",
              _mask: function _mask(e) {
                return "(" + e.groupSeparator + "99){*|1}(" + e.groupSeparator + "999){1|1}";
              },
              groupSeparator: ",",
              radixPoint: ".",
              placeholder: "0",
              digits: 2,
              digitsOptional: !1
            }
          });
        },
        9380: function _(e, t, i) {
          var a;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = void 0;
          var n = ((a = i(8741)) && a.__esModule ? a : {
            default: a
          }).default ? window : {};
          t.default = n;
        },
        7760: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.HandleNativePlaceholder = function (e, t) {
            var i = e ? e.inputmask : this;
            if (s.ie) {
              if (e.inputmask._valueGet() !== t && (e.placeholder !== t || "" === e.placeholder)) {
                var a = o.getBuffer.call(i).slice(),
                  n = e.inputmask._valueGet();
                if (n !== t) {
                  var r = o.getLastValidPosition.call(i);
                  -1 === r && n === o.getBufferTemplate.call(i).join("") ? a = [] : -1 !== r && f.call(i, a), p(e, a);
                }
              }
            } else e.placeholder !== t && (e.placeholder = t, "" === e.placeholder && e.removeAttribute("placeholder"));
          }, t.applyInputValue = c, t.checkVal = d, t.clearOptionalTail = f, t.unmaskedvalue = function (e) {
            var t = e ? e.inputmask : this,
              i = t.opts,
              a = t.maskset;
            if (e) {
              if (void 0 === e.inputmask) return e.value;
              e.inputmask && e.inputmask.refreshValue && c(e, e.inputmask._valueGet(!0));
            }
            var n = [],
              r = a.validPositions;
            for (var l in r) {
              r[l] && r[l].match && (1 != r[l].match.static || Array.isArray(a.metadata) && !0 !== r[l].generatedInput) && n.push(r[l].input);
            }
            var s = 0 === n.length ? "" : (t.isRTL ? n.reverse() : n).join("");
            if ("function" == typeof i.onUnMask) {
              var u = (t.isRTL ? o.getBuffer.call(t).slice().reverse() : o.getBuffer.call(t)).join("");
              s = i.onUnMask.call(t, u, s, i);
            }
            return s;
          }, t.writeBuffer = p;
          var a,
            n = (a = i(5581)) && a.__esModule ? a : {
              default: a
            },
            r = i(4713),
            o = i(8711),
            l = i(7215),
            s = i(9845),
            u = i(6030);
          function c(e, t) {
            var i = e ? e.inputmask : this,
              a = i.opts;
            e.inputmask.refreshValue = !1, "function" == typeof a.onBeforeMask && (t = a.onBeforeMask.call(i, t, a) || t), d(e, !0, !1, t = t.toString().split("")), i.undoValue = i._valueGet(!0), (a.clearMaskOnLostFocus || a.clearIncomplete) && e.inputmask._valueGet() === o.getBufferTemplate.call(i).join("") && -1 === o.getLastValidPosition.call(i) && e.inputmask._valueSet("");
          }
          function f(e) {
            e.length = 0;
            for (var t, i = r.getMaskTemplate.call(this, !0, 0, !0, void 0, !0); void 0 !== (t = i.shift());) {
              e.push(t);
            }
            return e;
          }
          function d(e, t, i, a, n) {
            var s = e ? e.inputmask : this,
              c = s.maskset,
              f = s.opts,
              d = s.dependencyLib,
              h = a.slice(),
              v = "",
              m = -1,
              g = void 0,
              k = f.skipOptionalPartCharacter;
            f.skipOptionalPartCharacter = "", o.resetMaskSet.call(s), c.tests = {}, m = f.radixPoint ? o.determineNewCaretPosition.call(s, {
              begin: 0,
              end: 0
            }, !1, !1 === f.__financeInput ? "radixFocus" : void 0).begin : 0, c.p = m, s.caretPos = {
              begin: m
            };
            var y = [],
              b = s.caretPos;
            if (h.forEach(function (e, t) {
              if (void 0 !== e) {
                var a = new d.Event("_checkval");
                a.keyCode = e.toString().charCodeAt(0), v += e;
                var n = o.getLastValidPosition.call(s, void 0, !0);
                !function (e, t) {
                  for (var i = r.getMaskTemplate.call(s, !0, 0).slice(e, o.seekNext.call(s, e, !1, !1)).join("").replace(/'/g, ""), a = i.indexOf(t); a > 0 && " " === i[a - 1];) {
                    a--;
                  }
                  var n = 0 === a && !o.isMask.call(s, e) && (r.getTest.call(s, e).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(s, e).match.static && r.getTest.call(s, e).match.nativeDef === "'" + t.charAt(0) || " " === r.getTest.call(s, e).match.nativeDef && (r.getTest.call(s, e + 1).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(s, e + 1).match.static && r.getTest.call(s, e + 1).match.nativeDef === "'" + t.charAt(0)));
                  if (!n && a > 0 && !o.isMask.call(s, e, !1, !0)) {
                    var l = o.seekNext.call(s, e);
                    s.caretPos.begin < l && (s.caretPos = {
                      begin: l
                    });
                  }
                  return n;
                }(m, v) ? (g = u.EventHandlers.keypressEvent.call(s, a, !0, !1, i, s.caretPos.begin)) && (m = s.caretPos.begin + 1, v = "") : g = u.EventHandlers.keypressEvent.call(s, a, !0, !1, i, n + 1), g ? (void 0 !== g.pos && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static && void 0 === c.validPositions[g.pos].alternation && (y.push(g.pos), s.isRTL || (g.forwardPosition = g.pos + 1)), p.call(s, void 0, o.getBuffer.call(s), g.forwardPosition, a, !1), s.caretPos = {
                  begin: g.forwardPosition,
                  end: g.forwardPosition
                }, b = s.caretPos) : void 0 === c.validPositions[t] && h[t] === r.getPlaceholder.call(s, t) && o.isMask.call(s, t, !0) ? s.caretPos.begin++ : s.caretPos = b;
              }
            }), y.length > 0) {
              var x,
                P,
                E = o.seekNext.call(s, -1, void 0, !1);
              if (!l.isComplete.call(s, o.getBuffer.call(s)) && y.length <= E || l.isComplete.call(s, o.getBuffer.call(s)) && y.length > 0 && y.length !== E && 0 === y[0]) for (var S = E; void 0 !== (x = y.shift());) {
                var _ = new d.Event("_checkval");
                if ((P = c.validPositions[x]).generatedInput = !0, _.keyCode = P.input.charCodeAt(0), (g = u.EventHandlers.keypressEvent.call(s, _, !0, !1, i, S)) && void 0 !== g.pos && g.pos !== x && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static) y.push(g.pos);else if (!g) break;
                S++;
              }
            }
            t && p.call(s, e, o.getBuffer.call(s), g ? g.forwardPosition : s.caretPos.begin, n || new d.Event("checkval"), n && ("input" === n.type && s.undoValue !== o.getBuffer.call(s).join("") || "paste" === n.type)), f.skipOptionalPartCharacter = k;
          }
          function p(e, t, i, a, r) {
            var s = e ? e.inputmask : this,
              u = s.opts,
              c = s.dependencyLib;
            if (a && "function" == typeof u.onBeforeWrite) {
              var f = u.onBeforeWrite.call(s, a, t, i, u);
              if (f) {
                if (f.refreshFromBuffer) {
                  var d = f.refreshFromBuffer;
                  l.refreshFromBuffer.call(s, !0 === d ? d : d.start, d.end, f.buffer || t), t = o.getBuffer.call(s, !0);
                }
                void 0 !== i && (i = void 0 !== f.caret ? f.caret : i);
              }
            }
            if (void 0 !== e && (e.inputmask._valueSet(t.join("")), void 0 === i || void 0 !== a && "blur" === a.type || o.caret.call(s, e, i, void 0, void 0, void 0 !== a && "keydown" === a.type && (a.keyCode === n.default.DELETE || a.keyCode === n.default.BACKSPACE)), !0 === r)) {
              var p = c(e),
                h = e.inputmask._valueGet();
              e.inputmask.skipInputEvent = !0, p.trigger("input"), setTimeout(function () {
                h === o.getBufferTemplate.call(s).join("") ? p.trigger("cleared") : !0 === l.isComplete.call(s, t) && p.trigger("complete");
              }, 0);
            }
          }
        },
        2394: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = void 0, i(7149), i(3194);
          var a = i(157),
            n = m(i(4963)),
            r = m(i(9380)),
            o = i(2391),
            l = i(4713),
            s = i(8711),
            u = i(7215),
            c = i(7760),
            f = i(9716),
            d = m(i(7392)),
            p = m(i(3976)),
            h = m(i(8741));
          function v(e) {
            return v = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
              return _typeof(e);
            } : function (e) {
              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
            }, v(e);
          }
          function m(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          var g = r.default.document,
            k = "_inputmask_opts";
          function y(e, t, i) {
            if (h.default) {
              if (!(this instanceof y)) return new y(e, t, i);
              this.dependencyLib = n.default, this.el = void 0, this.events = {}, this.maskset = void 0, !0 !== i && ("[object Object]" === Object.prototype.toString.call(e) ? t = e : (t = t || {}, e && (t.alias = e)), this.opts = n.default.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions, this.userOptions = t || {}, b(this.opts.alias, t, this.opts)), this.refreshValue = !1, this.undoValue = void 0, this.$el = void 0, this.skipKeyPressEvent = !1, this.skipInputEvent = !1, this.validationEvent = !1, this.ignorable = !1, this.maxLength, this.mouseEnter = !1, this.originalPlaceholder = void 0, this.isComposing = !1;
            }
          }
          function b(e, t, i) {
            var a = y.prototype.aliases[e];
            return a ? (a.alias && b(a.alias, void 0, i), n.default.extend(!0, i, a), n.default.extend(!0, i, t), !0) : (null === i.mask && (i.mask = e), !1);
          }
          y.prototype = {
            dataAttribute: "data-inputmask",
            defaults: p.default,
            definitions: d.default,
            aliases: {},
            masksCache: {},
            get isRTL() {
              return this.opts.isRTL || this.opts.numericInput;
            },
            mask: function mask(e) {
              var t = this;
              return "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [e] : Array.isArray(e) ? e : Array.from(e)).forEach(function (e, i) {
                var l = n.default.extend(!0, {}, t.opts);
                if (function (e, t, i, a) {
                  function o(t, n) {
                    var o = "" === a ? t : a + "-" + t;
                    null !== (n = void 0 !== n ? n : e.getAttribute(o)) && ("string" == typeof n && (0 === t.indexOf("on") ? n = r.default[n] : "false" === n ? n = !1 : "true" === n && (n = !0)), i[t] = n);
                  }
                  if (!0 === t.importDataAttributes) {
                    var l,
                      s,
                      u,
                      c,
                      f = e.getAttribute(a);
                    if (f && "" !== f && (f = f.replace(/'/g, '"'), s = JSON.parse("{" + f + "}")), s) for (c in u = void 0, s) {
                      if ("alias" === c.toLowerCase()) {
                        u = s[c];
                        break;
                      }
                    }
                    for (l in o("alias", u), i.alias && b(i.alias, i, t), t) {
                      if (s) for (c in u = void 0, s) {
                        if (c.toLowerCase() === l.toLowerCase()) {
                          u = s[c];
                          break;
                        }
                      }
                      o(l, u);
                    }
                  }
                  n.default.extend(!0, t, i), ("rtl" === e.dir || t.rightAlign) && (e.style.textAlign = "right");
                  ("rtl" === e.dir || t.numericInput) && (e.dir = "ltr", e.removeAttribute("dir"), t.isRTL = !0);
                  return Object.keys(i).length;
                }(e, l, n.default.extend(!0, {}, t.userOptions), t.dataAttribute)) {
                  var s = (0, o.generateMaskSet)(l, t.noMasksCache);
                  void 0 !== s && (void 0 !== e.inputmask && (e.inputmask.opts.autoUnmask = !0, e.inputmask.remove()), e.inputmask = new y(void 0, void 0, !0), e.inputmask.opts = l, e.inputmask.noMasksCache = t.noMasksCache, e.inputmask.userOptions = n.default.extend(!0, {}, t.userOptions), e.inputmask.el = e, e.inputmask.$el = (0, n.default)(e), e.inputmask.maskset = s, n.default.data(e, k, t.userOptions), a.mask.call(e.inputmask));
                }
              }), e && e[0] && e[0].inputmask || this;
            },
            option: function option(e, t) {
              return "string" == typeof e ? this.opts[e] : "object" === v(e) ? (n.default.extend(this.userOptions, e), this.el && !0 !== t && this.mask(this.el), this) : void 0;
            },
            unmaskedvalue: function unmaskedvalue(e) {
              if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), void 0 === this.el || void 0 !== e) {
                var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                c.checkVal.call(this, void 0, !1, !1, t), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, s.getBuffer.call(this), 0, this.opts);
              }
              return c.unmaskedvalue.call(this, this.el);
            },
            remove: function remove() {
              if (this.el) {
                n.default.data(this.el, k, null);
                var e = this.opts.autoUnmask ? (0, c.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                e !== s.getBufferTemplate.call(this).join("") ? this._valueSet(e, this.opts.autoUnmask) : this._valueSet(""), f.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                  get: this.__valueGet,
                  set: this.__valueSet,
                  configurable: !0
                }) : g.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
              }
              return this.el;
            },
            getemptymask: function getemptymask() {
              return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), s.getBufferTemplate.call(this).join("");
            },
            hasMaskedValue: function hasMaskedValue() {
              return !this.opts.autoUnmask;
            },
            isComplete: function isComplete() {
              return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), u.isComplete.call(this, s.getBuffer.call(this));
            },
            getmetadata: function getmetadata() {
              if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), Array.isArray(this.maskset.metadata)) {
                var e = l.getMaskTemplate.call(this, !0, 0, !1).join("");
                return this.maskset.metadata.forEach(function (t) {
                  return t.mask !== e || (e = t, !1);
                }), e;
              }
              return this.maskset.metadata;
            },
            isValid: function isValid(e) {
              if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), e) {
                var t = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
                c.checkVal.call(this, void 0, !0, !1, t);
              } else e = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
              for (var i = s.getBuffer.call(this), a = s.determineLastRequiredPosition.call(this), n = i.length - 1; n > a && !s.isMask.call(this, n); n--) {
                ;
              }
              return i.splice(a, n + 1 - a), u.isComplete.call(this, i) && e === (this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join(""));
            },
            format: function format(e, t) {
              this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache);
              var i = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split("");
              c.checkVal.call(this, void 0, !0, !1, i);
              var a = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
              return t ? {
                value: a,
                metadata: this.getmetadata()
              } : a;
            },
            setValue: function setValue(e) {
              this.el && (0, n.default)(this.el).trigger("setvalue", [e]);
            },
            analyseMask: o.analyseMask
          }, y.extendDefaults = function (e) {
            n.default.extend(!0, y.prototype.defaults, e);
          }, y.extendDefinitions = function (e) {
            n.default.extend(!0, y.prototype.definitions, e);
          }, y.extendAliases = function (e) {
            n.default.extend(!0, y.prototype.aliases, e);
          }, y.format = function (e, t, i) {
            return y(t).format(e, i);
          }, y.unmask = function (e, t) {
            return y(t).unmaskedvalue(e);
          }, y.isValid = function (e, t) {
            return y(t).isValid(e);
          }, y.remove = function (e) {
            "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [e] : e).forEach(function (e) {
              e.inputmask && e.inputmask.remove();
            });
          }, y.setValue = function (e, t) {
            "string" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [e] : e).forEach(function (e) {
              e.inputmask ? e.inputmask.setValue(t) : (0, n.default)(e).trigger("setvalue", [t]);
            });
          }, y.dependencyLib = n.default, r.default.Inputmask = y;
          var x = y;
          t.default = x;
        },
        5296: function _(e, t, i) {
          function a(e) {
            return a = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
              return _typeof(e);
            } : function (e) {
              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
            }, a(e);
          }
          var n = h(i(9380)),
            r = h(i(2394)),
            o = h(i(8741));
          function l(e, t) {
            for (var i = 0; i < t.length; i++) {
              var a = t[i];
              a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a);
            }
          }
          function s(e, t) {
            if (t && ("object" === a(t) || "function" == typeof t)) return t;
            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
            return function (e) {
              if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e;
            }(e);
          }
          function u(e) {
            var t = "function" == typeof Map ? new Map() : void 0;
            return u = function u(e) {
              if (null === e || (i = e, -1 === Function.toString.call(i).indexOf("[native code]"))) return e;
              var i;
              if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
              if (void 0 !== t) {
                if (t.has(e)) return t.get(e);
                t.set(e, a);
              }
              function a() {
                return c(e, arguments, p(this).constructor);
              }
              return a.prototype = Object.create(e.prototype, {
                constructor: {
                  value: a,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0
                }
              }), d(a, e);
            }, u(e);
          }
          function c(e, t, i) {
            return c = f() ? Reflect.construct : function (e, t, i) {
              var a = [null];
              a.push.apply(a, t);
              var n = new (Function.bind.apply(e, a))();
              return i && d(n, i.prototype), n;
            }, c.apply(null, arguments);
          }
          function f() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
            } catch (e) {
              return !1;
            }
          }
          function d(e, t) {
            return d = Object.setPrototypeOf || function (e, t) {
              return e.__proto__ = t, e;
            }, d(e, t);
          }
          function p(e) {
            return p = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
              return e.__proto__ || Object.getPrototypeOf(e);
            }, p(e);
          }
          function h(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
          var v = n.default.document;
          if (o.default && v && v.head && v.head.attachShadow && n.default.customElements && void 0 === n.default.customElements.get("input-mask")) {
            var m = function (e) {
              !function (e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                Object.defineProperty(e, "prototype", {
                  value: Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      writable: !0,
                      configurable: !0
                    }
                  }),
                  writable: !1
                }), t && d(e, t);
              }(c, e);
              var t,
                i,
                a,
                n,
                o,
                u = (t = c, i = f(), function () {
                  var e,
                    a = p(t);
                  if (i) {
                    var n = p(this).constructor;
                    e = Reflect.construct(a, arguments, n);
                  } else e = a.apply(this, arguments);
                  return s(this, e);
                });
              function c() {
                var e;
                !function (e, t) {
                  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                }(this, c);
                var t = (e = u.call(this)).getAttributeNames(),
                  i = e.attachShadow({
                    mode: "closed"
                  }),
                  a = v.createElement("input");
                for (var n in a.type = "text", i.appendChild(a), t) {
                  Object.prototype.hasOwnProperty.call(t, n) && a.setAttribute(t[n], e.getAttribute(t[n]));
                }
                var o = new r.default();
                return o.dataAttribute = "", o.mask(a), a.inputmask.shadowRoot = i, e;
              }
              return a = c, n && l(a.prototype, n), o && l(a, o), Object.defineProperty(a, "prototype", {
                writable: !1
              }), a;
            }(u(HTMLElement));
            n.default.customElements.define("input-mask", m);
          }
        },
        2391: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.analyseMask = function (e, t, i) {
            var a,
              o,
              l,
              s,
              u,
              c,
              f = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g,
              d = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
              p = !1,
              h = new n.default(),
              v = [],
              m = [],
              g = !1;
            function k(e, a, n) {
              n = void 0 !== n ? n : e.matches.length;
              var o = e.matches[n - 1];
              if (t) 0 === a.indexOf("[") || p && /\\d|\\s|\\w/i.test(a) || "." === a ? e.matches.splice(n++, 0, {
                fn: new RegExp(a, i.casing ? "i" : ""),
                static: !1,
                optionality: !1,
                newBlockMarker: void 0 === o ? "master" : o.def !== a,
                casing: null,
                def: a,
                placeholder: void 0,
                nativeDef: a
              }) : (p && (a = a[a.length - 1]), a.split("").forEach(function (t, a) {
                o = e.matches[n - 1], e.matches.splice(n++, 0, {
                  fn: /[a-z]/i.test(i.staticDefinitionSymbol || t) ? new RegExp("[" + (i.staticDefinitionSymbol || t) + "]", i.casing ? "i" : "") : null,
                  static: !0,
                  optionality: !1,
                  newBlockMarker: void 0 === o ? "master" : o.def !== t && !0 !== o.static,
                  casing: null,
                  def: i.staticDefinitionSymbol || t,
                  placeholder: void 0 !== i.staticDefinitionSymbol ? t : void 0,
                  nativeDef: (p ? "'" : "") + t
                });
              })), p = !1;else {
                var l = i.definitions && i.definitions[a] || i.usePrototypeDefinitions && r.default.prototype.definitions[a];
                l && !p ? e.matches.splice(n++, 0, {
                  fn: l.validator ? "string" == typeof l.validator ? new RegExp(l.validator, i.casing ? "i" : "") : new function () {
                    this.test = l.validator;
                  }() : new RegExp("."),
                  static: l.static || !1,
                  optionality: l.optional || !1,
                  newBlockMarker: void 0 === o || l.optional ? "master" : o.def !== (l.definitionSymbol || a),
                  casing: l.casing,
                  def: l.definitionSymbol || a,
                  placeholder: l.placeholder,
                  nativeDef: a,
                  generated: l.generated
                }) : (e.matches.splice(n++, 0, {
                  fn: /[a-z]/i.test(i.staticDefinitionSymbol || a) ? new RegExp("[" + (i.staticDefinitionSymbol || a) + "]", i.casing ? "i" : "") : null,
                  static: !0,
                  optionality: !1,
                  newBlockMarker: void 0 === o ? "master" : o.def !== a && !0 !== o.static,
                  casing: null,
                  def: i.staticDefinitionSymbol || a,
                  placeholder: void 0 !== i.staticDefinitionSymbol ? a : void 0,
                  nativeDef: (p ? "'" : "") + a
                }), p = !1);
              }
            }
            function y() {
              if (v.length > 0) {
                if (k(s = v[v.length - 1], o), s.isAlternator) {
                  u = v.pop();
                  for (var e = 0; e < u.matches.length; e++) {
                    u.matches[e].isGroup && (u.matches[e].isGroup = !1);
                  }
                  v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                }
              } else k(h, o);
            }
            function b(e) {
              var t = new n.default(!0);
              return t.openGroup = !1, t.matches = e, t;
            }
            function x() {
              if ((l = v.pop()).openGroup = !1, void 0 !== l) {
                if (v.length > 0) {
                  if ((s = v[v.length - 1]).matches.push(l), s.isAlternator) {
                    for (var e = (u = v.pop()).matches[0].matches ? u.matches[0].matches.length : 1, t = 0; t < u.matches.length; t++) {
                      u.matches[t].isGroup = !1, u.matches[t].alternatorGroup = !1, null === i.keepStatic && e < (u.matches[t].matches ? u.matches[t].matches.length : 1) && (i.keepStatic = !0), e = u.matches[t].matches ? u.matches[t].matches.length : 1;
                    }
                    v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                  }
                } else h.matches.push(l);
              } else y();
            }
            function P(e) {
              var t = e.pop();
              return t.isQuantifier && (t = b([e.pop(), t])), t;
            }
            t && (i.optionalmarker[0] = void 0, i.optionalmarker[1] = void 0);
            for (; a = t ? d.exec(e) : f.exec(e);) {
              if (o = a[0], t) {
                switch (o.charAt(0)) {
                  case "?":
                    o = "{0,1}";
                    break;
                  case "+":
                  case "*":
                    o = "{" + o + "}";
                    break;
                  case "|":
                    if (0 === v.length) {
                      var E = b(h.matches);
                      E.openGroup = !0, v.push(E), h.matches = [], g = !0;
                    }
                }
                if ("\\d" === o) o = "[0-9]";
              }
              if (p) y();else switch (o.charAt(0)) {
                case "$":
                case "^":
                  t || y();
                  break;
                case i.escapeChar:
                  p = !0, t && y();
                  break;
                case i.optionalmarker[1]:
                case i.groupmarker[1]:
                  x();
                  break;
                case i.optionalmarker[0]:
                  v.push(new n.default(!1, !0));
                  break;
                case i.groupmarker[0]:
                  v.push(new n.default(!0));
                  break;
                case i.quantifiermarker[0]:
                  var S = new n.default(!1, !1, !0),
                    _ = (o = o.replace(/[{}?]/g, "")).split("|"),
                    w = _[0].split(","),
                    M = isNaN(w[0]) ? w[0] : parseInt(w[0]),
                    O = 1 === w.length ? M : isNaN(w[1]) ? w[1] : parseInt(w[1]),
                    T = isNaN(_[1]) ? _[1] : parseInt(_[1]);
                  "*" !== M && "+" !== M || (M = "*" === O ? 0 : 1), S.quantifier = {
                    min: M,
                    max: O,
                    jit: T
                  };
                  var C = v.length > 0 ? v[v.length - 1].matches : h.matches;
                  if ((a = C.pop()).isAlternator) {
                    C.push(a), C = a.matches;
                    var A = new n.default(!0),
                      D = C.pop();
                    C.push(A), C = A.matches, a = D;
                  }
                  a.isGroup || (a = b([a])), C.push(a), C.push(S);
                  break;
                case i.alternatormarker:
                  if (v.length > 0) {
                    var j = (s = v[v.length - 1]).matches[s.matches.length - 1];
                    c = s.openGroup && (void 0 === j.matches || !1 === j.isGroup && !1 === j.isAlternator) ? v.pop() : P(s.matches);
                  } else c = P(h.matches);
                  if (c.isAlternator) v.push(c);else if (c.alternatorGroup ? (u = v.pop(), c.alternatorGroup = !1) : u = new n.default(!1, !1, !1, !0), u.matches.push(c), v.push(u), c.openGroup) {
                    c.openGroup = !1;
                    var B = new n.default(!0);
                    B.alternatorGroup = !0, v.push(B);
                  }
                  break;
                default:
                  y();
              }
            }
            g && x();
            for (; v.length > 0;) {
              l = v.pop(), h.matches.push(l);
            }
            h.matches.length > 0 && (!function e(a) {
              a && a.matches && a.matches.forEach(function (n, r) {
                var o = a.matches[r + 1];
                (void 0 === o || void 0 === o.matches || !1 === o.isQuantifier) && n && n.isGroup && (n.isGroup = !1, t || (k(n, i.groupmarker[0], 0), !0 !== n.openGroup && k(n, i.groupmarker[1]))), e(n);
              });
            }(h), m.push(h));
            (i.numericInput || i.isRTL) && function e(t) {
              for (var a in t.matches = t.matches.reverse(), t.matches) {
                if (Object.prototype.hasOwnProperty.call(t.matches, a)) {
                  var n = parseInt(a);
                  if (t.matches[a].isQuantifier && t.matches[n + 1] && t.matches[n + 1].isGroup) {
                    var r = t.matches[a];
                    t.matches.splice(a, 1), t.matches.splice(n + 1, 0, r);
                  }
                  void 0 !== t.matches[a].matches ? t.matches[a] = e(t.matches[a]) : t.matches[a] = ((o = t.matches[a]) === i.optionalmarker[0] ? o = i.optionalmarker[1] : o === i.optionalmarker[1] ? o = i.optionalmarker[0] : o === i.groupmarker[0] ? o = i.groupmarker[1] : o === i.groupmarker[1] && (o = i.groupmarker[0]), o);
                }
              }
              var o;
              return t;
            }(m[0]);
            return m;
          }, t.generateMaskSet = function (e, t) {
            var i;
            function n(e, i, n) {
              var o,
                l,
                s = !1;
              if (null !== e && "" !== e || ((s = null !== n.regex) ? e = (e = n.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (s = !0, e = ".*")), 1 === e.length && !1 === n.greedy && 0 !== n.repeat && (n.placeholder = ""), n.repeat > 0 || "*" === n.repeat || "+" === n.repeat) {
                var u = "*" === n.repeat ? 0 : "+" === n.repeat ? 1 : n.repeat;
                e = n.groupmarker[0] + e + n.groupmarker[1] + n.quantifiermarker[0] + u + "," + n.repeat + n.quantifiermarker[1];
              }
              return l = s ? "regex_" + n.regex : n.numericInput ? e.split("").reverse().join("") : e, null !== n.keepStatic && (l = "ks_" + n.keepStatic + l), void 0 === r.default.prototype.masksCache[l] || !0 === t ? (o = {
                mask: e,
                maskToken: r.default.prototype.analyseMask(e, s, n),
                validPositions: {},
                _buffer: void 0,
                buffer: void 0,
                tests: {},
                excludes: {},
                metadata: i,
                maskLength: void 0,
                jitOffset: {}
              }, !0 !== t && (r.default.prototype.masksCache[l] = o, o = a.default.extend(!0, {}, r.default.prototype.masksCache[l]))) : o = a.default.extend(!0, {}, r.default.prototype.masksCache[l]), o;
            }
            "function" == typeof e.mask && (e.mask = e.mask(e));
            if (Array.isArray(e.mask)) {
              if (e.mask.length > 1) {
                null === e.keepStatic && (e.keepStatic = !0);
                var o = e.groupmarker[0];
                return (e.isRTL ? e.mask.reverse() : e.mask).forEach(function (t) {
                  o.length > 1 && (o += e.alternatormarker), void 0 !== t.mask && "function" != typeof t.mask ? o += t.mask : o += t;
                }), n(o += e.groupmarker[1], e.mask, e);
              }
              e.mask = e.mask.pop();
            }
            i = e.mask && void 0 !== e.mask.mask && "function" != typeof e.mask.mask ? n(e.mask.mask, e.mask, e) : n(e.mask, e.mask, e);
            null === e.keepStatic && (e.keepStatic = !1);
            return i;
          };
          var a = o(i(4963)),
            n = o(i(9695)),
            r = o(i(2394));
          function o(e) {
            return e && e.__esModule ? e : {
              default: e
            };
          }
        },
        157: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.mask = function () {
            var e = this,
              t = this.opts,
              i = this.el,
              a = this.dependencyLib;
            l.EventRuler.off(i);
            var f = function (t, i) {
              "textarea" !== t.tagName.toLowerCase() && i.ignorables.push(n.default.ENTER);
              var s = t.getAttribute("type"),
                u = "input" === t.tagName.toLowerCase() && i.supportsInputType.includes(s) || t.isContentEditable || "textarea" === t.tagName.toLowerCase();
              if (!u) if ("input" === t.tagName.toLowerCase()) {
                var c = document.createElement("input");
                c.setAttribute("type", s), u = "text" === c.type, c = null;
              } else u = "partial";
              return !1 !== u ? function (t) {
                var n, s;
                function u() {
                  return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== r.getLastValidPosition.call(e) || !0 !== i.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && i.clearMaskOnLostFocus ? (e.isRTL ? o.clearOptionalTail.call(e, r.getBuffer.call(e).slice()).reverse() : o.clearOptionalTail.call(e, r.getBuffer.call(e).slice())).join("") : n.call(this) : "" : n.call(this);
                }
                function c(e) {
                  s.call(this, e), this.inputmask && (0, o.applyInputValue)(this, e);
                }
                if (!t.inputmask.__valueGet) {
                  if (!0 !== i.noValuePatching) {
                    if (Object.getOwnPropertyDescriptor) {
                      var f = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t), "value") : void 0;
                      f && f.get && f.set ? (n = f.get, s = f.set, Object.defineProperty(t, "value", {
                        get: u,
                        set: c,
                        configurable: !0
                      })) : "input" !== t.tagName.toLowerCase() && (n = function n() {
                        return this.textContent;
                      }, s = function s(e) {
                        this.textContent = e;
                      }, Object.defineProperty(t, "value", {
                        get: u,
                        set: c,
                        configurable: !0
                      }));
                    } else document.__lookupGetter__ && t.__lookupGetter__("value") && (n = t.__lookupGetter__("value"), s = t.__lookupSetter__("value"), t.__defineGetter__("value", u), t.__defineSetter__("value", c));
                    t.inputmask.__valueGet = n, t.inputmask.__valueSet = s;
                  }
                  t.inputmask._valueGet = function (t) {
                    return e.isRTL && !0 !== t ? n.call(this.el).split("").reverse().join("") : n.call(this.el);
                  }, t.inputmask._valueSet = function (t, i) {
                    s.call(this.el, null == t ? "" : !0 !== i && e.isRTL ? t.split("").reverse().join("") : t);
                  }, void 0 === n && (n = function n() {
                    return this.value;
                  }, s = function s(e) {
                    this.value = e;
                  }, function (t) {
                    if (a.valHooks && (void 0 === a.valHooks[t] || !0 !== a.valHooks[t].inputmaskpatch)) {
                      var n = a.valHooks[t] && a.valHooks[t].get ? a.valHooks[t].get : function (e) {
                          return e.value;
                        },
                        l = a.valHooks[t] && a.valHooks[t].set ? a.valHooks[t].set : function (e, t) {
                          return e.value = t, e;
                        };
                      a.valHooks[t] = {
                        get: function get(t) {
                          if (t.inputmask) {
                            if (t.inputmask.opts.autoUnmask) return t.inputmask.unmaskedvalue();
                            var a = n(t);
                            return -1 !== r.getLastValidPosition.call(e, void 0, void 0, t.inputmask.maskset.validPositions) || !0 !== i.nullable ? a : "";
                          }
                          return n(t);
                        },
                        set: function set(e, t) {
                          var i = l(e, t);
                          return e.inputmask && (0, o.applyInputValue)(e, t), i;
                        },
                        inputmaskpatch: !0
                      };
                    }
                  }(t.type), function (t) {
                    l.EventRuler.on(t, "mouseenter", function () {
                      var t = this.inputmask._valueGet(!0);
                      t !== (e.isRTL ? r.getBuffer.call(e).reverse() : r.getBuffer.call(e)).join("") && (0, o.applyInputValue)(this, t);
                    });
                  }(t));
                }
              }(t) : t.inputmask = void 0, u;
            }(i, t);
            if (!1 !== f) {
              e.originalPlaceholder = i.placeholder, e.maxLength = void 0 !== i ? i.maxLength : void 0, -1 === e.maxLength && (e.maxLength = void 0), "inputMode" in i && null === i.getAttribute("inputmode") && (i.inputMode = t.inputmode, i.setAttribute("inputmode", t.inputmode)), !0 === f && (t.showMaskOnFocus = t.showMaskOnFocus && -1 === ["cc-number", "cc-exp"].indexOf(i.autocomplete), s.iphone && (t.insertModeVisual = !1), l.EventRuler.on(i, "submit", c.EventHandlers.submitEvent), l.EventRuler.on(i, "reset", c.EventHandlers.resetEvent), l.EventRuler.on(i, "blur", c.EventHandlers.blurEvent), l.EventRuler.on(i, "focus", c.EventHandlers.focusEvent), l.EventRuler.on(i, "invalid", c.EventHandlers.invalidEvent), l.EventRuler.on(i, "click", c.EventHandlers.clickEvent), l.EventRuler.on(i, "mouseleave", c.EventHandlers.mouseleaveEvent), l.EventRuler.on(i, "mouseenter", c.EventHandlers.mouseenterEvent), l.EventRuler.on(i, "paste", c.EventHandlers.pasteEvent), l.EventRuler.on(i, "cut", c.EventHandlers.cutEvent), l.EventRuler.on(i, "complete", t.oncomplete), l.EventRuler.on(i, "incomplete", t.onincomplete), l.EventRuler.on(i, "cleared", t.oncleared), !0 !== t.inputEventOnly && (l.EventRuler.on(i, "keydown", c.EventHandlers.keydownEvent), l.EventRuler.on(i, "keypress", c.EventHandlers.keypressEvent), l.EventRuler.on(i, "keyup", c.EventHandlers.keyupEvent)), (s.mobile || t.inputEventOnly) && i.removeAttribute("maxLength"), l.EventRuler.on(i, "input", c.EventHandlers.inputFallBackEvent), l.EventRuler.on(i, "compositionend", c.EventHandlers.compositionendEvent)), l.EventRuler.on(i, "setvalue", c.EventHandlers.setValueEvent), r.getBufferTemplate.call(e).join(""), e.undoValue = e._valueGet(!0);
              var d = (i.inputmask.shadowRoot || i.ownerDocument).activeElement;
              if ("" !== i.inputmask._valueGet(!0) || !1 === t.clearMaskOnLostFocus || d === i) {
                (0, o.applyInputValue)(i, i.inputmask._valueGet(!0), t);
                var p = r.getBuffer.call(e).slice();
                !1 === u.isComplete.call(e, p) && t.clearIncomplete && r.resetMaskSet.call(e), t.clearMaskOnLostFocus && d !== i && (-1 === r.getLastValidPosition.call(e) ? p = [] : o.clearOptionalTail.call(e, p)), (!1 === t.clearMaskOnLostFocus || t.showMaskOnFocus && d === i || "" !== i.inputmask._valueGet(!0)) && (0, o.writeBuffer)(i, p), d === i && r.caret.call(e, i, r.seekNext.call(e, r.getLastValidPosition.call(e)));
              }
            }
          };
          var a,
            n = (a = i(5581)) && a.__esModule ? a : {
              default: a
            },
            r = i(8711),
            o = i(7760),
            l = i(9716),
            s = i(9845),
            u = i(7215),
            c = i(6030);
        },
        9695: function _(e, t) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.default = function (e, t, i, a) {
            this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, this.isOptional = t || !1, this.isQuantifier = i || !1, this.isAlternator = a || !1, this.quantifier = {
              min: 1,
              max: 1
            };
          };
        },
        3194: function _() {
          Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
            value: function value(e, t) {
              if (null == this) throw new TypeError('"this" is null or not defined');
              var i = Object(this),
                a = i.length >>> 0;
              if (0 === a) return !1;
              for (var n = 0 | t, r = Math.max(n >= 0 ? n : a - Math.abs(n), 0); r < a;) {
                if (i[r] === e) return !0;
                r++;
              }
              return !1;
            }
          });
        },
        7149: function _() {
          function e(t) {
            return e = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
              return _typeof(e);
            } : function (e) {
              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
            }, e(t);
          }
          "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e("test".__proto__) ? function (e) {
            return e.__proto__;
          } : function (e) {
            return e.constructor.prototype;
          });
        },
        8711: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.caret = function (e, t, i, a, n) {
            var r,
              o = this,
              l = this.opts;
            if (void 0 === t) return "selectionStart" in e && "selectionEnd" in e ? (t = e.selectionStart, i = e.selectionEnd) : window.getSelection ? (r = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && r.commonAncestorContainer !== e || (t = r.startOffset, i = r.endOffset) : document.selection && document.selection.createRange && (r = document.selection.createRange(), t = 0 - r.duplicate().moveStart("character", -e.inputmask._valueGet().length), i = t + r.text.length), {
              begin: a ? t : u.call(o, t),
              end: a ? i : u.call(o, i)
            };
            if (Array.isArray(t) && (i = o.isRTL ? t[0] : t[1], t = o.isRTL ? t[1] : t[0]), void 0 !== t.begin && (i = o.isRTL ? t.begin : t.end, t = o.isRTL ? t.end : t.begin), "number" == typeof t) {
              t = a ? t : u.call(o, t), i = "number" == typeof (i = a ? i : u.call(o, i)) ? i : t;
              var s = parseInt(((e.ownerDocument.defaultView || window).getComputedStyle ? (e.ownerDocument.defaultView || window).getComputedStyle(e, null) : e.currentStyle).fontSize) * i;
              if (e.scrollLeft = s > e.scrollWidth ? s : 0, e.inputmask.caretPos = {
                begin: t,
                end: i
              }, l.insertModeVisual && !1 === l.insertMode && t === i && (n || i++), e === (e.inputmask.shadowRoot || e.ownerDocument).activeElement) if ("setSelectionRange" in e) e.setSelectionRange(t, i);else if (window.getSelection) {
                if (r = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {
                  var c = document.createTextNode("");
                  e.appendChild(c);
                }
                r.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), r.setEnd(e.firstChild, i < e.inputmask._valueGet().length ? i : e.inputmask._valueGet().length), r.collapse(!0);
                var f = window.getSelection();
                f.removeAllRanges(), f.addRange(r);
              } else e.createTextRange && ((r = e.createTextRange()).collapse(!0), r.moveEnd("character", i), r.moveStart("character", t), r.select());
            }
          }, t.determineLastRequiredPosition = function (e) {
            var t,
              i,
              r = this,
              l = this.maskset,
              s = this.dependencyLib,
              u = a.getMaskTemplate.call(r, !0, o.call(r), !0, !0),
              c = u.length,
              f = o.call(r),
              d = {},
              p = l.validPositions[f],
              h = void 0 !== p ? p.locator.slice() : void 0;
            for (t = f + 1; t < u.length; t++) {
              i = a.getTestTemplate.call(r, t, h, t - 1), h = i.locator.slice(), d[t] = s.extend(!0, {}, i);
            }
            var v = p && void 0 !== p.alternation ? p.locator[p.alternation] : void 0;
            for (t = c - 1; t > f && ((i = d[t]).match.optionality || i.match.optionalQuantifier && i.match.newBlockMarker || v && (v !== d[t].locator[p.alternation] && 1 != i.match.static || !0 === i.match.static && i.locator[p.alternation] && n.checkAlternationMatch.call(r, i.locator[p.alternation].toString().split(","), v.toString().split(",")) && "" !== a.getTests.call(r, t)[0].def)) && u[t] === a.getPlaceholder.call(r, t, i.match); t--) {
              c--;
            }
            return e ? {
              l: c,
              def: d[c] ? d[c].match : void 0
            } : c;
          }, t.determineNewCaretPosition = function (e, t, i) {
            var n = this,
              u = this.maskset,
              c = this.opts;
            t && (n.isRTL ? e.end = e.begin : e.begin = e.end);
            if (e.begin === e.end) {
              switch (i = i || c.positionCaretOnClick) {
                case "none":
                  break;
                case "select":
                  e = {
                    begin: 0,
                    end: r.call(n).length
                  };
                  break;
                case "ignore":
                  e.end = e.begin = s.call(n, o.call(n));
                  break;
                case "radixFocus":
                  if (function (e) {
                    if ("" !== c.radixPoint && 0 !== c.digits) {
                      var t = u.validPositions;
                      if (void 0 === t[e] || t[e].input === a.getPlaceholder.call(n, e)) {
                        if (e < s.call(n, -1)) return !0;
                        var i = r.call(n).indexOf(c.radixPoint);
                        if (-1 !== i) {
                          for (var o in t) {
                            if (t[o] && i < o && t[o].input !== a.getPlaceholder.call(n, o)) return !1;
                          }
                          return !0;
                        }
                      }
                    }
                    return !1;
                  }(e.begin)) {
                    var f = r.call(n).join("").indexOf(c.radixPoint);
                    e.end = e.begin = c.numericInput ? s.call(n, f) : f;
                    break;
                  }
                default:
                  var d = e.begin,
                    p = o.call(n, d, !0),
                    h = s.call(n, -1 !== p || l.call(n, 0) ? p : -1);
                  if (d <= h) e.end = e.begin = l.call(n, d, !1, !0) ? d : s.call(n, d);else {
                    var v = u.validPositions[p],
                      m = a.getTestTemplate.call(n, h, v ? v.match.locator : void 0, v),
                      g = a.getPlaceholder.call(n, h, m.match);
                    if ("" !== g && r.call(n)[h] !== g && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !l.call(n, h, c.keepStatic, !0) && m.match.def === g) {
                      var k = s.call(n, h);
                      (d >= k || d === h) && (h = k);
                    }
                    e.end = e.begin = h;
                  }
              }
              return e;
            }
          }, t.getBuffer = r, t.getBufferTemplate = function () {
            var e = this.maskset;
            void 0 === e._buffer && (e._buffer = a.getMaskTemplate.call(this, !1, 1), void 0 === e.buffer && (e.buffer = e._buffer.slice()));
            return e._buffer;
          }, t.getLastValidPosition = o, t.isMask = l, t.resetMaskSet = function (e) {
            var t = this.maskset;
            t.buffer = void 0, !0 !== e && (t.validPositions = {}, t.p = 0);
          }, t.seekNext = s, t.seekPrevious = function (e, t) {
            var i = this,
              n = e - 1;
            if (e <= 0) return 0;
            for (; n > 0 && (!0 === t && (!0 !== a.getTest.call(i, n).match.newBlockMarker || !l.call(i, n, void 0, !0)) || !0 !== t && !l.call(i, n, void 0, !0));) {
              n--;
            }
            return n;
          }, t.translatePosition = u;
          var a = i(4713),
            n = i(7215);
          function r(e) {
            var t = this.maskset;
            return void 0 !== t.buffer && !0 !== e || (t.buffer = a.getMaskTemplate.call(this, !0, o.call(this), !0), void 0 === t._buffer && (t._buffer = t.buffer.slice())), t.buffer;
          }
          function o(e, t, i) {
            var a = this.maskset,
              n = -1,
              r = -1,
              o = i || a.validPositions;
            for (var l in void 0 === e && (e = -1), o) {
              var s = parseInt(l);
              o[s] && (t || !0 !== o[s].generatedInput) && (s <= e && (n = s), s >= e && (r = s));
            }
            return -1 === n || n == e ? r : -1 == r || e - n < r - e ? n : r;
          }
          function l(e, t, i) {
            var n = this,
              r = this.maskset,
              o = a.getTestTemplate.call(n, e).match;
            if ("" === o.def && (o = a.getTest.call(n, e).match), !0 !== o.static) return o.fn;
            if (!0 === i && void 0 !== r.validPositions[e] && !0 !== r.validPositions[e].generatedInput) return !0;
            if (!0 !== t && e > -1) {
              if (i) {
                var l = a.getTests.call(n, e);
                return l.length > 1 + ("" === l[l.length - 1].match.def ? 1 : 0);
              }
              var s = a.determineTestTemplate.call(n, e, a.getTests.call(n, e)),
                u = a.getPlaceholder.call(n, e, s.match);
              return s.match.def !== u;
            }
            return !1;
          }
          function s(e, t, i) {
            var n = this;
            void 0 === i && (i = !0);
            for (var r = e + 1; "" !== a.getTest.call(n, r).match.def && (!0 === t && (!0 !== a.getTest.call(n, r).match.newBlockMarker || !l.call(n, r, void 0, !0)) || !0 !== t && !l.call(n, r, void 0, i));) {
              r++;
            }
            return r;
          }
          function u(e) {
            var t = this.opts,
              i = this.el;
            return !this.isRTL || "number" != typeof e || t.greedy && "" === t.placeholder || !i || (e = Math.abs(this._valueGet().length - e)), e;
          }
        },
        4713: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.determineTestTemplate = u, t.getDecisionTaker = o, t.getMaskTemplate = function (e, t, i, a, n) {
            var r = this,
              o = this.opts,
              c = this.maskset,
              f = o.greedy;
            n && o.greedy && (o.greedy = !1, r.maskset.tests = {});
            t = t || 0;
            var p,
              h,
              v,
              m,
              g = [],
              k = 0;
            do {
              if (!0 === e && c.validPositions[k]) v = n && c.validPositions[k].match.optionality && void 0 === c.validPositions[k + 1] && (!0 === c.validPositions[k].generatedInput || c.validPositions[k].input == o.skipOptionalPartCharacter && k > 0) ? u.call(r, k, d.call(r, k, p, k - 1)) : c.validPositions[k], h = v.match, p = v.locator.slice(), g.push(!0 === i ? v.input : !1 === i ? h.nativeDef : l.call(r, k, h));else {
                v = s.call(r, k, p, k - 1), h = v.match, p = v.locator.slice();
                var y = !0 !== a && (!1 !== o.jitMasking ? o.jitMasking : h.jit);
                (m = (m && h.static && h.def !== o.groupSeparator && null === h.fn || c.validPositions[k - 1] && h.static && h.def !== o.groupSeparator && null === h.fn) && c.tests[k] && 1 === c.tests[k].length) || !1 === y || void 0 === y || "number" == typeof y && isFinite(y) && y > k ? g.push(!1 === i ? h.nativeDef : l.call(r, k, h)) : m = !1;
              }
              k++;
            } while (!0 !== h.static || "" !== h.def || t > k);
            "" === g[g.length - 1] && g.pop();
            !1 === i && void 0 !== c.maskLength || (c.maskLength = k - 1);
            return o.greedy = f, g;
          }, t.getPlaceholder = l, t.getTest = c, t.getTestTemplate = s, t.getTests = d, t.isSubsetOf = f;
          var a,
            n = (a = i(2394)) && a.__esModule ? a : {
              default: a
            };
          function r(e, t) {
            var i = (null != e.alternation ? e.mloc[o(e)] : e.locator).join("");
            if ("" !== i) for (; i.length < t;) {
              i += "0";
            }
            return i;
          }
          function o(e) {
            var t = e.locator[e.alternation];
            return "string" == typeof t && t.length > 0 && (t = t.split(",")[0]), void 0 !== t ? t.toString() : "";
          }
          function l(e, t, i) {
            var a = this.opts,
              n = this.maskset;
            if (void 0 !== (t = t || c.call(this, e).match).placeholder || !0 === i) return "function" == typeof t.placeholder ? t.placeholder(a) : t.placeholder;
            if (!0 === t.static) {
              if (e > -1 && void 0 === n.validPositions[e]) {
                var r,
                  o = d.call(this, e),
                  l = [];
                if (o.length > 1 + ("" === o[o.length - 1].match.def ? 1 : 0)) for (var s = 0; s < o.length; s++) {
                  if ("" !== o[s].match.def && !0 !== o[s].match.optionality && !0 !== o[s].match.optionalQuantifier && (!0 === o[s].match.static || void 0 === r || !1 !== o[s].match.fn.test(r.match.def, n, e, !0, a)) && (l.push(o[s]), !0 === o[s].match.static && (r = o[s]), l.length > 1 && /[0-9a-bA-Z]/.test(l[0].match.def))) return a.placeholder.charAt(e % a.placeholder.length);
                }
              }
              return t.def;
            }
            return a.placeholder.charAt(e % a.placeholder.length);
          }
          function s(e, t, i) {
            return this.maskset.validPositions[e] || u.call(this, e, d.call(this, e, t ? t.slice() : t, i));
          }
          function u(e, t) {
            var i = this.opts,
              a = function (e, t) {
                var i = 0,
                  a = !1;
                t.forEach(function (e) {
                  e.match.optionality && (0 !== i && i !== e.match.optionality && (a = !0), (0 === i || i > e.match.optionality) && (i = e.match.optionality));
                }), i && (0 == e || 1 == t.length ? i = 0 : a || (i = 0));
                return i;
              }(e, t);
            e = e > 0 ? e - 1 : 0;
            var n,
              o,
              l,
              s = r(c.call(this, e));
            i.greedy && t.length > 1 && "" === t[t.length - 1].match.def && t.pop();
            for (var u = 0; u < t.length; u++) {
              var f = t[u];
              n = r(f, s.length);
              var d = Math.abs(n - s);
              (void 0 === o || "" !== n && d < o || l && !i.greedy && l.match.optionality && l.match.optionality - a > 0 && "master" === l.match.newBlockMarker && (!f.match.optionality || f.match.optionality - a < 1 || !f.match.newBlockMarker) || l && !i.greedy && l.match.optionalQuantifier && !f.match.optionalQuantifier) && (o = d, l = f);
            }
            return l;
          }
          function c(e, t) {
            var i = this.maskset;
            return i.validPositions[e] ? i.validPositions[e] : (t || d.call(this, e))[0];
          }
          function f(e, t, i) {
            function a(e) {
              for (var t, i = [], a = -1, n = 0, r = e.length; n < r; n++) {
                if ("-" === e.charAt(n)) for (t = e.charCodeAt(n + 1); ++a < t;) {
                  i.push(String.fromCharCode(a));
                } else a = e.charCodeAt(n), i.push(e.charAt(n));
              }
              return i.join("");
            }
            return e.match.def === t.match.nativeDef || !(!(i.regex || e.match.fn instanceof RegExp && t.match.fn instanceof RegExp) || !0 === e.match.static || !0 === t.match.static) && -1 !== a(t.match.fn.toString().replace(/[[\]/]/g, "")).indexOf(a(e.match.fn.toString().replace(/[[\]/]/g, "")));
          }
          function d(e, t, i) {
            var a,
              r,
              o = this,
              l = this.dependencyLib,
              s = this.maskset,
              c = this.opts,
              d = this.el,
              p = s.maskToken,
              h = t ? i : 0,
              v = t ? t.slice() : [0],
              m = [],
              g = !1,
              k = t ? t.join("") : "";
            function y(t, i, r, o) {
              function l(r, o, u) {
                function p(e, t) {
                  var i = 0 === t.matches.indexOf(e);
                  return i || t.matches.every(function (a, n) {
                    return !0 === a.isQuantifier ? i = p(e, t.matches[n - 1]) : Object.prototype.hasOwnProperty.call(a, "matches") && (i = p(e, a)), !i;
                  }), i;
                }
                function v(e, t, i) {
                  var a, n;
                  if ((s.tests[e] || s.validPositions[e]) && (s.tests[e] || [s.validPositions[e]]).every(function (e, r) {
                    if (e.mloc[t]) return a = e, !1;
                    var o = void 0 !== i ? i : e.alternation,
                      l = void 0 !== e.locator[o] ? e.locator[o].toString().indexOf(t) : -1;
                    return (void 0 === n || l < n) && -1 !== l && (a = e, n = l), !0;
                  }), a) {
                    var r = a.locator[a.alternation];
                    return (a.mloc[t] || a.mloc[r] || a.locator).slice((void 0 !== i ? i : a.alternation) + 1);
                  }
                  return void 0 !== i ? v(e, t) : void 0;
                }
                function b(e, t) {
                  var i = e.alternation,
                    a = void 0 === t || i === t.alternation && -1 === e.locator[i].toString().indexOf(t.locator[i]);
                  if (!a && i > t.alternation) for (var n = t.alternation; n < i; n++) {
                    if (e.locator[n] !== t.locator[n]) {
                      i = n, a = !0;
                      break;
                    }
                  }
                  if (a) {
                    e.mloc = e.mloc || {};
                    var r = e.locator[i];
                    if (void 0 !== r) {
                      if ("string" == typeof r && (r = r.split(",")[0]), void 0 === e.mloc[r] && (e.mloc[r] = e.locator.slice()), void 0 !== t) {
                        for (var o in t.mloc) {
                          "string" == typeof o && (o = o.split(",")[0]), void 0 === e.mloc[o] && (e.mloc[o] = t.mloc[o]);
                        }
                        e.locator[i] = Object.keys(e.mloc).join(",");
                      }
                      return !0;
                    }
                    e.alternation = void 0;
                  }
                  return !1;
                }
                function x(e, t) {
                  if (e.locator.length !== t.locator.length) return !1;
                  for (var i = e.alternation + 1; i < e.locator.length; i++) {
                    if (e.locator[i] !== t.locator[i]) return !1;
                  }
                  return !0;
                }
                if (h > e + c._maxTestPos) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + s.mask;
                if (h === e && void 0 === r.matches) {
                  if (m.push({
                    match: r,
                    locator: o.reverse(),
                    cd: k,
                    mloc: {}
                  }), !r.optionality || void 0 !== u || !(c.definitions && c.definitions[r.nativeDef] && c.definitions[r.nativeDef].optional || n.default.prototype.definitions[r.nativeDef] && n.default.prototype.definitions[r.nativeDef].optional)) return !0;
                  g = !0, h = e;
                } else if (void 0 !== r.matches) {
                  if (r.isGroup && u !== r) {
                    if (r = l(t.matches[t.matches.indexOf(r) + 1], o, u)) return !0;
                  } else if (r.isOptional) {
                    var P = r,
                      E = m.length;
                    if (r = y(r, i, o, u)) {
                      if (m.forEach(function (e, t) {
                        t >= E && (e.match.optionality = e.match.optionality ? e.match.optionality + 1 : 1);
                      }), a = m[m.length - 1].match, void 0 !== u || !p(a, P)) return !0;
                      g = !0, h = e;
                    }
                  } else if (r.isAlternator) {
                    var S,
                      _ = r,
                      w = [],
                      M = m.slice(),
                      O = o.length,
                      T = !1,
                      C = i.length > 0 ? i.shift() : -1;
                    if (-1 === C || "string" == typeof C) {
                      var A,
                        D = h,
                        j = i.slice(),
                        B = [];
                      if ("string" == typeof C) B = C.split(",");else for (A = 0; A < _.matches.length; A++) {
                        B.push(A.toString());
                      }
                      if (void 0 !== s.excludes[e]) {
                        for (var R = B.slice(), L = 0, I = s.excludes[e].length; L < I; L++) {
                          var F = s.excludes[e][L].toString().split(":");
                          o.length == F[1] && B.splice(B.indexOf(F[0]), 1);
                        }
                        0 === B.length && (delete s.excludes[e], B = R);
                      }
                      (!0 === c.keepStatic || isFinite(parseInt(c.keepStatic)) && D >= c.keepStatic) && (B = B.slice(0, 1));
                      for (var N = 0; N < B.length; N++) {
                        A = parseInt(B[N]), m = [], i = "string" == typeof C && v(h, A, O) || j.slice();
                        var V = _.matches[A];
                        if (V && l(V, [A].concat(o), u)) r = !0;else if (0 === N && (T = !0), V && V.matches && V.matches.length > _.matches[0].matches.length) break;
                        S = m.slice(), h = D, m = [];
                        for (var G = 0; G < S.length; G++) {
                          var H = S[G],
                            K = !1;
                          H.match.jit = H.match.jit || T, H.alternation = H.alternation || O, b(H);
                          for (var U = 0; U < w.length; U++) {
                            var $ = w[U];
                            if ("string" != typeof C || void 0 !== H.alternation && B.includes(H.locator[H.alternation].toString())) {
                              if (H.match.nativeDef === $.match.nativeDef) {
                                K = !0, b($, H);
                                break;
                              }
                              if (f(H, $, c)) {
                                b(H, $) && (K = !0, w.splice(w.indexOf($), 0, H));
                                break;
                              }
                              if (f($, H, c)) {
                                b($, H);
                                break;
                              }
                              if (Z = $, !0 === (Q = H).match.static && !0 !== Z.match.static && Z.match.fn.test(Q.match.def, s, e, !1, c, !1)) {
                                x(H, $) || void 0 !== d.inputmask.userOptions.keepStatic ? b(H, $) && (K = !0, w.splice(w.indexOf($), 0, H)) : c.keepStatic = !0;
                                break;
                              }
                            }
                          }
                          K || w.push(H);
                        }
                      }
                      m = M.concat(w), h = e, g = m.length > 0, r = w.length > 0, i = j.slice();
                    } else r = l(_.matches[C] || t.matches[C], [C].concat(o), u);
                    if (r) return !0;
                  } else if (r.isQuantifier && u !== t.matches[t.matches.indexOf(r) - 1]) for (var q = r, z = i.length > 0 ? i.shift() : 0; z < (isNaN(q.quantifier.max) ? z + 1 : q.quantifier.max) && h <= e; z++) {
                    var W = t.matches[t.matches.indexOf(q) - 1];
                    if (r = l(W, [z].concat(o), W)) {
                      if ((a = m[m.length - 1].match).optionalQuantifier = z >= q.quantifier.min, a.jit = (z + 1) * (W.matches.indexOf(a) + 1) > q.quantifier.jit, a.optionalQuantifier && p(a, W)) {
                        g = !0, h = e;
                        break;
                      }
                      return a.jit && (s.jitOffset[e] = W.matches.length - W.matches.indexOf(a)), !0;
                    }
                  } else if (r = y(r, i, o, u)) return !0;
                } else h++;
                var Q, Z;
              }
              for (var u = i.length > 0 ? i.shift() : 0; u < t.matches.length; u++) {
                if (!0 !== t.matches[u].isQuantifier) {
                  var p = l(t.matches[u], [u].concat(r), o);
                  if (p && h === e) return p;
                  if (h > e) break;
                }
              }
            }
            if (e > -1) {
              if (void 0 === t) {
                for (var b, x = e - 1; void 0 === (b = s.validPositions[x] || s.tests[x]) && x > -1;) {
                  x--;
                }
                void 0 !== b && x > -1 && (v = function (e, t) {
                  var i,
                    a = [];
                  return Array.isArray(t) || (t = [t]), t.length > 0 && (void 0 === t[0].alternation || !0 === c.keepStatic ? 0 === (a = u.call(o, e, t.slice()).locator.slice()).length && (a = t[0].locator.slice()) : t.forEach(function (e) {
                    "" !== e.def && (0 === a.length ? (i = e.alternation, a = e.locator.slice()) : e.locator[i] && -1 === a[i].toString().indexOf(e.locator[i]) && (a[i] += "," + e.locator[i]));
                  })), a;
                }(x, b), k = v.join(""), h = x);
              }
              if (s.tests[e] && s.tests[e][0].cd === k) return s.tests[e];
              for (var P = v.shift(); P < p.length; P++) {
                if (y(p[P], v, [P]) && h === e || h > e) break;
              }
            }
            return (0 === m.length || g) && m.push({
              match: {
                fn: null,
                static: !0,
                optionality: !1,
                casing: null,
                def: "",
                placeholder: ""
              },
              locator: [],
              mloc: {},
              cd: k
            }), void 0 !== t && s.tests[e] ? r = l.extend(!0, [], m) : (s.tests[e] = l.extend(!0, [], m), r = s.tests[e]), m.forEach(function (e) {
              e.match.optionality = !1;
            }), r;
          }
        },
        7215: function _(e, t, i) {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.alternate = s, t.checkAlternationMatch = function (e, t, i) {
            for (var a, n = this.opts.greedy ? t : t.slice(0, 1), r = !1, o = void 0 !== i ? i.split(",") : [], l = 0; l < o.length; l++) {
              -1 !== (a = e.indexOf(o[l])) && e.splice(a, 1);
            }
            for (var s = 0; s < e.length; s++) {
              if (n.includes(e[s])) {
                r = !0;
                break;
              }
            }
            return r;
          }, t.handleRemove = function (e, t, i, a, l) {
            var u = this,
              c = this.maskset,
              f = this.opts;
            if ((f.numericInput || u.isRTL) && (t === r.default.BACKSPACE ? t = r.default.DELETE : t === r.default.DELETE && (t = r.default.BACKSPACE), u.isRTL)) {
              var d = i.end;
              i.end = i.begin, i.begin = d;
            }
            var p,
              h = o.getLastValidPosition.call(u, void 0, !0);
            i.end >= o.getBuffer.call(u).length && h >= i.end && (i.end = h + 1);
            t === r.default.BACKSPACE ? i.end - i.begin < 1 && (i.begin = o.seekPrevious.call(u, i.begin)) : t === r.default.DELETE && i.begin === i.end && (i.end = o.isMask.call(u, i.end, !0, !0) ? i.end + 1 : o.seekNext.call(u, i.end) + 1);
            if (!1 !== (p = m.call(u, i))) {
              if (!0 !== a && !1 !== f.keepStatic || null !== f.regex && -1 !== n.getTest.call(u, i.begin).match.def.indexOf("|")) {
                var v = s.call(u, !0);
                if (v) {
                  var g = void 0 !== v.caret ? v.caret : v.pos ? o.seekNext.call(u, v.pos.begin ? v.pos.begin : v.pos) : o.getLastValidPosition.call(u, -1, !0);
                  (t !== r.default.DELETE || i.begin > g) && i.begin;
                }
              }
              !0 !== a && (c.p = t === r.default.DELETE ? i.begin + p : i.begin, c.p = o.determineNewCaretPosition.call(u, {
                begin: c.p,
                end: c.p
              }, !1, !1 === f.insertMode && t === r.default.BACKSPACE ? "none" : void 0).begin);
            }
          }, t.isComplete = c, t.isSelection = f, t.isValid = d, t.refreshFromBuffer = h, t.revalidateMask = m;
          var a,
            n = i(4713),
            r = (a = i(5581)) && a.__esModule ? a : {
              default: a
            },
            o = i(8711),
            l = i(6030);
          function s(e, t, i, a, r, l) {
            var u,
              c,
              f,
              p,
              h,
              v,
              m,
              g,
              k,
              y,
              b,
              x = this,
              P = this.dependencyLib,
              E = this.opts,
              S = x.maskset,
              _ = P.extend(!0, {}, S.validPositions),
              w = P.extend(!0, {}, S.tests),
              M = !1,
              O = !1,
              T = void 0 !== r ? r : o.getLastValidPosition.call(x);
            if (l && (y = l.begin, b = l.end, l.begin > l.end && (y = l.end, b = l.begin)), -1 === T && void 0 === r) u = 0, c = (p = n.getTest.call(x, u)).alternation;else for (; T >= 0; T--) {
              if ((f = S.validPositions[T]) && void 0 !== f.alternation) {
                if (p && p.locator[f.alternation] !== f.locator[f.alternation]) break;
                u = T, c = S.validPositions[u].alternation, p = f;
              }
            }
            if (void 0 !== c) {
              m = parseInt(u), S.excludes[m] = S.excludes[m] || [], !0 !== e && S.excludes[m].push((0, n.getDecisionTaker)(p) + ":" + p.alternation);
              var C = [],
                A = -1;
              for (h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) {
                -1 === A && e <= h && void 0 !== t && (C.push(t), A = C.length - 1), (v = S.validPositions[h]) && !0 !== v.generatedInput && (void 0 === l || h < y || h >= b) && C.push(v.input), delete S.validPositions[h];
              }
              for (-1 === A && void 0 !== t && (C.push(t), A = C.length - 1); void 0 !== S.excludes[m] && S.excludes[m].length < 10;) {
                for (S.tests = {}, o.resetMaskSet.call(x, !0), M = !0, h = 0; h < C.length && (g = M.caret || o.getLastValidPosition.call(x, void 0, !0) + 1, k = C[h], M = d.call(x, g, k, !1, a, !0)); h++) {
                  h === A && (O = M), 1 == e && M && (O = {
                    caretPos: h
                  });
                }
                if (M) break;
                if (o.resetMaskSet.call(x), p = n.getTest.call(x, m), S.validPositions = P.extend(!0, {}, _), S.tests = P.extend(!0, {}, w), !S.excludes[m]) {
                  O = s.call(x, e, t, i, a, m - 1, l);
                  break;
                }
                var D = (0, n.getDecisionTaker)(p);
                if (-1 !== S.excludes[m].indexOf(D + ":" + p.alternation)) {
                  O = s.call(x, e, t, i, a, m - 1, l);
                  break;
                }
                for (S.excludes[m].push(D + ":" + p.alternation), h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) {
                  delete S.validPositions[h];
                }
              }
            }
            return O && !1 === E.keepStatic || delete S.excludes[m], O;
          }
          function u(e, t, i) {
            var a = this.opts,
              n = this.maskset;
            switch (a.casing || t.casing) {
              case "upper":
                e = e.toUpperCase();
                break;
              case "lower":
                e = e.toLowerCase();
                break;
              case "title":
                var o = n.validPositions[i - 1];
                e = 0 === i || o && o.input === String.fromCharCode(r.default.SPACE) ? e.toUpperCase() : e.toLowerCase();
                break;
              default:
                if ("function" == typeof a.casing) {
                  var l = Array.prototype.slice.call(arguments);
                  l.push(n.validPositions), e = a.casing.apply(this, l);
                }
            }
            return e;
          }
          function c(e) {
            var t = this,
              i = this.opts,
              a = this.maskset;
            if ("function" == typeof i.isComplete) return i.isComplete(e, i);
            if ("*" !== i.repeat) {
              var r = !1,
                l = o.determineLastRequiredPosition.call(t, !0),
                s = o.seekPrevious.call(t, l.l);
              if (void 0 === l.def || l.def.newBlockMarker || l.def.optionality || l.def.optionalQuantifier) {
                r = !0;
                for (var u = 0; u <= s; u++) {
                  var c = n.getTestTemplate.call(t, u).match;
                  if (!0 !== c.static && void 0 === a.validPositions[u] && !0 !== c.optionality && !0 !== c.optionalQuantifier || !0 === c.static && e[u] !== n.getPlaceholder.call(t, u, c)) {
                    r = !1;
                    break;
                  }
                }
              }
              return r;
            }
          }
          function f(e) {
            var t = this.opts.insertMode ? 0 : 1;
            return this.isRTL ? e.begin - e.end > t : e.end - e.begin > t;
          }
          function d(e, t, i, a, r, l, p) {
            var g = this,
              k = this.dependencyLib,
              y = this.opts,
              b = g.maskset;
            i = !0 === i;
            var x = e;
            function P(e) {
              if (void 0 !== e) {
                if (void 0 !== e.remove && (Array.isArray(e.remove) || (e.remove = [e.remove]), e.remove.sort(function (e, t) {
                  return t.pos - e.pos;
                }).forEach(function (e) {
                  m.call(g, {
                    begin: e,
                    end: e + 1
                  });
                }), e.remove = void 0), void 0 !== e.insert && (Array.isArray(e.insert) || (e.insert = [e.insert]), e.insert.sort(function (e, t) {
                  return e.pos - t.pos;
                }).forEach(function (e) {
                  "" !== e.c && d.call(g, e.pos, e.c, void 0 === e.strict || e.strict, void 0 !== e.fromIsValid ? e.fromIsValid : a);
                }), e.insert = void 0), e.refreshFromBuffer && e.buffer) {
                  var t = e.refreshFromBuffer;
                  h.call(g, !0 === t ? t : t.start, t.end, e.buffer), e.refreshFromBuffer = void 0;
                }
                void 0 !== e.rewritePosition && (x = e.rewritePosition, e = !0);
              }
              return e;
            }
            function E(t, i, r) {
              var l = !1;
              return n.getTests.call(g, t).every(function (s, c) {
                var d = s.match;
                if (o.getBuffer.call(g, !0), !1 !== (l = (!d.jit || void 0 !== b.validPositions[o.seekPrevious.call(g, t)]) && (null != d.fn ? d.fn.test(i, b, t, r, y, f.call(g, e)) : (i === d.def || i === y.skipOptionalPartCharacter) && "" !== d.def && {
                  c: n.getPlaceholder.call(g, t, d, !0) || d.def,
                  pos: t
                }))) {
                  var p = void 0 !== l.c ? l.c : i,
                    h = t;
                  return p = p === y.skipOptionalPartCharacter && !0 === d.static ? n.getPlaceholder.call(g, t, d, !0) || d.def : p, !0 !== (l = P(l)) && void 0 !== l.pos && l.pos !== t && (h = l.pos), !0 !== l && void 0 === l.pos && void 0 === l.c ? !1 : (!1 === m.call(g, e, k.extend({}, s, {
                    input: u.call(g, p, d, h)
                  }), a, h) && (l = !1), !1);
                }
                return !0;
              }), l;
            }
            void 0 !== e.begin && (x = g.isRTL ? e.end : e.begin);
            var S = !0,
              _ = k.extend(!0, {}, b.validPositions);
            if (!1 === y.keepStatic && void 0 !== b.excludes[x] && !0 !== r && !0 !== a) for (var w = x; w < (g.isRTL ? e.begin : e.end); w++) {
              void 0 !== b.excludes[w] && (b.excludes[w] = void 0, delete b.tests[w]);
            }
            if ("function" == typeof y.preValidation && !0 !== a && !0 !== l && (S = P(S = y.preValidation.call(g, o.getBuffer.call(g), x, t, f.call(g, e), y, b, e, i || r))), !0 === S) {
              if (S = E(x, t, i), (!i || !0 === a) && !1 === S && !0 !== l) {
                var M = b.validPositions[x];
                if (!M || !0 !== M.match.static || M.match.def !== t && t !== y.skipOptionalPartCharacter) {
                  if (y.insertMode || void 0 === b.validPositions[o.seekNext.call(g, x)] || e.end > x) {
                    var O = !1;
                    if (b.jitOffset[x] && void 0 === b.validPositions[o.seekNext.call(g, x)] && !1 !== (S = d.call(g, x + b.jitOffset[x], t, !0, !0)) && (!0 !== r && (S.caret = x), O = !0), e.end > x && (b.validPositions[x] = void 0), !O && !o.isMask.call(g, x, y.keepStatic && 0 === x)) for (var T = x + 1, C = o.seekNext.call(g, x, !1, 0 !== x); T <= C; T++) {
                      if (!1 !== (S = E(T, t, i))) {
                        S = v.call(g, x, void 0 !== S.pos ? S.pos : T) || S, x = T;
                        break;
                      }
                    }
                  }
                } else S = {
                  caret: o.seekNext.call(g, x)
                };
              }
              !1 !== S || !y.keepStatic || !c.call(g, o.getBuffer.call(g)) && 0 !== x || i || !0 === r ? f.call(g, e) && b.tests[x] && b.tests[x].length > 1 && y.keepStatic && !i && !0 !== r && (S = s.call(g, !0)) : S = s.call(g, x, t, i, a, void 0, e), !0 === S && (S = {
                pos: x
              });
            }
            if ("function" == typeof y.postValidation && !0 !== a && !0 !== l) {
              var A = y.postValidation.call(g, o.getBuffer.call(g, !0), void 0 !== e.begin ? g.isRTL ? e.end : e.begin : e, t, S, y, b, i, p);
              void 0 !== A && (S = !0 === A ? S : A);
            }
            S && void 0 === S.pos && (S.pos = x), !1 === S || !0 === l ? (o.resetMaskSet.call(g, !0), b.validPositions = k.extend(!0, {}, _)) : v.call(g, void 0, x, !0);
            var D = P(S);
            void 0 !== g.maxLength && o.getBuffer.call(g).length > g.maxLength && !a && (o.resetMaskSet.call(g, !0), b.validPositions = k.extend(!0, {}, _), D = !1);
            return D;
          }
          function p(e, t, i) {
            for (var a = this.maskset, r = !1, o = n.getTests.call(this, e), l = 0; l < o.length; l++) {
              if (o[l].match && (o[l].match.nativeDef === t.match[i.shiftPositions ? "def" : "nativeDef"] && (!i.shiftPositions || !t.match.static) || o[l].match.nativeDef === t.match.nativeDef || i.regex && !o[l].match.static && o[l].match.fn.test(t.input))) {
                r = !0;
                break;
              }
              if (o[l].match && o[l].match.def === t.match.nativeDef) {
                r = void 0;
                break;
              }
            }
            return !1 === r && void 0 !== a.jitOffset[e] && (r = p.call(this, e + a.jitOffset[e], t, i)), r;
          }
          function h(e, t, i) {
            var a,
              n,
              r = this,
              s = this.maskset,
              u = this.opts,
              c = this.dependencyLib,
              f = u.skipOptionalPartCharacter,
              d = r.isRTL ? i.slice().reverse() : i;
            if (u.skipOptionalPartCharacter = "", !0 === e) o.resetMaskSet.call(r), s.tests = {}, e = 0, t = i.length, n = o.determineNewCaretPosition.call(r, {
              begin: 0,
              end: 0
            }, !1).begin;else {
              for (a = e; a < t; a++) {
                delete s.validPositions[a];
              }
              n = e;
            }
            var p = new c.Event("keypress");
            for (a = e; a < t; a++) {
              p.keyCode = d[a].toString().charCodeAt(0), r.ignorable = !1;
              var h = l.EventHandlers.keypressEvent.call(r, p, !0, !1, !1, n);
              !1 !== h && void 0 !== h && (n = h.forwardPosition);
            }
            u.skipOptionalPartCharacter = f;
          }
          function v(e, t, i) {
            var a = this,
              r = this.maskset,
              l = this.dependencyLib;
            if (void 0 === e) for (e = t - 1; e > 0 && !r.validPositions[e]; e--) {
              ;
            }
            for (var s = e; s < t; s++) {
              if (void 0 === r.validPositions[s] && !o.isMask.call(a, s, !1)) if (0 == s ? n.getTest.call(a, s) : r.validPositions[s - 1]) {
                var u = n.getTests.call(a, s).slice();
                "" === u[u.length - 1].match.def && u.pop();
                var c,
                  f = n.determineTestTemplate.call(a, s, u);
                if (f && (!0 !== f.match.jit || "master" === f.match.newBlockMarker && (c = r.validPositions[s + 1]) && !0 === c.match.optionalQuantifier) && ((f = l.extend({}, f, {
                  input: n.getPlaceholder.call(a, s, f.match, !0) || f.match.def
                })).generatedInput = !0, m.call(a, s, f, !0), !0 !== i)) {
                  var p = r.validPositions[t].input;
                  return r.validPositions[t] = void 0, d.call(a, t, p, !0, !0);
                }
              }
            }
          }
          function m(e, t, i, a) {
            var r = this,
              l = this.maskset,
              s = this.opts,
              u = this.dependencyLib;
            function c(e, t, i) {
              var a = t[e];
              if (void 0 !== a && !0 === a.match.static && !0 !== a.match.optionality && (void 0 === t[0] || void 0 === t[0].alternation)) {
                var n = i.begin <= e - 1 ? t[e - 1] && !0 === t[e - 1].match.static && t[e - 1] : t[e - 1],
                  r = i.end > e + 1 ? t[e + 1] && !0 === t[e + 1].match.static && t[e + 1] : t[e + 1];
                return n && r;
              }
              return !1;
            }
            var f = 0,
              h = void 0 !== e.begin ? e.begin : e,
              v = void 0 !== e.end ? e.end : e,
              m = !0;
            if (e.begin > e.end && (h = e.end, v = e.begin), a = void 0 !== a ? a : h, h !== v || s.insertMode && void 0 !== l.validPositions[a] && void 0 === i || void 0 === t || t.match.optionalQuantifier || t.match.optionality) {
              var g,
                k = u.extend(!0, {}, l.validPositions),
                y = o.getLastValidPosition.call(r, void 0, !0);
              for (l.p = h, g = y; g >= h; g--) {
                delete l.validPositions[g], void 0 === t && delete l.tests[g + 1];
              }
              var b,
                x,
                P = a,
                E = P;
              for (t && (l.validPositions[a] = u.extend(!0, {}, t), E++, P++), g = t ? v : v - 1; g <= y; g++) {
                if (void 0 !== (b = k[g]) && !0 !== b.generatedInput && (g >= v || g >= h && c(g, k, {
                  begin: h,
                  end: v
                }))) {
                  for (; "" !== n.getTest.call(r, E).match.def;) {
                    if (!1 !== (x = p.call(r, E, b, s)) || "+" === b.match.def) {
                      "+" === b.match.def && o.getBuffer.call(r, !0);
                      var S = d.call(r, E, b.input, "+" !== b.match.def, !0);
                      if (m = !1 !== S, P = (S.pos || E) + 1, !m && x) break;
                    } else m = !1;
                    if (m) {
                      void 0 === t && b.match.static && g === e.begin && f++;
                      break;
                    }
                    if (!m && o.getBuffer.call(r), E > l.maskLength) break;
                    E++;
                  }
                  "" == n.getTest.call(r, E).match.def && (m = !1), E = P;
                }
                if (!m) break;
              }
              if (!m) return l.validPositions = u.extend(!0, {}, k), o.resetMaskSet.call(r, !0), !1;
            } else t && n.getTest.call(r, a).match.cd === t.match.cd && (l.validPositions[a] = u.extend(!0, {}, t));
            return o.resetMaskSet.call(r, !0), f;
          }
        },
        5581: function _(e) {
          e.exports = JSON.parse('{"BACKSPACE":8,"BACKSPACE_SAFARI":127,"DELETE":46,"DOWN":40,"END":35,"ENTER":13,"ESCAPE":27,"HOME":36,"INSERT":45,"LEFT":37,"PAGE_DOWN":34,"PAGE_UP":33,"RIGHT":39,"SPACE":32,"TAB":9,"UP":38,"X":88,"Z":90,"CONTROL":17,"PAUSE/BREAK":19,"WINDOWS_LEFT":91,"WINDOWS_RIGHT":92,"KEY_229":229}');
        }
      },
      t = {};
    function i(a) {
      var n = t[a];
      if (void 0 !== n) return n.exports;
      var r = t[a] = {
        exports: {}
      };
      return e[a](r, r.exports, i), r.exports;
    }
    var a = {};
    return function () {
      var e,
        t = a;
      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.default = void 0, i(3851), i(219), i(207), i(5296);
      var n = ((e = i(2394)) && e.__esModule ? e : {
        default: e
      }).default;
      t.default = n;
    }(), a;
  }();
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./js/just-validate.es.js":
/*!********************************!*\
  !*** ./js/just-validate.es.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JustValidate; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};
var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }
  if (__getOwnPropSymbols) {
    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return a;
};
var __publicField = function __publicField(obj, key, value) {
  __defNormalProp(obj, _typeof(key) !== "symbol" ? key + "" : key, value);
  return value;
};
var EMAIL_REGEXP = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var NUMBER_REGEXP = /^[0-9]+$/;
var PASSWORD_REGEXP = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/;
var STRONG_PASSWORD_REGEXP = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
var isEmpty = function isEmpty(value) {
  var newVal = value;
  if (typeof value === "string") {
    newVal = value.trim();
  }
  return !newVal;
};
var isEmail = function isEmail(value) {
  return EMAIL_REGEXP.test(value);
};
var isLengthMoreThanMax = function isLengthMoreThanMax(value, len) {
  return value.length > len;
};
var isLengthLessThanMin = function isLengthLessThanMin(value, len) {
  return value.length < len;
};
var isNumber = function isNumber(value) {
  return NUMBER_REGEXP.test(value);
};
var isPassword = function isPassword(value) {
  return PASSWORD_REGEXP.test(value);
};
var isStrongPassword = function isStrongPassword(value) {
  return STRONG_PASSWORD_REGEXP.test(value);
};
var isNumberMoreThanMax = function isNumberMoreThanMax(value, len) {
  return value > len;
};
var isNumberLessThanMin = function isNumberLessThanMin(value, len) {
  return value < len;
};
var Rules = /* @__PURE__ */function (Rules2) {
  Rules2["Required"] = "required";
  Rules2["Email"] = "email";
  Rules2["MinLength"] = "minLength";
  Rules2["MaxLength"] = "maxLength";
  Rules2["Password"] = "password";
  Rules2["Number"] = "number";
  Rules2["MaxNumber"] = "maxNumber";
  Rules2["MinNumber"] = "minNumber";
  Rules2["StrongPassword"] = "strongPassword";
  Rules2["CustomRegexp"] = "customRegexp";
  Rules2["MinFilesCount"] = "minFilesCount";
  Rules2["MaxFilesCount"] = "maxFilesCount";
  Rules2["Files"] = "files";
  return Rules2;
}(Rules || {});
var GroupRules = /* @__PURE__ */function (GroupRules2) {
  GroupRules2["Required"] = "required";
  return GroupRules2;
}(GroupRules || {});
var CustomStyleTagIds = /* @__PURE__ */function (CustomStyleTagIds2) {
  CustomStyleTagIds2["Label"] = "label";
  CustomStyleTagIds2["LabelArrow"] = "labelArrow";
  return CustomStyleTagIds2;
}(CustomStyleTagIds || {});
var getDefaultFieldMessage = function getDefaultFieldMessage(rule, ruleValue) {
  switch (rule) {
    case Rules.Required:
      return "The field is required";
    case Rules.Email:
      return "Email has invalid format";
    case Rules.MaxLength:
      return "The field must contain a maximum of :value characters".replace(":value", String(ruleValue));
    case Rules.MinLength:
      return "The field must contain a minimum of :value characters".replace(":value", String(ruleValue));
    case Rules.Password:
      return "Password must contain minimum eight characters, at least one letter and one number";
    case Rules.Number:
      return "Value should be a number";
    case Rules.StrongPassword:
      return "Password should contain minimum eight characters, at least one uppercase letter, one lowercase letter, one number and one special character";
    case Rules.MaxNumber:
      return "Number should be less or equal than :value".replace(":value", String(ruleValue));
    case Rules.MinNumber:
      return "Number should be more or equal than :value".replace(":value", String(ruleValue));
    case Rules.MinFilesCount:
      return "Files count should be more or equal than :value".replace(":value", String(ruleValue));
    case Rules.MaxFilesCount:
      return "Files count should be less or equal than :value".replace(":value", String(ruleValue));
    case Rules.Files:
      return "Uploaded files have one or several invalid properties (extension/size/type etc)";
    default:
      return "Value is incorrect";
  }
};
var getDefaultGroupMessage = function getDefaultGroupMessage(rule) {
  switch (rule) {
    case GroupRules.Required:
      return "The field is required";
    default:
      return "Group is incorrect";
  }
};
var isPromise = function isPromise(val) {
  return !!val && typeof val.then === "function";
};
var getNodeParents = function getNodeParents(el) {
  var elem = el;
  var els = [];
  while (elem) {
    els.unshift(elem);
    elem = elem.parentNode;
  }
  return els;
};
var getClosestParent = function getClosestParent(groups, parents) {
  var reversedParents = _toConsumableArray(parents).reverse();
  for (var i = 0, len = reversedParents.length; i < len; ++i) {
    var parent = reversedParents[i];
    for (var key in groups) {
      var group = groups[key];
      if (group.groupElem === parent) {
        return [key, group];
      }
    }
  }
  return null;
};
var getClassList = function getClassList(classList) {
  if (Array.isArray(classList)) {
    return classList.filter(function (cls) {
      return cls.length > 0;
    });
  }
  if (typeof classList === "string" && classList.trim()) {
    return _toConsumableArray(classList.split(" ").filter(function (cls) {
      return cls.length > 0;
    }));
  }
  return [];
};
var errorLabelCss = ".just-validate-error-label[data-tooltip=true]{position:fixed;padding:4px 8px;background:#423f3f;color:#fff;white-space:nowrap;z-index:10;border-radius:4px;transform:translateY(-5px)}.just-validate-error-label[data-tooltip=true]:before{content:'';width:0;height:0;border-left:solid 5px transparent;border-right:solid 5px transparent;border-bottom:solid 5px #423f3f;position:absolute;z-index:3;display:block;bottom:-5px;transform:rotate(180deg);left:calc(50% - 5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]{transform:translateX(-5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]:before{right:-7px;bottom:auto;left:auto;top:calc(50% - 2px);transform:rotate(90deg)}.just-validate-error-label[data-tooltip=true][data-direction=right]{transform:translateX(5px)}.just-validate-error-label[data-tooltip=true][data-direction=right]:before{right:auto;bottom:auto;left:-7px;top:calc(50% - 2px);transform:rotate(-90deg)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]{transform:translateY(5px)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]:before{right:auto;bottom:auto;left:calc(50% - 5px);top:-5px;transform:rotate(0)}";
var TOOLTIP_ARROW_HEIGHT = 5;
var defaultGlobalConfig = {
  errorFieldStyle: {
    color: "#b81111",
    border: "1px solid #B81111"
  },
  errorFieldCssClass: "just-validate-error-field",
  successFieldCssClass: "just-validate-success-field",
  errorLabelStyle: {
    color: "#b81111"
  },
  errorLabelCssClass: "just-validate-error-label",
  successLabelCssClass: "just-validate-success-label",
  focusInvalidField: true,
  lockForm: true,
  testingMode: false
};
var JustValidate = /*#__PURE__*/function () {
  function JustValidate(form, globalConfig, dictLocale) {
    var _this = this;
    _classCallCheck(this, JustValidate);
    __publicField(this, "form", null);
    __publicField(this, "fields", {});
    __publicField(this, "groupFields", {});
    __publicField(this, "errors", {});
    __publicField(this, "isValid", false);
    __publicField(this, "isSubmitted", false);
    __publicField(this, "globalConfig", defaultGlobalConfig);
    __publicField(this, "errorLabels", {});
    __publicField(this, "successLabels", {});
    __publicField(this, "eventListeners", []);
    __publicField(this, "dictLocale", []);
    __publicField(this, "currentLocale");
    __publicField(this, "customStyleTags", {});
    __publicField(this, "onSuccessCallback");
    __publicField(this, "onFailCallback");
    __publicField(this, "tooltips", []);
    __publicField(this, "lastScrollPosition");
    __publicField(this, "isScrollTick");
    __publicField(this, "refreshAllTooltips", function () {
      _this.tooltips.forEach(function (item) {
        item.refresh();
      });
    });
    __publicField(this, "handleDocumentScroll", function () {
      _this.lastScrollPosition = window.scrollY;
      if (!_this.isScrollTick) {
        window.requestAnimationFrame(function () {
          _this.refreshAllTooltips();
          _this.isScrollTick = false;
        });
        _this.isScrollTick = true;
      }
    });
    __publicField(this, "formSubmitHandler", function (ev) {
      ev.preventDefault();
      _this.isSubmitted = true;
      _this.validateHandler(ev);
    });
    __publicField(this, "handleFieldChange", function (target) {
      var currentFieldName;
      for (var fieldName in _this.fields) {
        var field = _this.fields[fieldName];
        if (field.elem === target) {
          currentFieldName = fieldName;
          break;
        }
      }
      if (!currentFieldName) {
        return;
      }
      _this.validateField(currentFieldName, true);
    });
    __publicField(this, "handleGroupChange", function (target) {
      var currentGroup;
      var currentGroupName;
      for (var groupName in _this.groupFields) {
        var group = _this.groupFields[groupName];
        if (group.elems.find(function (elem) {
          return elem === target;
        })) {
          currentGroup = group;
          currentGroupName = groupName;
          break;
        }
      }
      if (!currentGroup || !currentGroupName) {
        return;
      }
      _this.validateGroup(currentGroupName, currentGroup);
    });
    __publicField(this, "handlerChange", function (ev) {
      if (!ev.target) {
        return;
      }
      _this.handleFieldChange(ev.target);
      _this.handleGroupChange(ev.target);
      _this.renderErrors();
    });
    this.initialize(form, globalConfig, dictLocale);
  }
  _createClass(JustValidate, [{
    key: "initialize",
    value: function initialize(form, globalConfig, dictLocale) {
      this.form = null;
      this.errors = {};
      this.isValid = false;
      this.isSubmitted = false;
      this.globalConfig = defaultGlobalConfig;
      this.errorLabels = {};
      this.successLabels = {};
      this.eventListeners = [];
      this.customStyleTags = {};
      this.tooltips = [];
      if (typeof form === "string") {
        var elem = document.querySelector(form);
        if (!elem) {
          throw Error("Form with ".concat(form, " selector not found! Please check the form selector"));
        }
        this.setForm(elem);
      } else if (form instanceof HTMLFormElement) {
        this.setForm(form);
      } else {
        throw Error("Form selector is not valid. Please specify a string selector or a DOM element.");
      }
      this.globalConfig = __spreadValues(__spreadValues({}, defaultGlobalConfig), globalConfig);
      if (dictLocale) {
        this.dictLocale = dictLocale;
      }
      if (this.isTooltip()) {
        var styleTag = document.createElement("style");
        styleTag.textContent = errorLabelCss;
        this.customStyleTags[CustomStyleTagIds.Label] = document.head.appendChild(styleTag);
        this.addListener("scroll", document, this.handleDocumentScroll);
      }
    }
  }, {
    key: "getLocalisedString",
    value: function getLocalisedString(str) {
      var _a;
      if (!this.currentLocale || !this.dictLocale.length) {
        return str;
      }
      var localisedStr = (_a = this.dictLocale.find(function (item) {
        return item.key === str;
      })) == null ? void 0 : _a.dict[this.currentLocale];
      return localisedStr || str;
    }
  }, {
    key: "getFieldErrorMessage",
    value: function getFieldErrorMessage(fieldRule, elem) {
      var msg = typeof fieldRule.errorMessage === "function" ? fieldRule.errorMessage(this.getElemValue(elem), this.fields) : fieldRule.errorMessage;
      return this.getLocalisedString(msg) || getDefaultFieldMessage(fieldRule.rule, fieldRule.value);
    }
  }, {
    key: "getFieldSuccessMessage",
    value: function getFieldSuccessMessage(successMessage, elem) {
      var msg = typeof successMessage === "function" ? successMessage(this.getElemValue(elem), this.fields) : successMessage;
      return this.getLocalisedString(msg);
    }
  }, {
    key: "getGroupErrorMessage",
    value: function getGroupErrorMessage(groupRule) {
      return this.getLocalisedString(groupRule.errorMessage) || getDefaultGroupMessage(groupRule.rule);
    }
  }, {
    key: "getGroupSuccessMessage",
    value: function getGroupSuccessMessage(groupRule) {
      return this.getLocalisedString(groupRule.successMessage);
    }
  }, {
    key: "setFieldInvalid",
    value: function setFieldInvalid(field, fieldRule) {
      this.fields[field].isValid = false;
      this.fields[field].errorMessage = this.getFieldErrorMessage(fieldRule, this.fields[field].elem);
    }
  }, {
    key: "setFieldValid",
    value: function setFieldValid(field, successMessage) {
      this.fields[field].isValid = true;
      if (successMessage !== void 0) {
        this.fields[field].successMessage = this.getFieldSuccessMessage(successMessage, this.fields[field].elem);
      }
    }
  }, {
    key: "setGroupInvalid",
    value: function setGroupInvalid(groupName, groupRule) {
      this.groupFields[groupName].isValid = false;
      this.groupFields[groupName].errorMessage = this.getGroupErrorMessage(groupRule);
    }
  }, {
    key: "setGroupValid",
    value: function setGroupValid(groupName, groupRule) {
      this.groupFields[groupName].isValid = true;
      this.groupFields[groupName].successMessage = this.getGroupSuccessMessage(groupRule);
    }
  }, {
    key: "getElemValue",
    value: function getElemValue(elem) {
      switch (elem.type) {
        case "checkbox":
          return elem.checked;
        case "file":
          return elem.files;
        default:
          return elem.value;
      }
    }
  }, {
    key: "validateGroupRule",
    value: function validateGroupRule(groupName, elems, groupRule) {
      switch (groupRule.rule) {
        case GroupRules.Required:
          {
            if (elems.every(function (elem) {
              return !elem.checked;
            })) {
              this.setGroupInvalid(groupName, groupRule);
            } else {
              this.setGroupValid(groupName, groupRule);
            }
          }
      }
    }
  }, {
    key: "validateFieldRule",
    value: function validateFieldRule(field, elem, fieldRule) {
      var _this2 = this;
      var afterInputChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var ruleValue = fieldRule.value;
      var elemValue = this.getElemValue(elem);
      if (fieldRule.plugin) {
        var result = fieldRule.plugin(elemValue, this.fields);
        if (!result) {
          this.setFieldInvalid(field, fieldRule);
        }
        return;
      }
      switch (fieldRule.rule) {
        case Rules.Required:
          {
            if (isEmpty(elemValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.Email:
          {
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (!isEmail(elemValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.MaxLength:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] should be a number. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (elemValue === "") {
              break;
            }
            if (isLengthMoreThanMax(elemValue, ruleValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.MinLength:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] should be a number. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (elemValue === "") {
              break;
            }
            if (isLengthLessThanMin(elemValue, ruleValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.Password:
          {
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (elemValue === "") {
              break;
            }
            if (!isPassword(elemValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.StrongPassword:
          {
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (elemValue === "") {
              break;
            }
            if (!isStrongPassword(elemValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.Number:
          {
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (elemValue === "") {
              break;
            }
            if (!isNumber(elemValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.MaxNumber:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (elemValue === "") {
              break;
            }
            var num = +elemValue;
            if (Number.isNaN(num) || isNumberMoreThanMax(num, ruleValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.MinNumber:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof elemValue !== "string") {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (elemValue === "") {
              break;
            }
            var _num = +elemValue;
            if (Number.isNaN(_num) || isNumberLessThanMin(_num, ruleValue)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.CustomRegexp:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              return;
            }
            var regexp;
            try {
              regexp = new RegExp(ruleValue);
            } catch (e) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] should be a valid regexp. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            var str = String(elemValue);
            if (str !== "" && !regexp.test(str)) {
              this.setFieldInvalid(field, fieldRule);
            }
            break;
          }
        case Rules.MinFilesCount:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length < ruleValue) {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            break;
          }
        case Rules.MaxFilesCount:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length > ruleValue) {
              this.setFieldInvalid(field, fieldRule);
              break;
            }
            break;
          }
        case Rules.Files:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              return;
            }
            if (_typeof(ruleValue) !== "object") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field should be an object. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              return;
            }
            var filesConfig = ruleValue.files;
            if (_typeof(filesConfig) !== "object") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(field, "] field should be an object with files array. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              return;
            }
            var isFilePropsInvalid = function isFilePropsInvalid(file, fileConfig) {
              var minSizeInvalid = Number.isFinite(fileConfig.minSize) && file.size < fileConfig.minSize;
              var maxSizeInvalid = Number.isFinite(fileConfig.maxSize) && file.size > fileConfig.maxSize;
              var nameInvalid = Array.isArray(fileConfig.names) && !fileConfig.names.includes(file.name);
              var extInvalid = Array.isArray(fileConfig.extensions) && !fileConfig.extensions.includes(file.name.split(".")[file.name.split(".").length - 1]);
              var typeInvalid = Array.isArray(fileConfig.types) && !fileConfig.types.includes(file.type);
              return minSizeInvalid || maxSizeInvalid || nameInvalid || extInvalid || typeInvalid;
            };
            if (_typeof(elemValue) === "object" && elemValue !== null) {
              for (var fileIdx = 0, len = elemValue.length; fileIdx < len; ++fileIdx) {
                var file = elemValue.item(fileIdx);
                if (!file) {
                  this.setFieldInvalid(field, fieldRule);
                  break;
                }
                var filesInvalid = isFilePropsInvalid(file, filesConfig);
                if (filesInvalid) {
                  this.setFieldInvalid(field, fieldRule);
                  break;
                }
              }
            }
            break;
          }
        default:
          {
            if (typeof fieldRule.validator !== "function") {
              console.error("Validator for custom rule for [".concat(field, "] field should be a function. This field will be always invalid."));
              this.setFieldInvalid(field, fieldRule);
              return;
            }
            var _result = fieldRule.validator(elemValue, this.fields);
            if (typeof _result !== "boolean" && typeof _result !== "function") {
              console.error("Validator return value for [".concat(field, "] field should be boolean or function. It will be cast to boolean."));
            }
            if (typeof _result === "function") {
              if (afterInputChanged) {
                this.fields[field].asyncCheckPending = true;
              } else {
                this.fields[field].asyncCheckPending = false;
                var promise = _result();
                if (!isPromise(promise)) {
                  console.error("Validator function for custom rule for [".concat(field, "] field should return a Promise. This field will be always invalid."));
                  this.setFieldInvalid(field, fieldRule);
                  return;
                }
                return promise.then(function (resp) {
                  if (!resp) {
                    _this2.setFieldInvalid(field, fieldRule);
                  }
                }).catch(function () {
                  _this2.setFieldInvalid(field, fieldRule);
                });
              }
            }
            if (!_result) {
              this.setFieldInvalid(field, fieldRule);
            }
          }
      }
    }
  }, {
    key: "validateField",
    value: function validateField(fieldName) {
      var _this3 = this;
      var afterInputChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _a;
      var field = this.fields[fieldName];
      field.isValid = true;
      var promises = [];
      _toConsumableArray(field.rules).reverse().forEach(function (rule) {
        var res = _this3.validateFieldRule(fieldName, field.elem, rule, afterInputChanged);
        if (isPromise(res)) {
          promises.push(res);
        }
      });
      if (field.isValid) {
        this.setFieldValid(fieldName, (_a = field.config) == null ? void 0 : _a.successMessage);
      }
      return Promise.allSettled(promises);
    }
  }, {
    key: "revalidateField",
    value: function revalidateField(field) {
      var _this4 = this;
      if (typeof field !== "string") {
        throw Error("Field selector is not valid. Please specify a string selector.");
      }
      if (!this.fields[field]) {
        console.error("Field not found. Check the field selector.");
        return Promise.reject();
      }
      return new Promise(function (resolve) {
        _this4.validateField(field, true).finally(function () {
          _this4.clearFieldStyle(field);
          _this4.clearFieldLabel(field);
          _this4.renderFieldError(field);
          resolve(!!_this4.fields[field].isValid);
        });
      });
    }
  }, {
    key: "validateGroup",
    value: function validateGroup(groupName, group) {
      var _this5 = this;
      var promises = [];
      _toConsumableArray(group.rules).reverse().forEach(function (rule) {
        var res = _this5.validateGroupRule(groupName, group.elems, rule);
        if (isPromise(res)) {
          promises.push(res);
        }
      });
      return Promise.allSettled(promises);
    }
  }, {
    key: "focusInvalidField",
    value: function focusInvalidField() {
      var _this6 = this;
      var _loop = function _loop(fieldName) {
        var field = _this6.fields[fieldName];
        if (!field.isValid) {
          setTimeout(function () {
            return field.elem.focus();
          }, 0);
          return "break";
        }
      };
      for (var fieldName in this.fields) {
        var _ret = _loop(fieldName);
        if (_ret === "break") break;
      }
    }
  }, {
    key: "afterSubmitValidation",
    value: function afterSubmitValidation() {
      var forceRevalidation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.renderErrors(forceRevalidation);
      if (this.globalConfig.focusInvalidField) {
        this.focusInvalidField();
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      var _this7 = this;
      var forceRevalidation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new Promise(function (resolve) {
        var promises = [];
        Object.keys(_this7.fields).forEach(function (fieldName) {
          var promise = _this7.validateField(fieldName);
          if (isPromise(promise)) {
            promises.push(promise);
          }
        });
        Object.keys(_this7.groupFields).forEach(function (groupName) {
          var group = _this7.groupFields[groupName];
          var promise = _this7.validateGroup(groupName, group);
          if (isPromise(promise)) {
            promises.push(promise);
          }
        });
        if (promises.length) {
          Promise.allSettled(promises).then(function () {
            _this7.afterSubmitValidation(forceRevalidation);
            resolve(true);
          });
        } else {
          _this7.afterSubmitValidation(forceRevalidation);
          resolve(false);
        }
      });
    }
  }, {
    key: "revalidate",
    value: function revalidate() {
      var _this8 = this;
      return new Promise(function (resolve) {
        _this8.validateHandler(void 0, true).finally(function () {
          if (_this8.globalConfig.focusInvalidField) {
            _this8.focusInvalidField();
          }
          resolve(_this8.isValid);
        });
      });
    }
  }, {
    key: "validateHandler",
    value: function validateHandler(ev) {
      var _this9 = this;
      var forceRevalidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.globalConfig.lockForm) {
        this.lockForm();
      }
      return this.validate(forceRevalidation).finally(function () {
        var _a, _b;
        if (_this9.globalConfig.lockForm) {
          _this9.unlockForm();
        }
        if (_this9.isValid) {
          (_a = _this9.onSuccessCallback) == null ? void 0 : _a.call(_this9, ev);
        } else {
          (_b = _this9.onFailCallback) == null ? void 0 : _b.call(_this9, _this9.fields, _this9.groupFields);
        }
      });
    }
  }, {
    key: "setForm",
    value: function setForm(form) {
      this.form = form;
      this.form.setAttribute("novalidate", "novalidate");
      this.removeListener("submit", this.form, this.formSubmitHandler);
      this.addListener("submit", this.form, this.formSubmitHandler);
    }
  }, {
    key: "addListener",
    value: function addListener(type, elem, handler) {
      elem.addEventListener(type, handler);
      this.eventListeners.push({
        type: type,
        elem: elem,
        func: handler
      });
    }
  }, {
    key: "removeListener",
    value: function removeListener(type, elem, handler) {
      elem.removeEventListener(type, handler);
      this.eventListeners = this.eventListeners.filter(function (item) {
        return item.type !== type || item.elem !== elem;
      });
    }
  }, {
    key: "addField",
    value: function addField(field, rules, config) {
      if (typeof field !== "string") {
        throw Error("Field selector is not valid. Please specify a string selector.");
      }
      var elem = this.form.querySelector(field);
      if (!elem) {
        throw Error("Field with ".concat(field, " selector not found! Please check the field selector."));
      }
      if (!Array.isArray(rules) || !rules.length) {
        throw Error("Rules argument for the field [".concat(field, "] should be an array and should contain at least 1 element."));
      }
      rules.forEach(function (item) {
        if (!("rule" in item || "validator" in item || "plugin" in item)) {
          throw Error("Rules argument for the field [".concat(field, "] must contain at least one rule or validator property."));
        }
        if (!item.validator && !item.plugin && (!item.rule || !Object.values(Rules).includes(item.rule))) {
          throw Error("Rule should be one of these types: ".concat(Object.values(Rules).join(", "), ". Provided value: ").concat(item.rule));
        }
      });
      this.fields[field] = {
        elem: elem,
        rules: rules,
        isValid: void 0,
        config: config
      };
      this.setListeners(elem);
      if (this.isSubmitted) {
        this.validate();
      }
      return this;
    }
  }, {
    key: "removeField",
    value: function removeField(field) {
      if (typeof field !== "string") {
        throw Error("Field selector is not valid. Please specify a string selector.");
      }
      if (!this.fields[field]) {
        console.error("Field not found. Check the field selector.");
        return this;
      }
      var type = this.getListenerType(this.fields[field].elem.type);
      this.removeListener(type, this.fields[field].elem, this.handlerChange);
      this.clearErrors();
      delete this.fields[field];
      return this;
    }
  }, {
    key: "removeGroup",
    value: function removeGroup(group) {
      var _this10 = this;
      if (typeof group !== "string") {
        throw Error("Group selector is not valid. Please specify a string selector.");
      }
      if (!this.groupFields[group]) {
        console.error("Group not found. Check the group selector.");
        return this;
      }
      this.groupFields[group].elems.forEach(function (elem) {
        var type = _this10.getListenerType(elem.type);
        _this10.removeListener(type, elem, _this10.handlerChange);
      });
      this.clearErrors();
      delete this.groupFields[group];
      return this;
    }
  }, {
    key: "addRequiredGroup",
    value: function addRequiredGroup(groupField, errorMessage, config, successMessage) {
      var _this11 = this;
      if (typeof groupField !== "string") {
        throw Error("Group selector is not valid. Please specify a string selector.");
      }
      var elem = this.form.querySelector(groupField);
      if (!elem) {
        throw Error("Group with ".concat(groupField, " selector not found! Please check the group selector."));
      }
      var inputs = elem.querySelectorAll("input");
      var childrenInputs = Array.from(inputs).filter(function (input) {
        var parent = getClosestParent(_this11.groupFields, getNodeParents(input));
        if (!parent) {
          return true;
        }
        return parent[1].elems.find(function (elem2) {
          return elem2 !== input;
        });
      });
      this.groupFields[groupField] = {
        rules: [{
          rule: GroupRules.Required,
          errorMessage: errorMessage,
          successMessage: successMessage
        }],
        groupElem: elem,
        elems: childrenInputs,
        isDirty: false,
        isValid: void 0,
        config: config
      };
      inputs.forEach(function (input) {
        _this11.setListeners(input);
      });
      return this;
    }
  }, {
    key: "getListenerType",
    value: function getListenerType(type) {
      switch (type) {
        case "checkbox":
        case "select-one":
        case "file":
        case "radio":
          {
            return "change";
          }
        default:
          {
            return "input";
          }
      }
    }
  }, {
    key: "setListeners",
    value: function setListeners(elem) {
      var type = this.getListenerType(elem.type);
      this.removeListener(type, elem, this.handlerChange);
      this.addListener(type, elem, this.handlerChange);
    }
  }, {
    key: "clearFieldLabel",
    value: function clearFieldLabel(fieldName) {
      var _a, _b;
      (_a = this.errorLabels[fieldName]) == null ? void 0 : _a.remove();
      (_b = this.successLabels[fieldName]) == null ? void 0 : _b.remove();
    }
  }, {
    key: "clearFieldStyle",
    value: function clearFieldStyle(fieldName) {
      var _field$elem$classList;
      var _a, _b, _c, _d;
      var field = this.fields[fieldName];
      var errorStyle = ((_a = field.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
      Object.keys(errorStyle).forEach(function (key) {
        field.elem.style[key] = "";
      });
      var successStyle = ((_b = field.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
      Object.keys(successStyle).forEach(function (key) {
        field.elem.style[key] = "";
      });
      (_field$elem$classList = field.elem.classList).remove.apply(_field$elem$classList, _toConsumableArray(getClassList(((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass)).concat(_toConsumableArray(getClassList(((_d = field.config) == null ? void 0 : _d.successFieldCssClass) || this.globalConfig.successFieldCssClass))));
    }
  }, {
    key: "clearErrors",
    value: function clearErrors() {
      var _this12 = this;
      var _a, _b;
      Object.keys(this.errorLabels).forEach(function (key) {
        return _this12.errorLabels[key].remove();
      });
      Object.keys(this.successLabels).forEach(function (key) {
        return _this12.successLabels[key].remove();
      });
      for (var fieldName in this.fields) {
        this.clearFieldStyle(fieldName);
      }
      var _loop2 = function _loop2(groupName) {
        var group = _this12.groupFields[groupName];
        var errorStyle = ((_a = group.config) == null ? void 0 : _a.errorFieldStyle) || _this12.globalConfig.errorFieldStyle;
        Object.keys(errorStyle).forEach(function (key) {
          group.elems.forEach(function (elem) {
            var _elem$classList;
            var _a2;
            elem.style[key] = "";
            (_elem$classList = elem.classList).remove.apply(_elem$classList, _toConsumableArray(getClassList(((_a2 = group.config) == null ? void 0 : _a2.errorFieldCssClass) || _this12.globalConfig.errorFieldCssClass)));
          });
        });
        var successStyle = ((_b = group.config) == null ? void 0 : _b.successFieldStyle) || _this12.globalConfig.successFieldStyle || {};
        Object.keys(successStyle).forEach(function (key) {
          group.elems.forEach(function (elem) {
            var _elem$classList2;
            var _a2;
            elem.style[key] = "";
            (_elem$classList2 = elem.classList).remove.apply(_elem$classList2, _toConsumableArray(getClassList(((_a2 = group.config) == null ? void 0 : _a2.successFieldCssClass) || _this12.globalConfig.successFieldCssClass)));
          });
        });
      };
      for (var groupName in this.groupFields) {
        _loop2(groupName);
      }
      this.tooltips = [];
    }
  }, {
    key: "isTooltip",
    value: function isTooltip() {
      return !!this.globalConfig.tooltip;
    }
  }, {
    key: "lockForm",
    value: function lockForm() {
      var elems = this.form.querySelectorAll("input, textarea, button, select");
      for (var i = 0, len = elems.length; i < len; ++i) {
        elems[i].setAttribute("data-just-validate-fallback-disabled", elems[i].disabled ? "true" : "false");
        elems[i].setAttribute("disabled", "disabled");
        elems[i].style.pointerEvents = "none";
        elems[i].style.webkitFilter = "grayscale(100%)";
        elems[i].style.filter = "grayscale(100%)";
      }
    }
  }, {
    key: "unlockForm",
    value: function unlockForm() {
      var elems = this.form.querySelectorAll("input, textarea, button, select");
      for (var i = 0, len = elems.length; i < len; ++i) {
        if (elems[i].getAttribute("data-just-validate-fallback-disabled") !== "true") {
          elems[i].removeAttribute("disabled");
        }
        elems[i].style.pointerEvents = "";
        elems[i].style.webkitFilter = "";
        elems[i].style.filter = "";
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip(elem, errorLabel, position) {
      var _this13 = this;
      var _a;
      var _elem$getBoundingClie = elem.getBoundingClientRect(),
        top = _elem$getBoundingClie.top,
        left = _elem$getBoundingClie.left,
        width = _elem$getBoundingClie.width,
        height = _elem$getBoundingClie.height;
      var errorLabelRect = errorLabel.getBoundingClientRect();
      var pos = position || ((_a = this.globalConfig.tooltip) == null ? void 0 : _a.position);
      switch (pos) {
        case "left":
          {
            errorLabel.style.top = "".concat(top + height / 2 - errorLabelRect.height / 2, "px");
            errorLabel.style.left = "".concat(left - errorLabelRect.width - TOOLTIP_ARROW_HEIGHT, "px");
            break;
          }
        case "top":
          {
            errorLabel.style.top = "".concat(top - errorLabelRect.height - TOOLTIP_ARROW_HEIGHT, "px");
            errorLabel.style.left = "".concat(left + width / 2 - errorLabelRect.width / 2, "px");
            break;
          }
        case "right":
          {
            errorLabel.style.top = "".concat(top + height / 2 - errorLabelRect.height / 2, "px");
            errorLabel.style.left = "".concat(left + width + TOOLTIP_ARROW_HEIGHT, "px");
            break;
          }
        case "bottom":
          {
            errorLabel.style.top = "".concat(top + height + TOOLTIP_ARROW_HEIGHT, "px");
            errorLabel.style.left = "".concat(left + width / 2 - errorLabelRect.width / 2, "px");
            break;
          }
      }
      errorLabel.dataset.direction = pos;
      var refresh = function refresh() {
        _this13.renderTooltip(elem, errorLabel, position);
      };
      return {
        refresh: refresh
      };
    }
  }, {
    key: "createErrorLabelElem",
    value: function createErrorLabelElem(name, errorMessage, config) {
      var _errorLabel$classList;
      var errorLabel = document.createElement("div");
      errorLabel.innerHTML = errorMessage;
      var customErrorLabelStyle = this.isTooltip() ? config == null ? void 0 : config.errorLabelStyle : (config == null ? void 0 : config.errorLabelStyle) || this.globalConfig.errorLabelStyle;
      Object.assign(errorLabel.style, customErrorLabelStyle);
      (_errorLabel$classList = errorLabel.classList).add.apply(_errorLabel$classList, _toConsumableArray(getClassList((config == null ? void 0 : config.errorLabelCssClass) || this.globalConfig.errorLabelCssClass)).concat(["just-validate-error-label"]));
      if (this.isTooltip()) {
        errorLabel.dataset.tooltip = "true";
      }
      if (this.globalConfig.testingMode) {
        errorLabel.dataset.testId = "error-label-".concat(name);
      }
      this.errorLabels[name] = errorLabel;
      return errorLabel;
    }
  }, {
    key: "createSuccessLabelElem",
    value: function createSuccessLabelElem(name, successMessage, config) {
      var _successLabel$classLi;
      if (successMessage === void 0) {
        return null;
      }
      var successLabel = document.createElement("div");
      successLabel.innerHTML = successMessage;
      var customSuccessLabelStyle = (config == null ? void 0 : config.successLabelStyle) || this.globalConfig.successLabelStyle;
      Object.assign(successLabel.style, customSuccessLabelStyle);
      (_successLabel$classLi = successLabel.classList).add.apply(_successLabel$classLi, _toConsumableArray(getClassList((config == null ? void 0 : config.successLabelCssClass) || this.globalConfig.successLabelCssClass)).concat(["just-validate-success-label"]));
      if (this.globalConfig.testingMode) {
        successLabel.dataset.testId = "success-label-".concat(name);
      }
      this.successLabels[name] = successLabel;
      return successLabel;
    }
  }, {
    key: "renderErrorsContainer",
    value: function renderErrorsContainer(label, errorsContainer) {
      var container = errorsContainer || this.globalConfig.errorsContainer;
      if (typeof container === "string") {
        var elem = this.form.querySelector(container);
        if (elem) {
          elem.appendChild(label);
          return true;
        } else {
          console.error("Error container with ".concat(container, " selector not found. Errors will be rendered as usual"));
        }
      }
      if (container instanceof Element) {
        container.appendChild(label);
        return true;
      }
      if (container !== void 0) {
        console.error("Error container not found. It should be a string or existing Element. Errors will be rendered as usual");
      }
      return false;
    }
  }, {
    key: "renderGroupLabel",
    value: function renderGroupLabel(elem, label, errorsContainer, isSuccess) {
      if (!isSuccess) {
        var renderedInErrorsContainer = this.renderErrorsContainer(label, errorsContainer);
        if (renderedInErrorsContainer) {
          return;
        }
      }
      elem.appendChild(label);
    }
  }, {
    key: "renderFieldLabel",
    value: function renderFieldLabel(elem, label, errorsContainer, isSuccess) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!isSuccess) {
        var renderedInErrorsContainer = this.renderErrorsContainer(label, errorsContainer);
        if (renderedInErrorsContainer) {
          return;
        }
      }
      if (elem.type === "checkbox" || elem.type === "radio") {
        var labelElem = document.querySelector("label[for=\"".concat(elem.getAttribute("id"), "\"]"));
        if (((_b = (_a = elem.parentElement) == null ? void 0 : _a.tagName) == null ? void 0 : _b.toLowerCase()) === "label") {
          (_d = (_c = elem.parentElement) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.appendChild(label);
        } else if (labelElem) {
          (_e = labelElem.parentElement) == null ? void 0 : _e.appendChild(label);
        } else {
          (_f = elem.parentElement) == null ? void 0 : _f.appendChild(label);
        }
      } else {
        (_g = elem.parentElement) == null ? void 0 : _g.appendChild(label);
      }
    }
  }, {
    key: "showLabels",
    value: function showLabels(fields, isError) {
      var _this14 = this;
      Object.keys(fields).forEach(function (fieldName, i) {
        var error = fields[fieldName];
        var field = _this14.fields[fieldName];
        field.isValid = !isError;
        _this14.clearFieldStyle(fieldName);
        _this14.clearFieldLabel(fieldName);
        _this14.renderFieldError(fieldName, error);
        if (i === 0 && _this14.globalConfig.focusInvalidField) {
          setTimeout(function () {
            return field.elem.focus();
          }, 0);
        }
      });
    }
  }, {
    key: "showErrors",
    value: function showErrors(fields) {
      if (_typeof(fields) !== "object") {
        throw Error("[showErrors]: Errors should be an object with key: value format");
      }
      this.showLabels(fields, true);
    }
  }, {
    key: "showSuccessLabels",
    value: function showSuccessLabels(fields) {
      if (_typeof(fields) !== "object") {
        throw Error("[showSuccessLabels]: Labels should be an object with key: value format");
      }
      this.showLabels(fields, false);
    }
  }, {
    key: "renderFieldError",
    value: function renderFieldError(fieldName, message) {
      var _field$elem$classList3;
      var _a, _b, _c, _d, _e, _f;
      var field = this.fields[fieldName];
      if (field.isValid) {
        if (!field.asyncCheckPending) {
          var _field$elem$classList2;
          var successLabel = this.createSuccessLabelElem(fieldName, message !== void 0 ? message : field.successMessage, field.config);
          if (successLabel) {
            this.renderFieldLabel(field.elem, successLabel, (_a = field.config) == null ? void 0 : _a.errorsContainer, true);
          }
          (_field$elem$classList2 = field.elem.classList).add.apply(_field$elem$classList2, _toConsumableArray(getClassList(((_b = field.config) == null ? void 0 : _b.successFieldCssClass) || this.globalConfig.successFieldCssClass)));
        }
        return;
      }
      this.isValid = false;
      (_field$elem$classList3 = field.elem.classList).add.apply(_field$elem$classList3, _toConsumableArray(getClassList(((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass)));
      var errorLabel = this.createErrorLabelElem(fieldName, message !== void 0 ? message : field.errorMessage, field.config);
      this.renderFieldLabel(field.elem, errorLabel, (_d = field.config) == null ? void 0 : _d.errorsContainer);
      if (this.isTooltip()) {
        this.tooltips.push(this.renderTooltip(field.elem, errorLabel, (_f = (_e = field.config) == null ? void 0 : _e.tooltip) == null ? void 0 : _f.position));
      }
    }
  }, {
    key: "renderErrors",
    value: function renderErrors() {
      var _this15 = this;
      var forceRevalidation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var _a, _b, _c, _d;
      if (!this.isSubmitted && !forceRevalidation) {
        return;
      }
      this.clearErrors();
      this.isValid = true;
      var _loop3 = function _loop3(groupName) {
        var group = _this15.groupFields[groupName];
        if (group.isValid) {
          group.elems.forEach(function (elem) {
            var _elem$classList3;
            var _a2, _b2;
            Object.assign(elem.style, ((_a2 = group.config) == null ? void 0 : _a2.successFieldStyle) || _this15.globalConfig.successFieldStyle);
            (_elem$classList3 = elem.classList).add.apply(_elem$classList3, _toConsumableArray(getClassList(((_b2 = group.config) == null ? void 0 : _b2.successFieldCssClass) || _this15.globalConfig.successFieldCssClass)));
          });
          var successLabel = _this15.createSuccessLabelElem(groupName, group.successMessage, group.config);
          if (successLabel) {
            _this15.renderGroupLabel(group.groupElem, successLabel, (_a = group.config) == null ? void 0 : _a.errorsContainer, true);
          }
          return "continue";
        }
        _this15.isValid = false;
        group.elems.forEach(function (elem) {
          var _elem$classList4;
          var _a2, _b2;
          Object.assign(elem.style, ((_a2 = group.config) == null ? void 0 : _a2.errorFieldStyle) || _this15.globalConfig.errorFieldStyle);
          (_elem$classList4 = elem.classList).add.apply(_elem$classList4, _toConsumableArray(getClassList(((_b2 = group.config) == null ? void 0 : _b2.errorFieldCssClass) || _this15.globalConfig.errorFieldCssClass)));
        });
        var errorLabel = _this15.createErrorLabelElem(groupName, group.errorMessage, group.config);
        _this15.renderGroupLabel(group.groupElem, errorLabel, (_b = group.config) == null ? void 0 : _b.errorsContainer);
        if (_this15.isTooltip()) {
          _this15.tooltips.push(_this15.renderTooltip(group.groupElem, errorLabel, (_d = (_c = group.config) == null ? void 0 : _c.tooltip) == null ? void 0 : _d.position));
        }
      };
      for (var groupName in this.groupFields) {
        var _ret2 = _loop3(groupName);
        if (_ret2 === "continue") continue;
      }
      for (var fieldName in this.fields) {
        this.renderFieldError(fieldName);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this16 = this;
      this.eventListeners.forEach(function (event) {
        _this16.removeListener(event.type, event.elem, event.func);
      });
      Object.keys(this.customStyleTags).forEach(function (key) {
        _this16.customStyleTags[key].remove();
      });
      this.clearErrors();
      if (this.globalConfig.lockForm) {
        this.unlockForm();
      }
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var _this17 = this;
      this.destroy();
      if (!this.form) {
        console.error("Cannot initialize the library! Form is not defined");
      } else {
        this.initialize(this.form, this.globalConfig);
        Object.keys(this.fields).forEach(function (key) {
          _this17.addField(key, _toConsumableArray(_this17.fields[key].rules), _this17.fields[key].config);
        });
      }
    }
  }, {
    key: "setCurrentLocale",
    value: function setCurrentLocale(locale) {
      if (typeof locale !== "string" && locale !== void 0) {
        console.error("Current locale should be a string");
        return;
      }
      this.currentLocale = locale;
      if (this.isSubmitted) {
        this.validate();
      }
    }
  }, {
    key: "onSuccess",
    value: function onSuccess(callback) {
      this.onSuccessCallback = callback;
      return this;
    }
  }, {
    key: "onFail",
    value: function onFail(callback) {
      this.onFailCallback = callback;
      return this;
    }
  }]);
  return JustValidate;
}();


/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_ios_vh_fix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/ios-vh-fix */ "./js/utils/ios-vh-fix.js");
/* harmony import */ var _modules_modals_init_modals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/modals/init-modals */ "./js/modules/modals/init-modals.js");
/* harmony import */ var _inputmask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inputmask */ "./js/inputmask.js");
/* harmony import */ var _inputmask__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_inputmask__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _just_validate_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./just-validate.es */ "./js/just-validate.es.js");
/* harmony import */ var _imask__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./imask */ "./js/imask.js");
/* harmony import */ var _imask__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_imask__WEBPACK_IMPORTED_MODULE_4__);






// ---------------------------------

window.addEventListener('DOMContentLoaded', function () {
  // Utils
  // ---------------------------------

  Object(_utils_ios_vh_fix__WEBPACK_IMPORTED_MODULE_0__["iosVhFix"])();

  // Modules
  // ---------------------------------

  // все скрипты должны быть в обработчике 'DOMContentLoaded', но не все в 'load'
  // в load следует добавить скрипты, не участвующие в работе первого экрана
  window.addEventListener('load', function () {
    Object(_modules_modals_init_modals__WEBPACK_IMPORTED_MODULE_1__["initModals"])();
  });
});

// ---------------------------------

// ❗❗❗ обязательно установите плагины eslint, stylelint, editorconfig в редактор кода.

// привязывайте js не на классы, а на дата атрибуты (data-validate)

// вместо модификаторов .block--active используем утилитарные классы
// .is-active || .is-open || .is-invalid и прочие (обязателен нейминг в два слова)
// .select.select--opened ❌ ---> [data-select].is-open ✅

// выносим все в дата атрибуты
// url до иконок пинов карты, настройки автопрокрутки слайдера, url к json и т.д.

// для адаптивного JS используется matchMedia и addListener
// const breakpoint = window.matchMedia(`(min-width:1024px)`);
// const breakpointChecker = () => {
//   if (breakpoint.matches) {
//   } else {
//   }
// };
// breakpoint.addListener(breakpointChecker);
// breakpointChecker();

// используйте .closest(el)

var header = document.querySelector('.header');
var accordeonButton = document.querySelector('.footer-menu__control');
var footerMenuWrapper = document.querySelector('.footer-menu__clickarea');
var plusButton = document.querySelector('.footer-menu__control-open');
var minusButton = document.querySelector('.footer-menu__control-close');
var footerList = document.querySelector('.footer-menu__list');
var accordeonIcon = document.querySelector('.footer-contacts__accordeon-icon');
var footerContactsWrapper = document.querySelector('.footer-contacts__pointer');
var contactsList = document.querySelector('.footer-contacts__list');
var plusButtonContacts = document.querySelector('.footer-contacts__plus');
var minusButtonContacts = document.querySelector('.footer-contacts__minus');
var aboutButton = document.querySelector('.about__button');
var aboutText = document.querySelector('.about__text');
var textAfterDivider = document.querySelector('.about__text--after-divider');
var textAfterDividerMobile = document.querySelector('.about__text--after-divider-mobile');
var closeModal = document.querySelector('.modal-window__close');
var modalWindow = document.querySelector('.modal-window');
var headerCallBack = document.querySelector('.header__calback');
var modalWrapper = document.querySelector('.modal-window__wrapper');
var goodsHeader = document.querySelector('.goods__header');
var goodsHeaderMobile = goodsHeader.dataset.mobileText;
var firstScreenButton = document.querySelector('.first-screen__container-button');
var firstScreenButtonMobile = firstScreenButton.dataset.firstScreenButtonMobile;
var featuresItemReg = document.querySelectorAll('.features__item--regular');
var feturesItemFirst = document.querySelector('.features__item--first');

// Убираем синий фон с первой фичи, при наведении на другие

featuresItemReg.forEach(function (item) {
  item.addEventListener('mouseover', function () {
    feturesItemFirst.classList.remove('features__item--active');
    console.log('Hello');
  });
});

// Без JS

footerList.classList.remove('footer-menu__list--no-js');
contactsList.classList.remove('footer-contacts__list--no-js');

// Маска телефона

// let selector = document.querySelector('.feedback-form__phone');
// let im = new Inputmask('+7 (999) 999-99-99');

// im.mask(selector);

// var phoneMask = IMask(
//   document.getElementById('feedback-form__phone'), {
//     mask: '+{7}(000)000-00-00'
//   });

var element = document.querySelector('.feedback-form__phone');
var maskOptions = {
  mask: '+{7}(000)000-00-00',
  minLength: 5
};
var mask = _imask__WEBPACK_IMPORTED_MODULE_4___default()(element, maskOptions);

// Маска телефона для модального окна

var selectorModal = document.querySelector('.modal-window__phone');
var imModal = new _inputmask__WEBPACK_IMPORTED_MODULE_2___default.a('+7 (999) 999-99-99');
imModal.mask(selectorModal);

// Валидация формы

var validation = new _just_validate_es__WEBPACK_IMPORTED_MODULE_3__["default"]('#feedback-form', {
  errorFieldCssClass: 'is-invalid'
});
validation.addField('#feedback-form__name', [{
  rule: 'minLength',
  value: 3,
  errorMessage: 'В имени должно быть больше трёх букв'
}, {
  rule: 'maxLength',
  value: 30
}, {
  rule: 'required',
  errorMessage: 'Укажите Ваше имя'
}]).addField('#agreement', [{
  rule: 'required',
  errorMessage: 'Вы должны согласиться с правилами'
}]).addField('#feedback-form__phone', [{
  rule: 'required',
  errorMessage: 'Укажите Ваш телефон'
}, {
  rule: 'minLength',
  value: 16,
  errorMessage: 'Неверный формат'
}, {
  rule: 'maxLength',
  value: 18
}]).onSuccess(function (event) {
  document.getElementById("feedback-form").submit();
});

// // Валидация модального окна

var validationModal = new _just_validate_es__WEBPACK_IMPORTED_MODULE_3__["default"]('#modal-window');
validationModal.addField('#modal-window__name', [{
  rule: 'minLength',
  value: 3,
  errorMessage: 'В имени должно быть больше трёх букв'
}, {
  rule: 'maxLength',
  value: 30
}, {
  rule: 'required',
  errorMessage: 'Укажите Ваше имя'
}]).addField('#modal-agreement', [{
  rule: 'required',
  errorMessage: 'Вы должны согласиться с правилами'
}]).addField('#modal-window__phone', [{
  rule: 'required',
  errorMessage: 'Укажите Ваш телефон'
}, {
  rule: 'minLength',
  value: 16,
  errorMessage: 'Неверный формат'
}, {
  rule: 'maxLength',
  value: 18
}]).onSuccess(function (event) {
  document.getElementById("modal-window").submit();
});

// Фиксация header в desktop

if (window.matchMedia('(min-width: 1024px)').matches) {
  header.style.position = 'sticky';
  header.style.top = '0';
}
footerMenuWrapper.addEventListener('click', function () {
  if (contactsList.classList.contains('footer-contacts__display')) {
    plusButtonContacts.style['display'] = '';
    minusButtonContacts.style['display'] = '';
    contactsList.style['display'] = '';
    plusButtonContacts.classList.toggle('footer-contacts__no-display');
    minusButtonContacts.classList.toggle('footer-contacts__display');
    contactsList.classList.toggle('footer-contacts__display');
  }
  plusButton.classList.toggle('footer-menu__no-display');
  minusButton.classList.toggle('footer-menu__display');
  footerList.classList.toggle('footer-menu__display');
});
footerContactsWrapper.addEventListener('click', function () {
  if (footerList.classList.contains('footer-menu__display')) {
    plusButton.style['display'] = '';
    minusButton.style['display'] = '';
    footerList.style['display'] = '';
    plusButton.classList.toggle('footer-menu__no-display');
    minusButton.classList.toggle('footer-menu__display');
    footerList.classList.toggle('footer-menu__display');
  }
  plusButtonContacts.classList.toggle('footer-contacts__no-display');
  minusButtonContacts.classList.toggle('footer-contacts__display');
  contactsList.classList.toggle('footer-contacts__display');
});

// Регулировка текста о компании

if (window.matchMedia('(max-width: 767px)').matches) {
  aboutButton.addEventListener('click', function () {
    aboutText.classList.toggle('about__click');
    if (aboutText.classList.contains('about__click')) {
      textAfterDivider.style.display = 'inline';
      textAfterDividerMobile.style.display = 'inline';
      aboutButton.textContent = 'Свернуть';
    } else if (!aboutText.classList.contains('about__click')) {
      textAfterDivider.style.display = 'none';
      textAfterDividerMobile.style.display = 'none';
      aboutButton.textContent = 'Подробнее';
    }
  });
}
if (window.matchMedia('(min-width: 768px)').matches) {
  aboutButton.addEventListener('click', function () {
    aboutText.classList.toggle('about__click');
    if (aboutText.classList.contains('about__click')) {
      textAfterDivider.style.display = 'inline';
      aboutButton.textContent = 'Свернуть';
    } else if (!aboutText.classList.contains('about__click')) {
      textAfterDivider.style.display = 'none';
      // textAfterDividerMobile.style.display = 'inline';
      aboutButton.textContent = 'Подробнее';
    }
  });
}
if (window.matchMedia('(max-width: 767px)').matches) {
  goodsHeader.textContent = goodsHeaderMobile;
  // console.log(goodsHeaderMobile);
  // firstScreenButton.textContent = firstScreenButtonMobile;
}

if (window.matchMedia('(max-width: 767px)').matches) {
  // goodsHeader.textContent = goodsHeaderMobile;
  firstScreenButton.textContent = firstScreenButtonMobile;
}
window.addEventListener('resize', function (event) {
  if (window.matchMedia('(max-width: 767px)').matches) {
    goodsHeader.textContent = goodsHeaderMobile;
  }
  if (window.matchMedia('(min-width: 768px)').matches) {
    goodsHeader.textContent = 'Smart Device предлагает следующие товары и услуги';
  }
}, true);
window.addEventListener('resize', function (event) {
  if (window.matchMedia('(max-width: 767px)').matches) {
    firstScreenButton.textContent = firstScreenButtonMobile;
    footerList.classList.add('footer-menu__no-display');
    contactsList.classList.add('footer-contacts__no-display');
  }
  if (window.matchMedia('(max-width: 767px)').matches) {
    textAfterDividerMobile.style.display = 'none';
  }

  // if (window.matchMedia('(max-width: 767px)').matches) {
  //   aboutButton.addEventListener('click', () => {
  //     aboutText.classList.toggle('about__click');
  //     if (aboutText.classList.contains('about__click')) {
  //       textAfterDivider.style.display = 'inline';
  //       textAfterDividerMobile.style.display = 'inline';
  //       aboutButton.textContent = 'Свернуть';
  //     } else if (!aboutText.classList.contains('about__click')) {
  //       textAfterDivider.style.display = 'none';
  //       textAfterDividerMobile.style.display = 'none';
  //       aboutButton.textContent = 'Подробнее';
  //     }
  //   });
  // }

  if (window.matchMedia('(min-width: 768px)').matches) {
    textAfterDividerMobile.style.display = 'inline';
  }

  // if (window.matchMedia('(min-width: 768px)').matches) {
  //   aboutButton.addEventListener('click', () => {
  //     aboutText.classList.toggle('about__click');
  //     if (aboutText.classList.contains('about__click')) {
  //       textAfterDivider.style.display = 'none';
  //       aboutButton.textContent = 'Свернуть';
  //     } else if (!aboutText.classList.contains('about__click')) {
  //       textAfterDivider.style.display = 'inline';
  //       // textAfterDividerMobile.style.display = 'inline';
  //       aboutButton.textContent = 'Подробнее';
  //     }
  //   });
  // }

  if (window.matchMedia('(min-width: 768px)').matches) {
    firstScreenButton.textContent = 'Получить бесплатную консультацию';
    footerList.classList.remove('footer-menu__no-display');
    contactsList.classList.remove('footer-contacts__no-display');
  }
  if (window.matchMedia('(min-width: 1024px)').matches) {
    header.style.position = 'sticky';
    header.style.top = '0';
  }
  if (window.matchMedia('(max-width: 1023px)').matches) {
    header.style.position = 'relative';
  }
}, true);
if (window.matchMedia('(min-width: 768px)').matches) {
  contactsList.classList.remove('footer-contacts__no-display');
  footerList.classList.remove('footer-menu__no-display');
}

// Модальное окно

headerCallBack.addEventListener('click', function () {
  modalWindow.style.display = 'block';
  document.getElementById('modal-window__name').focus();
  document.body.style.overflow = 'hidden';
});
closeModal.addEventListener('click', function () {
  modalWindow.style.display = 'none';
  document.body.style.overflow = 'auto';
});
modalWindow.addEventListener('click', function (e) {
  var withinBoundaries = e.composedPath().includes(modalWrapper);
  if (!withinBoundaries) {
    modalWindow.style.display = 'none'; // Cкрываем элемент т.к. клик был за его пределами
    document.body.style.overflow = 'auto';
  }
});

// Закрытие модалки по ESC

document.body.addEventListener('keyup', function (e) {
  var key = e.keyCode;
  if (key == 27) {
    modalWindow.style.display = 'none';
    document.body.style.overflow = 'auto';
  }
  ;
}, false);

/***/ }),

/***/ "./js/modules/modals/init-modals.js":
/*!******************************************!*\
  !*** ./js/modules/modals/init-modals.js ***!
  \******************************************/
/*! exports provided: modals, initModals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modals", function() { return modals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initModals", function() { return initModals; });
/* harmony import */ var _modals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modals */ "./js/modules/modals/modals.js");

var modals;

// Здесь реализован пример открытия модалки через колбэк закрытия
// const openModalInCloseCallback = (name, context = this) => {
//   context._enableScrolling = false;
//   context._setSettings('default');
//   modals.open(name);
// };

// closeCallback() {
//   openModalInCloseCallback('modal-5');
// },

var settings = {
  'default': {
    preventDefault: true,
    stopPlay: true,
    lockFocus: true,
    startFocus: true,
    focusBack: true,
    eventTimeout: 400,
    openCallback: false,
    closeCallback: false
  }
};
var initModals = function initModals() {
  var modalElements = document.querySelectorAll('.modal');
  modalElements.forEach(function (el) {
    setTimeout(function () {
      el.classList.remove('modal--preload');
    }, 100);
  });
  modals = new _modals__WEBPACK_IMPORTED_MODULE_0__["Modals"](settings);
  // Используйте в разработке экспортируемую переменную modals, window сделан для бэкэнда
  window.modals = modals;
};


/***/ }),

/***/ "./js/modules/modals/modals.js":
/*!*************************************!*\
  !*** ./js/modules/modals/modals.js ***!
  \*************************************/
/*! exports provided: Modals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Modals", function() { return Modals; });
/* harmony import */ var _utils_scroll_lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/scroll-lock */ "./js/utils/scroll-lock.js");
/* harmony import */ var _utils_focus_lock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/focus-lock */ "./js/utils/focus-lock.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }


var Modals = /*#__PURE__*/function () {
  function Modals() {
    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Modals);
    this._scrollLock = new _utils_scroll_lock__WEBPACK_IMPORTED_MODULE_0__["ScrollLock"]();
    this._focusLock = new _utils_focus_lock__WEBPACK_IMPORTED_MODULE_1__["FocusLock"]();
    this._modalOpenElements = document.querySelectorAll('[data-open-modal]');
    this._openedModalElement = null;
    this._modalName = null;
    this._enableScrolling = true;
    this._settingKey = 'default';
    this._settings = settings;
    this._preventDefault = this._settings[this._settingKey].preventDefault;
    this._stopPlay = this._settings[this._settingKey].stopPlay;
    this._lockFocus = this._settings[this._settingKey].lockFocus;
    this._startFocus = this._settings[this._settingKey].startFocus;
    this._focusBack = this._settings[this._settingKey].focusBack;
    this._eventTimeout = this._settings[this._settingKey].eventTimeout;
    this._openCallback = this._settings[this._settingKey].openCallback;
    this._closeCallback = this._settings[this._settingKey].closeCallback;
    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);
    this._documentClickHandler = this._documentClickHandler.bind(this);
    this._modalClickHandler = this._modalClickHandler.bind(this);
    this._init();
  }
  _createClass(Modals, [{
    key: "_init",
    value: function _init() {
      if (this._modalOpenElements.length) {
        document.addEventListener('click', this._documentClickHandler);
      }
    }
  }, {
    key: "_setSettings",
    value: function _setSettings() {
      var settingKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._settingKey;
      if (!this._settings[settingKey]) {
        return;
      }
      this._preventDefault = typeof this._settings[settingKey].preventDefault === 'boolean' ? this._settings[settingKey].preventDefault : this._settings[this._settingKey].preventDefault;
      this._stopPlay = typeof this._settings[settingKey].stopPlay === 'boolean' ? this._settings[settingKey].stopPlay : this._settings[this._settingKey].stopPlay;
      this._lockFocus = typeof this._settings[settingKey].lockFocus === 'boolean' ? this._settings[settingKey].lockFocus : this._settings[this._settingKey].lockFocus;
      this._startFocus = typeof this._settings[settingKey].startFocus === 'boolean' ? this._settings[settingKey].startFocus : this._settings[this._settingKey].startFocus;
      this._focusBack = typeof this._settings[settingKey].lockFocus === 'boolean' ? this._settings[settingKey].focusBack : this._settings[this._settingKey].focusBack;
      this._eventTimeout = typeof this._settings[settingKey].eventTimeout === 'number' ? this._settings[settingKey].eventTimeout : this._settings[this._settingKey].eventTimeout;
      this._openCallback = this._settings[settingKey].openCallback || this._settings[this._settingKey].openCallback;
      this._closeCallback = this._settings[settingKey].closeCallback || this._settings[this._settingKey].closeCallback;
    }
  }, {
    key: "_documentClickHandler",
    value: function _documentClickHandler(evt) {
      var target = evt.target;
      if (!target.closest('[data-open-modal]')) {
        return;
      }
      evt.preventDefault();
      this._modalName = target.closest('[data-open-modal]').dataset.openModal;
      if (!this._modalName) {
        return;
      }
      this.open();
    }
  }, {
    key: "_documentKeydownHandler",
    value: function _documentKeydownHandler(evt) {
      var isEscKey = evt.key === 'Escape' || evt.key === 'Esc';
      if (isEscKey) {
        evt.preventDefault();
        this.close(document.querySelector('.modal.is-active').dataset.modal);
      }
    }
  }, {
    key: "_modalClickHandler",
    value: function _modalClickHandler(evt) {
      var target = evt.target;
      if (!target.closest('[data-close-modal]')) {
        return;
      }
      this.close(target.closest('[data-modal]').dataset.modal);
    }
  }, {
    key: "_addListeners",
    value: function _addListeners(modal) {
      modal.addEventListener('click', this._modalClickHandler);
      document.addEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "_removeListeners",
    value: function _removeListeners(modal) {
      modal.removeEventListener('click', this._modalClickHandler);
      document.removeEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "_stopInteractive",
    value: function _stopInteractive(modal) {
      if (this._stopPlay) {
        modal.querySelectorAll('video, audio').forEach(function (el) {
          return el.pause();
        });
        modal.querySelectorAll('[data-iframe]').forEach(function (el) {
          el.querySelector('iframe').contentWindow.postMessage('{"event": "command", "func": "pauseVideo", "args": ""}', '*');
        });
      }
    }
  }, {
    key: "_autoPlay",
    value: function _autoPlay(modal) {
      modal.querySelectorAll('[data-iframe]').forEach(function (el) {
        var autoPlay = el.closest('[data-auto-play]');
        if (autoPlay) {
          el.querySelector('iframe').contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
        }
      });
    }
  }, {
    key: "open",
    value: function open() {
      var _this = this;
      var modalName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._modalName;
      var modal = document.querySelector("[data-modal=\"".concat(modalName, "\"]"));
      if (!modal || modal.classList.contains('is-active')) {
        return;
      }
      document.removeEventListener('click', this._documentClickHandler);
      this._openedModalElement = document.querySelector('.modal.is-active');
      if (this._openedModalElement) {
        this._enableScrolling = false;
        this.close(this._openedModalElement.dataset.modal);
      }
      this._setSettings(modalName);
      modal.classList.add('is-active');
      if (!this._openedModalElement) {
        this._scrollLock.disableScrolling();
      }
      if (this._openCallback) {
        this._openCallback();
      }
      if (this._lockFocus) {
        this._focusLock.lock('.modal.is-active', this._startFocus);
      }
      setTimeout(function () {
        _this._addListeners(modal);
        _this._autoPlay(modal);
        document.addEventListener('click', _this._documentClickHandler);
      }, this._eventTimeout);
    }
  }, {
    key: "close",
    value: function close() {
      var _this2 = this;
      var modalName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._modalName;
      var modal = document.querySelector("[data-modal=\"".concat(modalName, "\"]"));
      document.removeEventListener('click', this._documentClickHandler);
      if (!modal || !modal.classList.contains('is-active')) {
        return;
      }
      if (this._lockFocus) {
        this._focusLock.unlock(this._focusBack);
      }
      modal.classList.remove('is-active');
      this._removeListeners(modal);
      this._stopInteractive(modal);
      if (this._closeCallback) {
        this._closeCallback();
      }
      if (this._enableScrolling) {
        setTimeout(function () {
          _this2._scrollLock.enableScrolling();
        }, this._eventTimeout);
      }
      setTimeout(function () {
        document.addEventListener('click', _this2._documentClickHandler);
      }, this._eventTimeout);
      this._setSettings('default');
      this._enableScrolling = true;
    }
  }]);
  return Modals;
}();

/***/ }),

/***/ "./js/utils/focus-lock.js":
/*!********************************!*\
  !*** ./js/utils/focus-lock.js ***!
  \********************************/
/*! exports provided: FocusLock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FocusLock", function() { return FocusLock; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var SELECTORS = ['a[href]', 'area[href]', 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', 'select:not([disabled]):not([aria-hidden])', 'textarea:not([disabled]):not([aria-hidden])', 'button:not([disabled]):not([aria-hidden])', 'iframe', 'object', 'embed', '[contenteditable]', '[tabindex]:not([tabindex^="-"])'];
var FocusLock = /*#__PURE__*/function () {
  function FocusLock() {
    _classCallCheck(this, FocusLock);
    this._lockedSelector = null;
    this._focusableElements = null;
    this._endElement = null;
    this._selectors = SELECTORS;
    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);
  }
  _createClass(FocusLock, [{
    key: "_documentKeydownHandler",
    value: function _documentKeydownHandler(evt) {
      var activeElement = document.activeElement;
      if (evt.key === 'Tab') {
        if (!this._focusableElements.length) {
          evt.preventDefault();
          activeElement.blur();
          return;
        }
        if (this._focusableElements.length === 1) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
        if (this._focusableElements.length > 1 && !activeElement.closest(this._lockedSelector)) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
      }
      if (evt.key === 'Tab' && !evt.shiftKey && activeElement === this._focusableElements[this._focusableElements.length - 1]) {
        evt.preventDefault();
        this._focusableElements[0].focus();
      }
      if (evt.key === 'Tab' && evt.shiftKey && activeElement === this._focusableElements[0]) {
        evt.preventDefault();
        this._focusableElements[this._focusableElements.length - 1].focus();
      }
    }
  }, {
    key: "lock",
    value: function lock(lockedSelector) {
      var startFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.unlock();
      this._lockedSelector = lockedSelector;
      var lockedElement = document.querySelector(this._lockedSelector);
      if (!lockedElement) {
        return;
      }
      this._focusableElements = lockedElement.querySelectorAll(this._selectors);
      this._endElement = document.activeElement;
      var startElement = lockedElement.querySelector('[data-focus]') || this._focusableElements[0];
      if (this._endElement) {
        this._endElement.blur();
      }
      if (startElement && startFocus) {
        startElement.focus();
      }
      document.addEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "unlock",
    value: function unlock() {
      var returnFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (this._endElement && returnFocus) {
        this._endElement.focus();
      }
      this._lockedSelector = null;
      this._focusableElements = null;
      this._endElement = null;
      document.removeEventListener('keydown', this._documentKeydownHandler);
    }
  }]);
  return FocusLock;
}();
window.focusLock = new FocusLock();

/***/ }),

/***/ "./js/utils/ios-checker.js":
/*!*********************************!*\
  !*** ./js/utils/ios-checker.js ***!
  \*********************************/
/*! exports provided: iosChecker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iosChecker", function() { return iosChecker; });
var iosChecker = function iosChecker() {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)
  // iPad on iOS 13 detection
  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;
};

/***/ }),

/***/ "./js/utils/ios-vh-fix.js":
/*!********************************!*\
  !*** ./js/utils/ios-vh-fix.js ***!
  \********************************/
/*! exports provided: iosVhFix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iosVhFix", function() { return iosVhFix; });
/* harmony import */ var _ios_checker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ios-checker */ "./js/utils/ios-checker.js");

var iosVhFix = function iosVhFix() {
  if (!(!!window.MSInputMethodContext && !!document.documentMode)) {
    if (Object(_ios_checker__WEBPACK_IMPORTED_MODULE_0__["iosChecker"])()) {
      var vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      window.addEventListener('resize', function () {
        vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      });
    }
  }
};


/***/ }),

/***/ "./js/utils/scroll-lock.js":
/*!*********************************!*\
  !*** ./js/utils/scroll-lock.js ***!
  \*********************************/
/*! exports provided: ScrollLock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollLock", function() { return ScrollLock; });
/* harmony import */ var _ios_checker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ios-checker */ "./js/utils/ios-checker.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var ScrollLock = /*#__PURE__*/function () {
  function ScrollLock() {
    _classCallCheck(this, ScrollLock);
    this._iosChecker = _ios_checker__WEBPACK_IMPORTED_MODULE_0__["iosChecker"];
    this._lockClass = this._iosChecker() ? 'scroll-lock-ios' : 'scroll-lock';
    this._scrollTop = null;
    this._fixedBlockElements = document.querySelectorAll('[data-fix-block]');
  }
  _createClass(ScrollLock, [{
    key: "_getScrollbarWidth",
    value: function _getScrollbarWidth() {
      return window.innerWidth - document.documentElement.clientWidth;
    }
  }, {
    key: "_getBodyScrollTop",
    value: function _getBodyScrollTop() {
      return self.pageYOffset || document.documentElement && document.documentElement.ScrollTop || document.body && document.body.scrollTop;
    }
  }, {
    key: "disableScrolling",
    value: function disableScrolling() {
      var _this = this;
      this._scrollTop = document.body.dataset.scroll = document.body.dataset.scroll ? document.body.dataset.scroll : this._getBodyScrollTop();
      if (this._getScrollbarWidth()) {
        document.body.style.paddingRight = "".concat(this._getScrollbarWidth(), "px");
        this._fixedBlockElements.forEach(function (block) {
          block.style.paddingRight = "".concat(_this._getScrollbarWidth(), "px");
        });
      }
      document.body.style.top = "-".concat(this._scrollTop, "px");
      document.body.classList.add(this._lockClass);
    }
  }, {
    key: "enableScrolling",
    value: function enableScrolling() {
      document.body.classList.remove(this._lockClass);
      window.scrollTo(0, +document.body.dataset.scroll);
      document.body.style.paddingRight = null;
      document.body.style.top = null;
      this._fixedBlockElements.forEach(function (block) {
        block.style.paddingRight = null;
      });
      document.body.removeAttribute('data-scroll');
      this._scrollTop = null;
    }
  }]);
  return ScrollLock;
}();
window.scrollLock = new ScrollLock();

/***/ })

/******/ });
//# sourceMappingURL=main.min.js.map